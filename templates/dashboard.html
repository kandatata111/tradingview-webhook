<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>ダウ雲表 v2</title>
<style>
body { font-family: 'Yu Gothic', 'Meiryo', sans-serif; background: #1e3c72; color: #fff; padding: 0 !important; margin: 0 !important; }
.container { max-width: none; margin: 0 !important; padding: 0; }
.header-row { display:flex; align-items:center; justify-content:space-between; padding: 10px 10px 12px 6px; margin: 0 8px 14px 6px; border-bottom: 1px solid rgba(255,255,255,0.45); }
h1 { text-align: left; margin: 0; font-size: 1.55em; letter-spacing: 0.4px; text-shadow: none; }
#dashboard { margin: 0; padding: 0 8px 8px 6px; }
/* 設定パネルスタイル */
.settings { display: flex; gap: 12px; justify-content: flex-end; align-items: center; margin-bottom: 12px; }
.settings label { color: #fff; font-size: 0.95em; }
.settings select, .settings input[type="radio"] { margin-left: 6px; }

/* 設定モーダル */
.settings-button { background:transparent;color:#f5f7ff;border:1px solid rgba(255,255,255,0.8);padding:7px 16px;border-radius:999px;cursor:pointer;display:flex;align-items:center;gap:6px;transition:background 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
.settings-button::before { content:'\2699'; font-size:1.05em; }
.settings-button:hover { background:rgba(255,255,255,0.15); color:#ffffff; }
.modal-overlay { position:fixed; left:0;top:0;right:0;bottom:0; background: rgba(0,0,0,0.4); display:none; align-items:center; justify-content:center; z-index:9999 }
  .modal { background:rgba(255,255,255,0.18); color:#f5f7ff; padding:20px 22px; border-radius:14px; min-width:280px; position:relative; cursor:move; user-select:none; backdrop-filter:blur(14px); -webkit-backdrop-filter:blur(14px); border:1px solid rgba(255,255,255,0.35); box-shadow:0 18px 40px rgba(0,0,0,0.35); max-height:80vh; overflow:auto; }
.modal h3 { margin-top:0; cursor:move; font-weight:600; letter-spacing:0.5px; }
.modal .row { margin-bottom:12px }
.modal label { color:#f5f7ff; }
.modal select, .modal input[type="checkbox"], .modal input[type="radio"] { accent-color:#7ea6ff; }
.modal select { min-width:140px; background:rgba(15,27,65,0.7); color:#f5f7ff; border:1px solid rgba(255,255,255,0.35); border-radius:8px; padding:6px 10px; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.15); }
.modal button { background:rgba(10,20,55,0.6) !important; color:#f5f7ff !important; border:1px solid rgba(255,255,255,0.35) !important; padding:6px 12px !important; border-radius:8px !important; box-shadow:0 8px 18px rgba(0,0,0,0.35); transition:background 0.2s ease, transform 0.2s ease; }
.modal button:hover { background:rgba(30,60,140,0.7) !important; transform:translateY(-1px); }
  .modal .section-header { background:#000; color:#fff; padding:6px 10px; margin:8px 0 10px 0; border-radius:6px; font-weight:600; font-size:0.95em; letter-spacing:0.3px; display:flex; justify-content:space-between; align-items:center; }
  .section-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.5em; line-height:1; padding:0; margin:0; transition:transform 0.2s ease; }
  .section-toggle:hover { transform:scale(1.15); }
  .subsection-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .subsection-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.2em; line-height:1; padding:2px 6px; margin:0; transition:transform 0.2s ease; }
  .subsection-toggle:hover { opacity:0.7; }

/* ライト／ダークモード（テーブル色は JS で変更しないように注意） */
.light-mode { background: #f5f5f5 !important; color: #111 !important; }
.light-mode .header-row { border-bottom: 1px solid rgba(0,0,0,0.5); }
.light-mode h1 { color: #111 !important; }
.light-mode .settings-button { color:#111; border-color: rgba(0,0,0,0.7); }
.light-mode .settings-button:hover { background: rgba(0,0,0,0.08); color:#000; }
.dark-mode { background: #1e3c72 !important; color: #fff !important; }

table { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; width: auto; border-collapse: collapse; background: #fff; color: #333; table-layout: auto; margin: 0; }
/* テーブルを角丸にするためのラッパー */
.table-wrap { border-radius: 8px; overflow: hidden; display: inline-block; }
th, td { padding: 4px; border: 1px solid #ddd; text-align: center; white-space: nowrap; width: auto; }
th { font-family: Arial; background: #667eea; color: white; }
.tf-label { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; color: #667eea; }
.up { color: #2962ff; font-weight: bold; }
.down { color: #ef4444; font-weight: bold; }
.loading { text-align: left; padding: 50px; }

/* 新規スタイル */
.header-black { background: #000 !important; color: #fff !important; }
.cell-black { background: #000 !important; color: #fff !important; }
.col-cloud-label { color: #000 !important; }
.price-row td:first-child { background: #fff !important; color: #000 !important; font-weight: bold; }
/* ヘッダーは現状のまま維持し、データ部(td)のみフォントを一段階細くする */
table th { font-weight: bold; font-size: 1.1em; }
table td { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; }
/* ダウ時間(9列目) と 交差時間(10列目) を右揃えにする */
table th:nth-child(9), table td:nth-child(9),
table th:nth-child(10), table td:nth-child(10),
table th:nth-child(11), table td:nth-child(11) {
  text-align: right;
}
/* ヘッダーのダウ時間と交差時間をセンター揃え */
table th:nth-child(9), table th:nth-child(10), table th:nth-child(11) {
  text-align: center;
}

/* 発火履歴ウィンドウ */
.main-content { display: flex; gap: 12px; align-items: flex-start; }
#dashboard { flex: 0 0 auto; }
#fire-history { 
  flex: 0 0 300px; 
  background: rgba(255,255,255,0.1); 
  border: 1px solid rgba(255,255,255,0.25); 
  border-radius: 8px; 
  padding: 12px; 
  overflow: hidden;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
}
#fire-history-header { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
#fire-history h3 { 
  margin: 0; 
  font-size: 1em;
  color: #f5f7ff; 
  font-weight: 600;
}
#test-fire-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
#test-fire-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
#fire-history-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
}
.fire-item { 
  padding: 8px; 
  margin-bottom: 6px; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  font-size: 0.9em; 
  border-left: 3px solid #667eea;
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.fire-item:hover { background: rgba(0,0,0,0.3); }
.fire-time { color: #a0c4ff; font-weight: 600; white-space: nowrap; }
.fire-name { color: #ffd700; font-weight: 600; }
.light-mode #fire-history { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.2); }
.light-mode #fire-history-header { border-bottom-color: rgba(0,0,0,0.2); }
.light-mode #test-fire-btn { background: rgba(102, 126, 234, 0.15); color: #4a5eb4; border-color: #4a5eb4; }
.light-mode #test-fire-btn:hover { background: rgba(102, 126, 234, 0.3); }
.light-mode .fire-item { background: rgba(0,0,0,0.08); border-left-color: #667eea; }
.light-mode .fire-time { color: #2962ff; }
.light-mode .fire-name { color: #d97706; }
</style>
</head>
<body>
<div class="container">
<!-- タイトルと設定ボタンを横並び -->
<div class="header-row">
  <h1>ダウ雲表</h1>
  <button id="openSettings" class="settings-button">設定</button>
</div>

<!-- 設定モーダル（初期は非表示） -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <h3 id="settingsTitle" style="margin:0">各項目設定</h3>
    <button id="closeSettings" style="background:#333;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer">閉じる</button>
  </div>
    
    <!-- 表示調整セクション -->
  <div class="section-header" data-section="displayAdjust">表示調整 <button class="section-toggle" data-section="displayAdjust" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="displayAdjust">
  <div class="row">
      <label>モード</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="dark" id="modeDark"> ダーク</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="light" id="modeLight"> ライト</label>
    </div>
    <div class="row">
      <label for="fontSizeSelect">文字サイズ</label>
      <select id="fontSizeSelect" aria-label="表の文字サイズ">
        <option value="10">10px</option>
        <option value="11">11px</option>
        <option value="12">12px</option>
        <option value="13">13px</option>
        <option value="14">14px</option>
        <option value="15">15px</option>
        <option value="16">16px</option>
        <option value="17">17px</option>
        <option value="18">18px</option>
      </select>
    </div>
    <div class="row">
      <label for="timeFormatSelect">経過時間の表示</label>
      <select id="timeFormatSelect" aria-label="経過時間の表示形式">
        <option value="datetime">測定開始日時</option>
        <option value="dhm">日/時/分</option>
        <option value="hm">時/分</option>
        <option value="m">分のみ</option>
      </select>
    </div>
    <div class="row">
      <label for="updateDelayInput">更新時間の調整 (秒)</label>
      <input type="number" id="updateDelayInput" min="0" max="300" step="1" value="10" aria-label="データ更新の遅延時間（秒）" style="min-width:80px; background:rgba(15,27,65,0.7); color:#f5f7ff; border:1px solid rgba(255,255,255,0.35); border-radius:8px; padding:6px 10px; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.15);">
    </div>
    
    <!-- 列の表示セクション -->
  </div>
  <div class="section-header" data-section="columns">列の表示 <button class="section-toggle" data-section="columns" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="columns">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="1" checked> ダウ転</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="2" checked> 突破数</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="3" checked> 雲交差</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="4" checked> 各雲間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="5" checked> 価格間</label>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="6" checked> 雲角度</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="7" checked> 雲厚み</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="8" checked> ダウ時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="9" checked> 交差時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="10" checked> 時間差</label>
      </div>
    </div>
    
    <!-- 行の表示セクション -->
  </div>
  <div class="section-header" data-section="rows">行の表示 <button class="section-toggle" data-section="rows" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="rows">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="5m" checked> 5m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="15m" checked> 15m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="1H" checked> 1H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="4H" checked> 4H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="price" checked> 価格</label>
      </div>
    </div>
    
    <!-- 通貨フィルターセクション -->
  </div>
  <div class="section-header" data-section="currencies">通貨フィルター <button class="section-toggle" data-section="currencies" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="currencies">
  <div class="row">
      <div id="currencyFilterContainer" style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <!-- 通貨チェックボックスは動的に生成されます -->
      </div>
  </div>
  </div>

    <!-- 音声設定セクション（グローバル設定のみ） -->
    <div class="section-header" data-section="voice">音声設定 <button class="section-toggle" data-section="voice" aria-expanded="true">▾</button></div>
    <div class="section-body" data-section-body="voice">
    <div class="row">
      <label for="voiceVolume">音量</label>
      <input type="range" id="voiceVolume" min="0" max="1" step="0.01" value="0.8" aria-label="音量" style="min-width:150px;">
      <span id="voiceVolumeValue" style="margin-left:8px">80%</span>
    </div>
    <div class="row">
      <label for="voiceRate">音速</label>
      <input type="range" id="voiceRate" min="0.5" max="2.0" step="0.1" value="1.0" aria-label="音速" style="min-width:150px;">
      <span id="voiceRateValue" style="margin-left:8px">1.0x</span>
    </div>
    </div>

    <!-- 発火条件セクション -->
    <div class="section-header" data-section="rules">発火条件（ルール） <button class="section-toggle" data-section="rules" aria-expanded="true">▾</button></div>
    <div class="section-body" data-section-body="rules">
    <div class="row" style="display:flex;flex-direction:column;gap:10px">
      <div style="width:100%; max-height:220px; overflow:auto; border:1px solid rgba(255,255,255,0.08); padding:8px; border-radius:8px; background:rgba(0,0,0,0.12);">
        <div class="subsection-header">
          <strong>保存済みルール</strong>
          <div style="display:flex;gap:6px;align-items:center">
            <button id="newRuleBtn" style="font-size:0.9em;padding:4px 8px">新規ルール作成</button>
            <button class="subsection-toggle" data-subsection="savedRules" aria-expanded="true">▾</button>
          </div>
        </div>
        <div class="subsection-body" data-subsection-body="savedRules">
          <ul id="rulesList" style="list-style:none;padding:0;margin:0;display:block"></ul>
        </div>
      </div>

      <div style="width:100%; max-height:360px; overflow:auto; border:1px solid rgba(255,255,255,0.08); padding:8px; border-radius:8px; background:rgba(0,0,0,0.06);">
        <div class="subsection-header">
          <strong>ルール編集</strong>
          <button class="subsection-toggle" data-subsection="ruleEditor" aria-expanded="true">▾</button>
        </div>
        <div class="subsection-body" data-subsection-body="ruleEditor">
        <div style="display:flex;gap:8px;flex-direction:column">
          <input id="ruleName" placeholder="ルール名" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit">
          <select id="ruleScope" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit">
            <option value="">全通貨</option>
          </select>
          
          <!-- 音声設定（ルール個別設定） -->
          <div style="margin-top:12px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.04);">
            <div style="font-weight:600;margin-bottom:6px">音声設定</div>
            <div style="display:flex;flex-direction:column;gap:6px">
              <label style="font-size:0.9em">
                音声メッセージ:
                <input id="voiceMessage" placeholder="例: ルールが発火しました" style="margin-left:8px;padding:4px;border-radius:4px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:300px">
              </label>
              <label style="font-size:0.9em">
                <input type="checkbox" id="voiceDirectionBased"> 方向別アラーム
                <select id="voiceMessagePosition" style="margin-left:8px;padding:4px;border-radius:4px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;">
                  <option value="prefix">先頭</option>
                  <option value="suffix">最後</option>
                  <option value="both">先頭と最後</option>
                </select>
              </label>
              <div id="directionMessages" style="display:none;flex-direction:row;gap:12px;margin-left:8px;align-items:center">
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  上昇：
                  <input id="voiceMessageUp" placeholder="例: 上昇トレンドが検出されました" style="padding:4px;border-radius:4px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  下降：
                  <input id="voiceMessageDown" placeholder="例: 下降トレンドが検出されました" style="padding:4px;border-radius:4px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
              </div>
              <label style="font-size:0.9em;display:flex;align-items:center;gap:8px">
                音声選択:
                <select id="voiceSelect" style="margin-left:8px;padding:4px;border-radius:4px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:200px">
                  <option value="">グローバル設定を使用</option>
                  <!-- 音声リストは動的に追加 -->
                </select>
                <button id="testVoiceBtn" style="padding:6px 12px;">テスト再生</button>
              </label>
            </div>
          </div>
          
          <!-- 雲整列条件 UI（ユーザー指定レイアウト） -->
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:6px;padding:6px;border-radius:6px;background:rgba(0,0,0,0.02);">
            <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">
              <strong style="margin-right:6px">雲整列条件</strong>
              <label style="font-size:0.9em"><input type="checkbox" id="alignAllTf"> 全時間</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="5m"> 5m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="15m"> 15m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="1H"> 1H</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="4H"> 4H</label>
            </div>
            <div style="display:flex;align-items:center;gap:12px">
              <div style="display:flex;align-items:center;gap:8px">
                <label style="font-size:0.95em">欠損</label>
                <select id="alignMissing" style="padding:6px;border-radius:6px;background:rgba(15,27,65,0.7);color:inherit;border:1px solid rgba(255,255,255,0.12)">
                  <option value="ignore">無視</option>
                  <option value="fail">不一致</option>
                </select>
              </div>
              <div style="display:flex;align-items:center;gap:8px">
                <label style="font-size:0.95em">閾値N</label>
                <select id="alignN" style="padding:6px;border-radius:6px;background:rgba(15,27,65,0.7);color:inherit;border:1px solid rgba(255,255,255,0.12)">
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="off">無効</option>
                </select>
              </div>
            </div>
            <div id="alignError" style="color:#ffb4b4;font-weight:600;margin-top:6px;display:none;width:100%"></div>
          </div>
          <div id="conditionsContainer" style="display:flex;flex-direction:column;gap:6px">
            <!-- 単純な1条件行のテンプレート -->
            <div class="cond-row" style="display:flex;gap:6px;align-items:center">
              <select class="cond-tf" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="5m">5m</option>
                <option value="15m">15m</option>
                <option value="1H">1H</option>
                <option value="4H">4H</option>
              </select>
              <select class="cond-field" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="dauten">ダウ転</option>
                <option value="bos_count">突破数</option>
                <option value="gc">雲交差</option>
                <option value="distance_from_prev">各雲間</option>
                <option value="distance_from_price">価格間</option>
                <option value="angle">雲角度</option>
                <option value="thickness">雲厚み</option>
                <option value="transfer_time_diff">転換時間差</option>
              </select>
              <select class="cond-op" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="==">==</option>
                <option value=">=">&gt;=</option>
                <option value=">">&gt;</option>
                <option value="<=">&lt;=</option>
                <option value="<">&lt;</option>
              </select>
              <input class="cond-value" placeholder="値" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit;width:120px">
              <button class="removeCond" style="padding:4px 8px">削除</button>
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button id="addCondBtn">条件を追加</button>
            <button id="testRuleBtn">ルールをテスト</button>
            <button id="saveRuleBtn" style="margin-left:auto">ルールを保存</button>
          </div>
          <div style="margin-top:8px">
            <div style="font-weight:600;margin-bottom:4px">テスト結果</div>
            <div id="ruleTestResult" style="background:rgba(0,0,0,0.06);color:inherit;padding:8px;border-radius:6px;max-height:260px;overflow:auto">
              <div class="test-summary" style="display:flex;align-items:center;gap:10px">
                <div id="testBadge" style="font-weight:700;padding:6px 10px;border-radius:6px;background:#444;color:#fff">未実行</div>
                <div id="testShort" style="opacity:0.9">ルールを実行して結果を確認してください</div>
              </div>
              <div id="testDetails" style="margin-top:8px;font-size:0.9em;color:inherit">結果の詳細はここに表示されます。</div>
            </div>
          </div>
        </div>
        </div>
      </div>
    </div>
    </div>
  </div>
</div>

<div class="main-content">
  <div id="dashboard" class="loading">読み込み中...</div>
  <div id="fire-history">
    <div id="fire-history-header">
      <h3>ドル円発火履歴</h3>
      <button id="test-fire-btn">テスト発火</button>
    </div>
    <div id="fire-history-list">
      <div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">
        履歴なし
      </div>
    </div>
  </div>
</div>
</div>
<script>
// Version check and cache buster - 2025-11-08-v1
(function() {
  const REQUIRED_VERSION = '2025-11-08-v1';
  const currentVersion = localStorage.getItem('app_version');
  if (currentVersion !== REQUIRED_VERSION) {
    console.log('[VERSION] Updating from', currentVersion, 'to', REQUIRED_VERSION);
    localStorage.setItem('app_version', REQUIRED_VERSION);
    if (currentVersion && currentVersion !== REQUIRED_VERSION) {
      console.log('[VERSION] Hard reload required');
      window.location.reload(true);
      return;
    }
  }
})();

// 設定パネルの動作: モード切替（body にクラス付与）とフォントサイズの適用
function applyMode(mode) {
  document.body.classList.remove('light-mode','dark-mode');
  if (mode === 'light') document.body.classList.add('light-mode');
  else document.body.classList.add('dark-mode');
}

function applyFontSize(px) {
  // テーブルの th と td にのみフォントサイズを適用（セルの色は変更しない）
  const els = document.querySelectorAll('table th, table td');
  els.forEach(el => {
    el.style.fontSize = px + 'px';
  });
  
  // 発火履歴の全要素にフォントサイズを適用
  const fireHistoryEls = document.querySelectorAll('#fire-history h3, #test-fire-btn, .fire-item, .fire-time, .fire-name, #fire-history-list');
  fireHistoryEls.forEach(el => {
    el.style.fontSize = px + 'px';
  });
}

function applyColumnVisibility() {
  const cols = document.querySelectorAll('.col-toggle');
  cols.forEach(cb => {
    const colIndex = parseInt(cb.dataset.col);
    const visible = cb.checked;
    // colIndex は 1-indexed（雲整列は0列目、ダウ転は1列目...）
    const selector = `table th:nth-child(${colIndex + 1}), table td:nth-child(${colIndex + 1})`;
    document.querySelectorAll(selector).forEach(el => {
      el.style.display = visible ? '' : 'none';
    });
  });
}

function applyRowVisibility() {
  const rows = document.querySelectorAll('.row-toggle');
  rows.forEach(cb => {
    const rowLabel = cb.dataset.row;
    const visible = cb.checked;
    // 各行は tf-label セルの textContent で識別
    const allRows = document.querySelectorAll('table tr');
    allRows.forEach(tr => {
      const labelCell = tr.querySelector('.tf-label');
      if (labelCell) {
        const text = labelCell.textContent.trim();
        if ((rowLabel === 'price' && text === '価格') ||
            (rowLabel === '5m' && text === '5m') ||
            (rowLabel === '15m' && text === '15m') ||
            (rowLabel === '1H' && text === '1H') ||
            (rowLabel === '4H' && text === '4H')) {
          tr.style.display = visible ? '' : 'none';
        }
      }
    });
  });
}

function applyCurrencyFilter() {
  const currencies = document.querySelectorAll('.currency-toggle');
  const enabled = new Set();
  currencies.forEach(cb => {
    if (cb.checked) enabled.add(cb.dataset.currency);
  });
  
  // テーブル全体を通貨でフィルター
  // 現在は単一通貨のみ表示なので、選択された通貨かどうかで表示制御
  const allTables = document.querySelectorAll('table');
  allTables.forEach(table => {
    const header = table.querySelector('th');
    if (header) {
      const headerText = header.textContent.trim();
      const symbol = headerText.split(' ')[0]; // "USDJPY - 153.45" → "USDJPY"
      if (enabled.has(symbol)) {
        table.style.display = '';
      } else {
        table.style.display = 'none';
      }
    }
  });
}

function updateCurrencyFilter(availableCurrencies) {
  const container = document.getElementById('currencyFilterContainer');
  const savedCurrencies = JSON.parse(localStorage.getItem('tv_currencies') || '{}');
  
  // 既存のチェックボックスの通貨を記録
  const existingCurrencies = new Set();
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    existingCurrencies.add(cb.dataset.currency);
  });
  
  // 新しい通貨があれば追加
  availableCurrencies.forEach(currency => {
    if (!existingCurrencies.has(currency)) {
      const label = document.createElement('label');
      label.style.fontSize = '0.9em';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'currency-toggle';
      checkbox.dataset.currency = currency;
      checkbox.checked = (savedCurrencies[currency] !== false); // デフォルトtrue
      
      checkbox.addEventListener('change', () => {
        const currencies = {};
        document.querySelectorAll('.currency-toggle').forEach(cb => {
          currencies[cb.dataset.currency] = cb.checked;
        });
        localStorage.setItem('tv_currencies', JSON.stringify(currencies));
        applyCurrencyFilter();
      });
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(' ' + currency));
      container.appendChild(label);
    }
  });
  
  // 保存された設定を適用
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    const currency = cb.dataset.currency;
    cb.checked = (savedCurrencies[currency] !== false);
  });
  
  applyCurrencyFilter();
}

function loadSettings() {
  const savedMode = localStorage.getItem('tv_mode') || 'dark';
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  const savedCols = JSON.parse(localStorage.getItem('tv_cols') || '{}');
  const savedRows = JSON.parse(localStorage.getItem('tv_rows') || '{}');
  const savedTimeFormat = localStorage.getItem('tv_time_format') || 'datetime';
  const savedUpdateDelay = localStorage.getItem('tv_update_delay') || '10';
  const savedVoiceVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
  const savedVoiceRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
  
  // set UI
  document.getElementById('modeDark').checked = (savedMode === 'dark');
  document.getElementById('modeLight').checked = (savedMode === 'light');
  document.getElementById('fontSizeSelect').value = savedSize;
  document.getElementById('timeFormatSelect').value = savedTimeFormat;
  document.getElementById('updateDelayInput').value = savedUpdateDelay;
  document.getElementById('voiceVolume').value = savedVoiceVolume;
  document.getElementById('voiceVolumeValue').textContent = Math.round(savedVoiceVolume * 100) + '%';
  document.getElementById('voiceRate').value = savedVoiceRate;
  document.getElementById('voiceRateValue').textContent = savedVoiceRate.toFixed(1) + 'x';
  
  // 列チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    const col = cb.dataset.col;
    cb.checked = (savedCols[col] !== false); // デフォルトtrue
  });
  
  // 行チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    const row = cb.dataset.row;
    cb.checked = (savedRows[row] !== false); // デフォルトtrue
  });
  
  applyMode(savedMode);
  applyFontSize(savedSize);
  applyColumnVisibility();
  applyRowVisibility();
}

function wireSettings() {
  document.getElementById('modeDark').addEventListener('change', e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','dark'); applyMode('dark'); }
  });
  document.getElementById('modeLight').addEventListener('change', e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','light'); applyMode('light'); }
  });
  document.getElementById('fontSizeSelect').addEventListener('change', e => {
    localStorage.setItem('tv_font_size', e.target.value);
    applyFontSize(e.target.value);
  });
  
  // 列表示チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    cb.addEventListener('change', () => {
      const cols = {};
      document.querySelectorAll('.col-toggle').forEach(c => {
        cols[c.dataset.col] = c.checked;
      });
      localStorage.setItem('tv_cols', JSON.stringify(cols));
      applyColumnVisibility();
    });
  });
  
  // 行表示チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    cb.addEventListener('change', () => {
      const rows = {};
      document.querySelectorAll('.row-toggle').forEach(r => {
        rows[r.dataset.row] = r.checked;
      });
      localStorage.setItem('tv_rows', JSON.stringify(rows));
      applyRowVisibility();
    });
  });
  
  // 経過時間形式プルダウン
  document.getElementById('timeFormatSelect').addEventListener('change', e => {
    localStorage.setItem('tv_time_format', e.target.value);
    load(); // 再読み込みして表示を更新
  });
  
  // 更新時間の調整
  document.getElementById('updateDelayInput').addEventListener('change', async e => {
    const delay = parseInt(e.target.value);
    if (isNaN(delay) || delay < 0 || delay > 300) {
      alert('更新時間は0-300秒の範囲で入力してください');
      e.target.value = localStorage.getItem('tv_update_delay') || '10';
      return;
    }
    localStorage.setItem('tv_update_delay', delay.toString());
    // サーバーに設定を保存
    try {
      const res = await fetch('/api/settings', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ update_delay_seconds: delay })
      });
      const data = await res.json();
      if (data.status !== 'success') {
        alert('設定保存に失敗しました: ' + (data.msg || '不明なエラー'));
      }
    } catch (err) {
      console.error('設定保存エラー:', err);
      alert('設定保存中にエラーが発生しました');
    }
  });
  
  // 音声設定（グローバル）
  document.getElementById('voiceVolume').addEventListener('input', e => {
    const vol = parseFloat(e.target.value);
    document.getElementById('voiceVolumeValue').textContent = Math.round(vol * 100) + '%';
    localStorage.setItem('tv_voice_volume', vol.toString());
  });
  document.getElementById('voiceRate').addEventListener('input', e => {
    const rate = parseFloat(e.target.value);
    document.getElementById('voiceRateValue').textContent = rate.toFixed(1) + 'x';
    localStorage.setItem('tv_voice_rate', rate.toString());
  });
}

function wireSectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_sections') || '{}');
    document.querySelectorAll('.section-toggle').forEach(btn => {
      const sec = btn.dataset.section;
      const body = document.querySelector(`.section-body[data-section-body="${sec}"]`);
      if (!body) return;
      const expanded = (saved[sec] !== undefined) ? !!saved[sec] : true;
      body.style.display = expanded ? '' : 'none';
      btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      btn.textContent = expanded ? '▾' : '▸';
      btn.addEventListener('click', () => {
        const cur = body.style.display !== 'none';
        const next = !cur;
        body.style.display = next ? '' : 'none';
        btn.setAttribute('aria-expanded', next ? 'true' : 'false');
        btn.textContent = next ? '▾' : '▸';
        const s = JSON.parse(localStorage.getItem('tv_sections') || '{}');
        s[sec] = next;
        localStorage.setItem('tv_sections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSectionToggles error', e);
  }
}

// Wire subsection toggles (for saved rules and rule editor)
function wireSubsectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
    document.querySelectorAll('.subsection-toggle').forEach(btn => {
      const subsec = btn.dataset.subsection;
      const body = document.querySelector(`.subsection-body[data-subsection-body="${subsec}"]`);
      if (!body) return;
      const expanded = (saved[subsec] !== undefined) ? !!saved[subsec] : true;
      body.style.display = expanded ? '' : 'none';
      btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      btn.textContent = expanded ? '▾' : '▸';
      btn.addEventListener('click', () => {
        const cur = body.style.display !== 'none';
        const next = !cur;
        body.style.display = next ? '' : 'none';
        btn.setAttribute('aria-expanded', next ? 'true' : 'false');
        btn.textContent = next ? '▾' : '▸';
        const s = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
        s[subsec] = next;
        localStorage.setItem('tv_subsections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSubsectionToggles error', e);
  }
}

// 初期化: 設定を読み込み、UI を配線
document.addEventListener('DOMContentLoaded', async () => {
  try { 
    loadSettings(); 
    wireSettings(); 
    wireSectionToggles(); 
    wireSubsectionToggles();
    
    // サーバーから最新の更新遅延設定を取得して同期
    try {
      const res = await fetch('/api/settings');
      const data = await res.json();
      if (data.status === 'success' && data.settings) {
        const serverDelay = data.settings.update_delay_seconds || 10;
        document.getElementById('updateDelayInput').value = serverDelay.toString();
        localStorage.setItem('tv_update_delay', serverDelay.toString());
      }
    } catch (err) {
      console.log('サーバー設定取得エラー:', err);
    }
  } catch (err) { console.log('settings init error', err); }
});

// モーダル開閉とドラッグ機能
document.addEventListener('DOMContentLoaded', () => {
  const openBtn = document.getElementById('openSettings');
  const closeBtn = document.getElementById('closeSettings');
  const overlay = document.getElementById('settingsModal');
  const modal = document.querySelector('.modal');
  
  openBtn?.addEventListener('click', () => { overlay.style.display = 'flex'; });
  closeBtn?.addEventListener('click', () => { overlay.style.display = 'none'; });
  // クリックでオーバーレイを閉じる（モーダル内は除外）
  overlay?.addEventListener('click', (e) => { if (e.target === overlay) overlay.style.display = 'none'; });
  
  // モーダルのドラッグ機能
  let isDragging = false, offsetX = 0, offsetY = 0;
  
  modal?.addEventListener('mousedown', e => {
    // input/select/button はドラッグ開始しない
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') return;
    isDragging = true;
    const rect = modal.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    modal.style.position = 'fixed';
    modal.style.margin = '0';
  });
  
  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    e.preventDefault();
    modal.style.left = (e.clientX - offsetX) + 'px';
    modal.style.top = (e.clientY - offsetY) + 'px';
  });
  
  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
});

// 経過時間変換関数
function formatElapsedTime(datetimeStr, format) {
  if (!datetimeStr || datetimeStr === '-' || datetimeStr === '') return '-';
  
  // format === 'datetime' の場合はそのまま返す
  if (format === 'datetime') return datetimeStr;
  
  console.log('formatElapsedTime called:', datetimeStr, 'format:', format);
  
  // datetimeStr をパースして経過時間（分）を計算
  // 想定形式: "YY/MM/DD/HH:MM" (例: "25/10/31/21:35")
  try {
    const now = new Date();
    const segments = datetimeStr.trim().split('/');
    
    if (segments.length < 4) {
      console.log('Invalid format, expected YY/MM/DD/HH:MM, got:', segments);
      return datetimeStr;
    }
    
    // YY/MM/DD/HH:MM 形式をパース
    const year = 2000 + parseInt(segments[0], 10); // YY を YYYY に変換
    const month = parseInt(segments[1], 10) - 1; // 0-indexed
    const day = parseInt(segments[2], 10);
    
    // 時間部分を処理 (HH:MM)
    const timePart = segments[3]; // "HH:MM"
    const timeSegments = timePart.split(':');
    
    if (timeSegments.length < 2) {
      console.log('Invalid time format:', timePart);
      return datetimeStr;
    }
    
    const hour = parseInt(timeSegments[0], 10);
    const minute = parseInt(timeSegments[1], 10);
    
    const startTime = new Date(year, month, day, hour, minute);
    const elapsedMs = now - startTime;
    const elapsedMinutes = Math.floor(elapsedMs / 60000);
    
    // 5分刻みに丸める
    const roundedElapsedMinutes = Math.floor(elapsedMinutes / 5) * 5;
    
    console.log('Parsed:', { year, month, day, hour, minute, elapsedMinutes, roundedElapsedMinutes });
    
    if (elapsedMinutes < 0) {
      console.log('Negative elapsed time');
      return datetimeStr; // 未来の日時は元の文字列
    }
    
    if (format === 'm') {
      // 分のみ: "7320m"
      return roundedElapsedMinutes + 'm';
    } else if (format === 'hm') {
      // 時/分: "122:00" または "05:00"
      const hours = Math.floor(roundedElapsedMinutes / 60);
      const mins = roundedElapsedMinutes % 60;
      return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    } else if (format === 'dhm') {
      // 日/時/分: "05/02:00"
      const days = Math.floor(roundedElapsedMinutes / 1440);
      const remainMins = roundedElapsedMinutes % 1440;
      const hours = Math.floor(remainMins / 60);
      const mins = remainMins % 60;
      return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    }
    
    return datetimeStr;
  } catch (e) {
    console.error('formatElapsedTime error:', e, 'input:', datetimeStr);
    return datetimeStr;
  }
}

function calculateTransferTimeDiff(cloud) {
  const dautenTimeStr = cloud.dauten_start_time_str;
  const crossTimeStr = cloud.elapsed_str;
  if (!dautenTimeStr || !crossTimeStr || dautenTimeStr === '-' || crossTimeStr === '-') return { diff: null, sameDirection: false };
  
  const dautenDir = cloud.dauten; // 'up' or 'down'
  const crossDir = cloud.gc; // true or false
  
  // 同方向チェック: dauten 'up' matches gc true (GC), dauten 'down' matches gc false (DC)
  const dautenUp = dautenDir === 'up';
  const crossUp = crossDir === true;
  const sameDirection = dautenUp === crossUp;
  
  if (!sameDirection) return { diff: null, sameDirection: false };
  
  // 時間差計算
  function parseTime(str) {
    if (!str || str === '-') return null;
    const segments = str.split('/');
    if (segments.length < 4) return null;
    const year = 2000 + parseInt(segments[0]);
    const month = parseInt(segments[1]) - 1;
    const day = parseInt(segments[2]);
    const timePart = segments[3];
    let hour = 0, minute = 0;
    if (timePart.includes(':')) {
      const tp = timePart.split(':');
      hour = parseInt(tp[0]);
      minute = parseInt(tp[1]);
    } else {
      hour = parseInt(timePart);
    }
    return new Date(year, month, day, hour, minute);
  }
  
  const dautenTime = parseTime(dautenTimeStr);
  const crossTime = parseTime(crossTimeStr);
  if (!dautenTime || !crossTime) return { diff: null, sameDirection: false };
  
  const diffMs = Math.abs(dautenTime - crossTime);
  const diffMin = Math.floor(diffMs / 60000);
  return { diff: diffMin, sameDirection: true };
}

function formatTimeDiff(diffMin, format) {
  if (format === 'datetime') return '-';
  if (diffMin === null) return '-';
  if (format === 'm') return diffMin + 'm';
  if (format === 'hm') {
    const hours = Math.floor(diffMin / 60);
    const mins = diffMin % 60;
    return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  if (format === 'dhm') {
    const days = Math.floor(diffMin / 1440);
    const remainMins = diffMin % 1440;
    const hours = Math.floor(remainMins / 60);
    const mins = remainMins % 60;
    return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  return diffMin + 'm';
}

async function load() {
  const update_at = new Date().toISOString();
  console.log('[CLIENT UPDATE START]', update_at);
  console.log('Loading data...');
  try {
    const r = await fetch('/current_states');
    console.log('Response status:', r.status);
    
    if (!r.ok) {
      throw new Error('HTTP ' + r.status);
    }
    
    const data = await r.json();
    console.log('Data received:', data);
    
    if (data.status === 'success' && data.states.length > 0) {
      // 利用可能な通貨を抽出して通貨フィルターを更新
      const availableCurrencies = [...new Set(data.states.map(s => s.symbol))];
      updateCurrencyFilter(availableCurrencies);
      
      // USDJPY の全時間足データを取得
      const symbol = 'USDJPY';
      const state5m = data.states.find(x => x.symbol === symbol && x.tf === '5');
      const state15m = data.states.find(x => x.symbol === symbol && x.tf === '15');
      const state1h = data.states.find(x => x.symbol === symbol && x.tf === '60');
      const state4h = data.states.find(x => x.symbol === symbol && x.tf === '240');
      
      console.log('5m:', state5m);
      console.log('15m:', state15m);
      console.log('1H:', state1h);
      console.log('4H:', state4h);
      
      if (!state5m) {
        document.getElementById('dashboard').innerHTML = '<div class="loading">5mデータがありません</div>';
        return;
      }
      
      // 更新時刻を計算（JST）
      const updateTime = state5m.timestamp ? new Date(state5m.timestamp).toLocaleString('ja-JP', {timeZone: 'Asia/Tokyo', hour12: false}).split(' ')[1] : 'N/A';
      
      // 5m のクラウド配列をベースに統合
      const mergedClouds = (state5m.clouds || []).map(cloud => {
        const merged = {...cloud};
        
        console.log('Original cloud data:', cloud.label, {
          dauten_start_time_str: cloud.dauten_start_time_str,
          elapsed_str: cloud.elapsed_str
        });
        
        // 15m/1H/4H の行は、該当する tf のデータで上書き
        // 突破数はdaytradeのbosを使用（cloudsのbos_countは使用しない）
        if (cloud.label === '15m' && state15m) {
          merged.dauten = state15m.clouds?.[0]?.dauten || cloud.dauten;
          merged.bos_count = state15m.daytrade?.bos || cloud.bos_count;
          merged.dauten_start_time_str = state15m.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
          merged.elapsed_str = state15m.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
        } else if (cloud.label === '1H' && state1h) {
          merged.dauten = state1h.clouds?.[0]?.dauten || cloud.dauten;
          merged.bos_count = state1h.daytrade?.bos || cloud.bos_count;
          merged.dauten_start_time_str = state1h.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
          merged.elapsed_str = state1h.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
        } else if (cloud.label === '4H' && state4h) {
          merged.dauten = state4h.clouds?.[0]?.dauten || cloud.dauten;
          merged.bos_count = state4h.daytrade?.bos || cloud.bos_count;
          merged.dauten_start_time_str = state4h.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
          merged.elapsed_str = state4h.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
        } else if (cloud.label === '5m') {
          // 5m は state5m の daytrade.bos を使用
          merged.bos_count = state5m.daytrade?.bos || cloud.bos_count;
        } else if (cloud.label !== '5m') {
          // 5m 以外で個別データがない場合は空欄
          merged.dauten = '';
          merged.bos_count = null;
          merged.dauten_start_time_str = '';
          merged.elapsed_str = '';
        }
        
        console.log('Merged cloud data:', merged.label, {
          dauten_start_time_str: merged.dauten_start_time_str,
          elapsed_str: merged.elapsed_str
        });
        
        return merged;
      });
      
      // row_order に従って行を並べ替え
      const rowOrder = state5m.row_order || ['5m', '15m', 'price', '1H', '4H'];
      const orderedRows = [];
      
      rowOrder.forEach(label => {
        if (label === 'price') {
          // 価格行を追加
          orderedRows.push({ type: 'price', price: state5m.price });
        } else {
          // 対応する雲データを追加
          const cloud = mergedClouds.find(c => c.label === label);
          if (cloud) {
            orderedRows.push({ type: 'cloud', ...cloud });
          }
        }
      });
      
  let html = '<div class="table-wrap"><table><tr><th colspan="11" style="text-align: center;">' + state5m.symbol + ' - ' + state5m.price + '<span style="float: right;">更新 ' + updateTime + '</span></th></tr>';
  html += '<tr><th class="header-black">雲整列</th><th class="header-black">ダウ転</th><th class="header-black">突破数</th><th class="header-black">雲交差</th><th class="header-black">各雲間</th><th class="header-black">価格間</th><th class="header-black">雲角度</th><th class="header-black">雲厚み</th><th class="header-black">ダウ時間</th><th class="header-black">交差時間</th><th class="header-black">時間差</th></tr>';

      orderedRows.forEach(row => {
        if (row.type === 'price') {
          // 価格行（背景白、文字黒）
          html += '<tr class="price-row"><td class="tf-label">価格</td>';
          html += '<td colspan="10"></td></tr>';
        } else {
          // 雲の行
          const c = row;
          html += '<tr>';
          
          // 雲整列セルの背景色を時間足ごとに設定（70%透過相当）
          let tfBgColor = '';
          if (c.label === '5m') tfBgColor = '#a9e88c';
          else if (c.label === '15m') tfBgColor = '#fbd0b2';
          else if (c.label === '1H') tfBgColor = '#8dc7fc';
          else if (c.label === '4H') tfBgColor = '#fa8dfe';
          
          // 雲整列（背景色付き、文字は黒）
          if (tfBgColor) {
            html += '<td class="tf-label" style="background:' + tfBgColor + '; color:#000">' + c.label + '</td>';
          } else {
            html += '<td class="tf-label col-cloud-label">' + c.label + '</td>';
          }

          // 色算出: ダウ転、雲交差、各雲間、価格間、雲角度、雲厚み
          // 緑色を #2962ff に変更
          let dautenColor = '';
          if (c.dauten === 'up') dautenColor = '#2962ff';
          else if (c.dauten === 'down') dautenColor = '#f23645';

          // 雲交差(gc)
          let gcColor = '';
          if (c.gc === true) gcColor = '#2962ff';
          else if (c.gc === false) gcColor = '#f23645';

          // 突破数値を取得
          let bosVal = c.bos_count;

          // 数値系
          const toNum = v => (v === null || v === undefined || v === '' ? null : Number(v));
          const prev = toNum(c.distance_from_prev);
          const prevColor = (prev !== null ? (prev > 0 ? '#2962ff' : (prev < 0 ? '#f23645' : '')) : '');
          const dp = toNum(c.distance_from_price);
          const dpColor = (dp !== null ? (dp > 0 ? '#2962ff' : (dp < 0 ? '#f23645' : '')) : '');
          const ang = toNum(c.angle);
          const angColor = (ang !== null ? (ang > 0 ? '#2962ff' : (ang < 0 ? '#f23645' : '')) : '');
          const th = toNum(c.thickness);
          const thColor = (th !== null ? (th > 0 ? '#2962ff' : (th < 0 ? '#f23645' : '')) : '');

          // ダウ転セル
          if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';
          else html += '<td>' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';

          // 突破数セル: 常にダウ転と同じ背景色にする（値が '-' の場合でも色を付ける）
          const displayBos = (bosVal === null || bosVal === undefined || bosVal === '' ? '-' : bosVal);
          if (dautenColor) {
            html += '<td style="background:' + dautenColor + '; color:#fff">' + displayBos + '</td>';
          } else {
            html += '<td>' + displayBos + '</td>';
          }

          // 雲交差セル
          if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (c.gc ? '▲GC' : '▼DC') + '</td>';
          else html += '<td>' + (c.gc ? '▲GC' : '▼DC') + '</td>';

          // 各雲間
          if (prevColor) html += '<td style="background:' + prevColor + '; color:#fff">' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';
          else html += '<td>' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';

          // 価格間
          if (dpColor) html += '<td style="background:' + dpColor + '; color:#fff">' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';
          else html += '<td>' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';

          // 雲角度
          if (angColor) html += '<td style="background:' + angColor + '; color:#fff">' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';
          else html += '<td>' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';

          // 雲厚み
          if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (th !== null ? th.toFixed(1) : '-') + '</td>';
          else html += '<td>' + (th !== null ? th.toFixed(1) : '-') + '</td>';

          // 経過時間形式を取得
          const timeFormat = localStorage.getItem('tv_time_format') || 'datetime';
          
          // ダウ時間: 形式変換を適用し、同じ行のダウ転セルと同じ背景色
          const dautenTimeFormatted = formatElapsedTime(c.dauten_start_time_str || '-', timeFormat);
          if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + dautenTimeFormatted + '</td>';
          else html += '<td>' + dautenTimeFormatted + '</td>';

      // 交差時間: 形式変換を適用し、雲交差セルと同じ背景色
          const elapsedTimeFormatted = formatElapsedTime(c.elapsed_str || '-', timeFormat);
          if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + elapsedTimeFormatted + '</td>';
          else html += '<td>' + elapsedTimeFormatted + '</td>';

          // 時間差: 計算とフォーマット
          const timeDiffResult = calculateTransferTimeDiff(c);
          const timeDiffFormatted = formatTimeDiff(timeDiffResult.diff, timeFormat);
          let timeDiffBg = '';
          let timeDiffColor = '#fff'; // 白抜き文字
          if (timeFormat === 'datetime') {
            // datetimeの場合: 同方向ならダウ時間の背景色、逆方向ならグレー
            if (timeDiffResult.sameDirection) {
              timeDiffBg = dautenColor || '';
            } else {
              timeDiffBg = 'rgba(128,128,128,0.5)'; // グレー
            }
          } else {
            // それ以外: 同方向ならダウ時間の背景色、逆方向ならグレー
            if (timeDiffResult.sameDirection) {
              timeDiffBg = dautenColor || '';
            } else {
              timeDiffBg = 'rgba(128,128,128,0.5)'; // グレー
            }
          }
          if (timeDiffBg) {
            html += '<td style="background:' + timeDiffBg + '; color:' + timeDiffColor + '">' + timeDiffFormatted + '</td></tr>';
          } else {
            html += '<td style="color:' + timeDiffColor + '">' + timeDiffFormatted + '</td></tr>';
          }
        }
      });

  html += '</table></div>';
      document.getElementById('dashboard').innerHTML = html;
      
      // テーブル再描画後に設定を再適用
      try {
        const sz = localStorage.getItem('tv_font_size') || document.getElementById('fontSizeSelect')?.value || '14';
        applyFontSize(sz);
        applyColumnVisibility();
        applyRowVisibility();
      } catch (e) { /* ignore */ }
      
      // Sync fire history height with table
      setTimeout(syncFireHistoryHeight, 100);
    } else {
      document.getElementById('dashboard').innerHTML = '<div class="loading">データなし</div>';
    }
  } catch (e) {
    document.getElementById('dashboard').innerHTML = '<div class="loading">エラー: ' + e.message + '</div>';
  }
}
load();
setInterval(load, 300000);

// --- Rules UI / API ---
async function loadRules() {
  try {
    const r = await fetch('/rules');
    if (!r.ok) return;
    const data = await r.json();
    if (data.status !== 'success') return;
    renderRulesList(data.rules || []);
    // populate scope select with available symbols (currencies)
    const scopeSelect = document.getElementById('ruleScope');
    const avail = [...new Set((data.rules || []).map(x => x.scope && x.scope.symbol).filter(Boolean))];
    // keep existing options but add any new
    avail.forEach(s => {
      if (![...scopeSelect.options].some(o => o.value === s)) {
        const opt = document.createElement('option'); opt.value = s; opt.textContent = s; scopeSelect.appendChild(opt);
      }
    });
  } catch (e) { console.log('loadRules error', e); }
}

function renderRulesList(rules) {
  // Sort rules: enabled first (by updated_at desc), then disabled (by updated_at desc)
  const sortedRules = rules.sort((a, b) => {
    const aEnabled = a.enabled !== false;
    const bEnabled = b.enabled !== false;
    if (aEnabled !== bEnabled) {
      return bEnabled - aEnabled; // enabled (true=1) comes before disabled (false=0)
    }
    // Same enabled status: sort by updated_at descending (most recent first)
    const aTime = a.updated_at || a.created_at || '';
    const bTime = b.updated_at || b.created_at || '';
    return bTime.localeCompare(aTime);
  });
  
  const ul = document.getElementById('rulesList'); ul.innerHTML = '';
  sortedRules.forEach(rule => {
    const li = document.createElement('li'); li.style.padding = '6px 4px'; li.style.borderBottom = '1px solid rgba(255,255,255,0.04)';
    li.style.display = 'flex'; li.style.alignItems = 'center'; li.style.justifyContent = 'space-between';
    
    const left = document.createElement('div'); left.style.display = 'flex'; left.style.alignItems = 'center'; left.style.gap = '8px';
    const btns = document.createElement('div'); btns.style.display = 'flex'; btns.style.gap = '6px';
    
    // 有効/無効トグルボタン
    const toggle = document.createElement('button');
    const isEnabled = rule.enabled !== false; // デフォルトは有効
    toggle.textContent = isEnabled ? '有効' : '無効';
    toggle.style.padding = '4px 8px';
    toggle.style.fontWeight = '600';
    toggle.style.background = isEnabled ? 'rgba(46, 160, 67, 0.2)' : 'rgba(176, 42, 42, 0.2)';
    toggle.style.color = isEnabled ? '#4ade80' : '#f87171';
    toggle.style.border = isEnabled ? '1px solid #4ade80' : '1px solid #f87171';
    toggle.style.borderRadius = '4px';
    toggle.style.cursor = 'pointer';
    toggle.addEventListener('click', async () => {
      try {
        const newEnabled = !isEnabled;
        const updatedRule = { ...rule, enabled: newEnabled };
        const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(updatedRule) });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('更新に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('toggle error', e); alert('トグルエラー: ' + e.message); }
    });
    
    const edit = document.createElement('button'); edit.textContent = '編集'; edit.style.padding = '4px 8px';
    const del = document.createElement('button'); del.textContent = '削除'; del.style.padding = '4px 8px';
    edit.addEventListener('click', () => openRuleEditor(rule));
    del.addEventListener('click', async () => {
      if (!confirm('ルールを削除しますか?')) return;
      try {
        const res = await fetch('/rules/' + encodeURIComponent(rule.id), { method: 'DELETE' });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('削除に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('delete error', e); alert('削除エラー: ' + e.message); }
    });
    
    btns.appendChild(toggle); btns.appendChild(edit); btns.appendChild(del);
    // According to request, place buttons first then rule name to the right
    const title = document.createElement('div'); 
    title.textContent = rule.name || rule.id; 
    title.style.fontWeight = '600'; 
    title.style.marginLeft = '12px';
    title.style.opacity = isEnabled ? '1' : '0.5'; // 無効な場合は薄く表示
    btns.style.opacity = isEnabled ? '1' : '0.5'; // ボタンも薄く表示
    left.appendChild(btns); left.appendChild(title);
    li.appendChild(left);
    ul.appendChild(li);
  });
}

function openRuleEditor(rule) {
  // populate editor fields
  console.log('[DEBUG] Editing rule:', JSON.stringify(rule, null, 2));
  document.getElementById('ruleName').value = rule.name || '';
  const scopeSel = document.getElementById('ruleScope');
  if (rule.scope && rule.scope.symbol) { scopeSel.value = rule.scope.symbol; }
  else { scopeSel.value = ''; }
  // clear conditions
  const condCont = document.getElementById('conditionsContainer'); condCont.innerHTML = '';
  const conds = (rule.rule && rule.rule.conditions) || [];
  if (conds.length === 0) addConditionRow();
  conds.forEach(c => {
    const row = createConditionRow(c);
    condCont.appendChild(row);
  });
    // populate alignment UI if present
  try {
    const align = rule.rule && rule.rule.alignment;
    if (align) {
      // clear all
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      (align.tfs || []).forEach(tf => {
        const el = document.querySelector('.align-tf[data-tf="' + tf + '"]');
        if(el) el.checked = true;
      });
      if (align.missing) document.getElementById('alignMissing').value = align.missing;
      if (align.n !== undefined && align.n !== null) document.getElementById('alignN').value = String(align.n);
      else document.getElementById('alignN').value = 'off';
    } else {
      // reset to defaults
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      document.getElementById('alignMissing').value = 'ignore';
      document.getElementById('alignN').value = 'off';
    }
  } catch(e) { /* ignore */ }
  
  // populate voice settings
  const voice = rule.rule && rule.rule.voice;
  const isDirectionBased = voice && (voice.message_up !== undefined || voice.message_down !== undefined);
  document.getElementById('voiceDirectionBased').checked = isDirectionBased;
  document.getElementById('directionMessages').style.display = isDirectionBased ? 'flex' : 'none';
  document.getElementById('voiceMessagePosition').value = (voice && voice.message_position) || 'suffix';
  
  // Always populate common message if present
  document.getElementById('voiceMessage').value = (voice && voice.message) || '';
  
  // Populate direction-based messages if present
  if (isDirectionBased) {
    document.getElementById('voiceMessageUp').value = (voice && voice.message_up) || '';
    document.getElementById('voiceMessageDown').value = (voice && voice.message_down) || '';
  } else {
    document.getElementById('voiceMessageUp').value = '';
    document.getElementById('voiceMessageDown').value = '';
  }
  
  document.getElementById('voiceSelect').value = (voice && voice.voice_name) || '';
  
  // store editing id on save button
  document.getElementById('saveRuleBtn').dataset.editing = rule.id;
}

// --- 雲整列: helper ---
function getAlignmentSettingsFromUI(){
  const tfs = Array.from(document.querySelectorAll('.align-tf')).filter(cb=>cb.checked).map(cb=>cb.dataset.tf);
  const missing = document.getElementById('alignMissing').value; // 'ignore' or 'fail'
  const nVal = document.getElementById('alignN').value;
  const n = (nVal === 'off') ? null : Number(nVal);
  return { tfs, missing, n };
}

function validateAlignmentForSave(){
  const s = getAlignmentSettingsFromUI();
  const errEl = document.getElementById('alignError'); errEl.style.display = 'none'; errEl.textContent = '';
  if(!s.n){
    // N is off -> treat alignment as disabled regardless of selection
    return {ok:true, msg:'alignment disabled'};
  }
  if(s.tfs.length === 0){
    errEl.style.display='block'; errEl.textContent='エラー: 判定対象の時間は 2 個以上選択してください';
    return {ok:false, msg:'need_2_tfs'};
  }
  if(s.tfs.length === 1){
    errEl.style.display='block'; errEl.textContent='エラー: 判定対象の時間は 2 個以上選択してください';
    return {ok:false, msg:'need_2_tfs'};
  }
  if(isNaN(s.n) || s.n < 2){
    errEl.style.display='block'; errEl.textContent='エラー: 閾値 N は 2 以上を選択してください';
    return {ok:false, msg:'invalid_n'};
  }
  if(s.n > s.tfs.length){
    errEl.style.display='block'; errEl.textContent='エラー: 閾値 N が選択個数より大きいため選べません';
    return {ok:false, msg:'n_gt_selected'};
  }
  return {ok:true, msg:'ok'};
}

// wire align checkbox changes to keep UI consistent
document.addEventListener('DOMContentLoaded', ()=>{
  document.querySelectorAll('.align-tf').forEach(cb=> cb.addEventListener('change', ()=>{ /* no-op for now; validation on save/test */ }));
  document.getElementById('alignAllTf').addEventListener('change', (e) => {
    const checked = e.target.checked;
    document.querySelectorAll('.align-tf').forEach(cb => cb.checked = checked);
  });
});

function createConditionRow(c) {
  const div = document.createElement('div'); div.className = 'cond-row'; div.style.display='flex'; div.style.gap='6px'; div.style.alignItems='center';
  const tf = document.createElement('select'); tf.className='cond-tf'; tf.innerHTML = '<option value="5m">5m</option><option value="15m">15m</option><option value="1H">1H</option><option value="4H">4H</option>';
  const field = document.createElement('select'); field.className='cond-field'; field.innerHTML = '<option value="dauten">ダウ転</option><option value="bos_count">突破数</option><option value="gc">雲交差</option><option value="distance_from_prev">各雲間</option><option value="distance_from_price">価格間</option><option value="angle">雲角度</option><option value="thickness">雲厚み</option><option value="transfer_time_diff">転換時間差</option>';
  const op = document.createElement('select'); op.className='cond-op'; op.innerHTML = '<option value==>==</option><option value=">=">&gt;=</option><option value=">">&gt;</option><option value="<=">&lt;=</option><option value="<">&lt;</option>';
  const val = document.createElement('input'); val.className='cond-value'; val.placeholder='値'; val.style.padding='6px'; val.style.borderRadius='6px'; val.style.border='1px solid rgba(255,255,255,0.08)'; val.style.background='transparent'; val.style.color='inherit'; val.style.width='120px';
  const rem = document.createElement('button'); rem.className='removeCond'; rem.textContent='削除'; rem.style.padding='4px 8px';
  rem.addEventListener('click', () => div.remove());
  div.append(tf, field, op, val, rem);

  // hide/remove op/val when field is one of the toggle-only/time/numeric-threshold types
  function updateCondVisibility() {
    try {
      const hideBoth = ['dauten','bos_count','gc','dauten_start_time_str','cross_start_time'];
      const hideOpOnly = ['distance_from_prev','distance_from_price','angle','thickness','transfer_time_diff'];
      
      if (hideBoth.includes(field.value)) {
        // remove both op and val from DOM
        if (op.parentNode === div) div.removeChild(op);
        if (val.parentNode === div) div.removeChild(val);
      } else if (hideOpOnly.includes(field.value)) {
        // remove only op, keep val for numeric input
        if (op.parentNode === div) div.removeChild(op);
        if (val.parentNode !== div) div.insertBefore(val, rem);
        val.style.display = '';
        val.placeholder = '閾値';
      } else {
        // ensure both op and val are present before the remove button
        if (op.parentNode !== div) div.insertBefore(op, rem);
        if (val.parentNode !== div) div.insertBefore(val, rem);
        op.style.display = '';
        val.style.display = '';
        val.placeholder = '値';
      }
    } catch (e) { /* ignore */ }
  }

  field.addEventListener('change', updateCondVisibility);
  // Set values from loaded rule BEFORE calling initial visibility update
  if (c) {
    tf.value = c.label || tf.value;
    field.value = c.field || field.value;
    op.value = c.op || op.value;
    val.value = c.value || '';
  }
  // initial visibility (AFTER setting field value so it checks the correct field type)
  updateCondVisibility();
  return div;
}

function addConditionRow() {
  const cont = document.getElementById('conditionsContainer');
  const r = createConditionRow(); cont.appendChild(r);
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('newRuleBtn')?.addEventListener('click', () => {
    document.getElementById('ruleName').value = '';
    document.getElementById('conditionsContainer').innerHTML = '';
    addConditionRow();
    document.getElementById('saveRuleBtn').dataset.editing = '';
    
    // clear voice settings
    document.getElementById('voiceMessage').value = '';
    document.getElementById('voiceMessageUp').value = '';
    document.getElementById('voiceMessageDown').value = '';
    document.getElementById('voiceDirectionBased').checked = false;
    document.getElementById('directionMessages').style.display = 'none';
    document.getElementById('voiceMessagePosition').value = 'suffix';
    document.getElementById('voiceSelect').value = '';
  });
  
  // Wire voice direction based checkbox
  document.getElementById('voiceDirectionBased')?.addEventListener('change', e => {
    const directionDiv = document.getElementById('directionMessages');
    directionDiv.style.display = e.target.checked ? 'flex' : 'none';
  });
  
  // Wire test voice button
  document.getElementById('testVoiceBtn')?.addEventListener('click', () => {
    const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
    const voiceName = document.getElementById('voiceSelect').value;
    const messagePosition = document.getElementById('voiceMessagePosition').value;
    
    let testMessage = '';
    if (isDirectionBased) {
      const messageUp = document.getElementById('voiceMessageUp').value.trim();
      const messageDown = document.getElementById('voiceMessageDown').value.trim();
      const directionMessage = messageUp || 'テストメッセージ（上昇）';
      const baseMessage = document.getElementById('voiceMessage').value.trim() || 'ルールが発火しました';
      
      if (messagePosition === 'prefix') {
        testMessage = directionMessage + ' ' + baseMessage;
      } else if (messagePosition === 'suffix') {
        testMessage = baseMessage + ' ' + directionMessage;
      } else if (messagePosition === 'both') {
        testMessage = directionMessage + ' ' + baseMessage + ' ' + directionMessage;
      }
    } else {
      testMessage = document.getElementById('voiceMessage').value.trim() || 'テストメッセージ';
    }
    
    const voiceSettings = voiceName ? { voice_name: voiceName } : null;
    const rateSuffix = testMessage ? '' : '。音速は' + document.getElementById('voiceRate').value + '倍です。';
    playVoiceAlert(testMessage + rateSuffix, voiceSettings);
  });
  
  // Populate voice select with available voices
  function populateVoiceSelect() {
    if (!('speechSynthesis' in window)) return;
    
    const select = document.getElementById('voiceSelect');
    const currentValue = select.value;
    
    select.innerHTML = '';
    
    const voices = speechSynthesis.getVoices();
    const allowedVoices = {
      'Microsoft 七海 Online (Natural) - Japanese (Japan)': '七海［女性］',
      'Microsoft 圭太 Online (Natural) - Japanese (Japan)': '圭太［男性］',
      'Microsoft 碧衣 Online (Natural) - Japanese (Japan)': '碧衣［女性］',
      'Microsoft 大智 Online (Natural) - Japanese (Japan)': '大智［男性］',
      'Microsoft 真夕 Online (Natural) - Japanese (Japan)': '真夕［女性］',
      'Microsoft 直紀 Online (Natural) - Japanese (Japan)': '直紀［男性］',
      'Microsoft 志織 Online (Natural) - Japanese (Japan)': '志織［女性］'
    };
    
    voices.forEach(voice => {
      if (voice.lang.startsWith('ja') && allowedVoices[voice.name]) {
        const option = document.createElement('option');
        option.value = voice.name;
        option.textContent = allowedVoices[voice.name];
        select.appendChild(option);
      }
    });
    
    // Restore previous selection if it still exists
    if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
      select.value = currentValue;
    }
  }
  
  // Populate voices when available
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = populateVoiceSelect;
  }
  populateVoiceSelect();
  
  document.getElementById('saveRuleBtn')?.addEventListener('click', async () => {
    // validate alignment first
    const alignValid = validateAlignmentForSave();
    if(!alignValid.ok){ return; }

    const name = document.getElementById('ruleName').value || ('rule-' + Date.now());
    const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
    const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
    const conditions = condRows.map(r => {
      const tf = r.querySelector('.cond-tf').value;
      const fld = r.querySelector('.cond-field').value;
      const opEl = r.querySelector('.cond-op');
      const valEl = r.querySelector('.cond-value');
      const opVal = opEl ? opEl.value : null;
      const valVal = valEl ? valEl.value : null;
      return { label: tf, field: fld, op: opVal, value: valVal };
    });
  const alignment = getAlignmentSettingsFromUI();
  const ruleObj = { conditions: conditions };
  // include alignment only if enabled (N not 'off') and TFs selected
  if(alignment.n && alignment.tfs && alignment.tfs.length > 0){ ruleObj.alignment = alignment; }
  
  // include voice settings
  const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
  const voiceName = document.getElementById('voiceSelect').value;
  const messagePosition = document.getElementById('voiceMessagePosition').value;
  const commonMessage = document.getElementById('voiceMessage').value.trim();
  const messageUp = document.getElementById('voiceMessageUp').value.trim();
  const messageDown = document.getElementById('voiceMessageDown').value.trim();
  
  console.log('[DEBUG] Voice settings - isDirectionBased:', isDirectionBased, 'voiceName:', voiceName, 'messagePosition:', messagePosition);
  console.log('[DEBUG] Messages - common:', commonMessage, 'up:', messageUp, 'down:', messageDown);
  
  // Check if any voice setting exists
  if (commonMessage || messageUp || messageDown || voiceName) {
    ruleObj.voice = {};
    
    // Always save common message if present
    if (commonMessage) {
      ruleObj.voice.message = commonMessage;
    }
    
    // Save direction-based messages if direction-based mode is enabled
    if (isDirectionBased) {
      ruleObj.voice.message_up = messageUp;
      ruleObj.voice.message_down = messageDown;
      ruleObj.voice.message_position = messagePosition;
    }
    
    // Always save voice name if selected
    if (voiceName) {
      ruleObj.voice.voice_name = voiceName;
    }
  }
  
  console.log('[DEBUG] ruleObj after voice settings:', JSON.stringify(ruleObj, null, 2));
  
    const payload = { id: document.getElementById('saveRuleBtn').dataset.editing || name, name: name, enabled: true, scope: scope, rule: ruleObj };
    console.log('[DEBUG] Saving payload:', JSON.stringify(payload, null, 2));
    try {
      const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
      const j = await res.json();
      if (j.status === 'success') { 
        alert('ルールを保存しました'); 
        // ルール一覧を再度読み込んで、最新のデータを取得
        await loadRules();
        // 保存したルールを再度開いて、UIを最新の状態に更新
        try {
          const rulesRes = await fetch('/rules');
          const rulesData = await rulesRes.json();
          if (rulesData.status === 'success') {
            const savedRule = rulesData.rules.find(r => r.id === payload.id);
            if (savedRule) {
              console.log('[DEBUG] Reloading saved rule for display:', JSON.stringify(savedRule, null, 2));
              openRuleEditor(savedRule);
            }
          }
        } catch (e) {
          console.log('Error reloading rule after save:', e);
        }
      }
      else { alert('保存失敗: ' + (j.msg || JSON.stringify(j))); }
    } catch (e) { console.log('save error', e); alert('保存時エラー: ' + e.message); }
  });

  document.getElementById('testRuleBtn')?.addEventListener('click', async () => {
    const panel = document.getElementById('ruleTestResult');
    const badge = document.getElementById('testBadge');
    const short = document.getElementById('testShort');
    const detailsEl = document.getElementById('testDetails');

    badge.style.background = '#777'; badge.textContent = '実行中...';
    short.textContent = '';
    detailsEl.innerHTML = '';

    // build payload
    const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
    const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
    const conditions = condRows.map(r => {
      const tf = r.querySelector('.cond-tf').value;
      const fld = r.querySelector('.cond-field').value;
      const opEl = r.querySelector('.cond-op');
      const valEl = r.querySelector('.cond-value');
      const opVal = opEl ? opEl.value : null;
      const valVal = valEl ? (valEl.value || null) : null;
      return { label: tf, field: fld, op: opVal, value: valVal };
    });
    const payload = { rule: { logic: 'AND', conditions: conditions }, scope: scope };
    const alignment = getAlignmentSettingsFromUI();
    if(alignment.n && alignment.tfs && alignment.tfs.length > 0){ payload.rule.alignment = alignment; }

    // alignment validation - we show a non-blocking warning
    const alignValid = validateAlignmentForSave();
    if(!alignValid.ok){ short.textContent = '注意: ' + alignValid.msg; }

    try {
      const res = await fetch('/rules/test', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
      const j = await res.json();
      if (j.status === 'success') {
        const matched = !!j.matched;
  // badge — show compact OK/NG
  if (matched) { badge.style.background = '#2d8a3d'; badge.textContent = 'OK'; }
  else { badge.style.background = '#b02a2a'; badge.textContent = 'NG'; }

        // short summary
        const condCount = Array.isArray(payload.rule.conditions) ? payload.rule.conditions.length : 0;
        const passCount = Array.isArray(j.details) ? j.details.filter(d => d.result).length : (matched ? condCount : 0);
  short.textContent = `判定: ${matched ? 'OK' : 'NG'} — 条件合致 ${passCount}/${condCount}${payload.rule.alignment ? ' / 雲整列を含む' : ''}`;

        // human-readable details
        if (Array.isArray(j.details) && j.details.length > 0) {
          const ul = document.createElement('ul');
          ul.style.margin = '6px 0 0 14px'; ul.style.padding = '0'; ul.style.listStyle = 'disc';
          j.details.forEach(d => {
            const li = document.createElement('li');
            try {
              const rawName = d.cond || (d.label ? `${d.label}.${d.field}` : JSON.stringify(d));
              // field -> Japanese name map
              const fieldMap = {
                'alignment':'雲整列', '雲整列':'雲整列',
                'dauten':'ダウ転換', 'gc':'雲交差', 'bos_count':'突破数', 'daytrade_bos':'突破数',
                'distance_from_prev':'各雲間', 'distance_from_price':'価格間',
                'angle':'雲角度', 'thickness':'雲厚み', 'transfer_time_diff':'転換時間差',
                'presence_check':'存在確認', 'direction_consistency':'方向一貫性'
              };

              // derive display name - extract field part after dot if present
              let name = rawName;
              const key = d.field || d.cond || rawName;
              
              // if cond contains a dot (e.g., "5m.dauten"), extract the field part
              if (typeof rawName === 'string' && rawName.includes('.')) {
                const parts = rawName.split('.');
                const tfPart = parts[0];  // e.g., "5m"
                const fieldPart = parts[1]; // e.g., "dauten"
                const mappedField = fieldMap[fieldPart] || fieldPart;
                name = `${tfPart}.${mappedField}`;
              } else if (fieldMap[key]) {
                name = fieldMap[key];
              }

              // OK/NG
              const ok = d.result ? 'OK' : 'NG';

              // helper to format actual values (handle undefined/null)
              const formatActual = (val, fld) => {
                if (val === undefined || val === null || val === '-') return '未測定';
                // normalize some known display values
                if (fld && fld.includes('dauten')) {
                  if (val === 'up' || val === '上' || val === 'upward' || val === '▲' || val === '上昇') return '上昇';
                  if (val === 'down' || val === '下' || val === 'downward' || val === '▼' || val === '下降') return '下降';
                  return String(val);
                }
                if (fld && fld.includes('gc')) {
                  if (String(val).toUpperCase() === 'GC') return 'GC';
                  if (String(val).toUpperCase() === 'DC') return 'DC';
                  return String(val);
                }
                return (typeof val === 'number') ? (Number(val).toFixed(2).replace(/\.00$/,'')) : String(val);
              };

              // build message by condition type / available fields
              let msg = '';

              // known reason translations
              const reasonMap = {
                'presence_check':'存在確認', 'missing_field':'データ欠損', 'invalid_threshold':'無効な閾値',
                'directions_mismatch':'方向不一致', 'missing_fail':'欠損で不成立', 'effective_lt_n':'有効数が閾値未満',
                'no_threshold_provided':'閾値未設定', 'invalid_direction':'無効な方向指定',
                'no_selection':'TF未選択', 'need_at_least_2':'最低2つのTFが必要'
              };
              if (d.reason) {
                const reasonText = reasonMap[d.reason] || d.reason;
                // if directions array is present (for direction_consistency), show them
                if (d.directions && Array.isArray(d.directions)) {
                  msg = `（${reasonText}：${d.directions.join('、')}）`;
                } else if (d.dauten_dir !== undefined || d.cross_dir !== undefined) {
                  // show debug info for invalid_direction errors
                  msg = `（${reasonText}：ダウ方向=${d.dauten_dir || '?'}、交差方向=${d.cross_dir || '?'}）`;
                } else {
                  msg = `（${reasonText}）`;
                }
              } else if (d.match_up !== undefined || d.match_down !== undefined) {
                const up = d.match_up !== undefined ? d.match_up : '-';
                const down = d.match_down !== undefined ? d.match_down : '-';
                msg = `（上昇：${up} ／ 下降：${down}`;
                if (d.threshold !== undefined) msg += `、閾値：${d.threshold}`;
                msg += '）';
              } else if (d.threshold !== undefined || d.value !== undefined) {
                const thr = d.threshold !== undefined ? d.threshold : d.value;
                const fieldKey = d.field || (d.cond ? d.cond.split('.')[1] : '');
                const actual = formatActual(d.actual, fieldKey || d.cond);
                // special-wording for some fields
                if ((fieldKey === 'dauten') || (d.cond && d.cond.indexOf('dauten') !== -1)) {
                  msg = `（期待方向：${thr}、実測：${actual}）`;
                } else if ((fieldKey === 'gc') || (d.cond && d.cond.indexOf('gc') !== -1)) {
                  msg = `（期待：${thr}、実測：${actual}）`;
                } else if ((fieldKey === 'bos_count') || (fieldKey === 'daytrade_bos') || (d.cond && d.cond.indexOf('bos_count') !== -1)) {
                  msg = `（閾値：${thr} 回、実測：${actual}）`;
                } else if ((fieldKey === 'transfer_time_diff') || (d.cond && d.cond.indexOf('transfer_time_diff') !== -1)) {
                  msg = `（閾値：${thr} 分、実測：${actual} 分）`;
                } else if ((fieldKey === 'angle') || (d.cond && d.cond.indexOf('angle') !== -1)) {
                  msg = `（閾値：${thr}°、実測：${actual}°）`;
                } else if ((fieldKey === 'distance_from_prev') || (d.cond && d.cond.indexOf('distance_from_prev') !== -1)) {
                  msg = `（閾値：${thr} pips、実測：${actual} pips）`;
                } else if ((fieldKey === 'distance_from_price') || (d.cond && d.cond.indexOf('distance_from_price') !== -1)) {
                  msg = `（閾値：${thr} pips、実測：${actual} pips）`;
                } else if ((fieldKey === 'thickness') || (d.cond && d.cond.indexOf('thickness') !== -1)) {
                  msg = `（閾値：${thr} pips、実測：${actual} pips）`;
                } else {
                  msg = `（閾値：${thr}、実測：${actual}）`;
                }
              } else if (d.delta_min !== undefined) {
                const actualVal = (d.delta_min === undefined || d.delta_min === null) ? '未測定' : Number(d.delta_min).toFixed(1);
                const thr = d.threshold !== undefined ? d.threshold : (d.value !== undefined ? d.value : '-');
                msg = `（閾値：${thr} 分、実測：${actualVal} 分）`;
              } else if (d.actual !== undefined) {
                const actual = formatActual(d.actual, d.field || d.cond);
                msg = `（実測：${actual}）`;
              } else if (d.found_in) {
                const fi = d.found_in;
                msg = `（取得元：TF=${fi.state_tf || fi.tf || '-'}、雲=${fi.cloud_label || fi.cloud || '-'}）`;
              }

              li.textContent = `${name}：${ok} ${msg}`.trim();
            } catch (e) { li.textContent = JSON.stringify(d); }
            ul.appendChild(li);
          });
          detailsEl.appendChild(ul);
        } else {
          detailsEl.textContent = '詳細情報はありません。';
        }

        // collapsible raw JSON with copy button (visible copy button placed next to the toggle)
        const raw = document.createElement('details');
        raw.style.marginTop = '8px';
        const sum = document.createElement('summary'); sum.textContent = '生データを表示'; raw.appendChild(sum);

        const pre = document.createElement('pre');
        pre.style.maxHeight = '240px'; pre.style.overflow = 'auto'; pre.style.background = 'transparent'; pre.style.color = 'inherit'; pre.style.whiteSpace = 'pre-wrap'; pre.style.userSelect = 'text';
        pre.textContent = JSON.stringify(j, null, 2);
        raw.appendChild(pre);

        // copy area inside details (for expanded view)
        const copyWrap = document.createElement('div');
        copyWrap.style.display = 'flex'; copyWrap.style.gap = '8px'; copyWrap.style.alignItems = 'center'; copyWrap.style.marginTop = '6px';
        const copyBtnInside = document.createElement('button');
        copyBtnInside.textContent = '生データをコピー';
        copyBtnInside.style.padding = '4px 8px'; copyBtnInside.style.fontSize = '0.9em'; copyBtnInside.style.cursor = 'pointer';
        const copyNote = document.createElement('span');
        copyNote.style.opacity = '0.85'; copyNote.style.fontSize = '0.9em'; copyNote.textContent = '';
        copyWrap.appendChild(copyBtnInside);
        copyWrap.appendChild(copyNote);
        raw.appendChild(copyWrap);

        // wrapper to hold details and a visible copy button next to the summary
        const rawWrap = document.createElement('div');
        rawWrap.style.display = 'flex'; rawWrap.style.alignItems = 'center'; rawWrap.style.gap = '8px';
        // visible copy button placed to the right of the summary (works even when details is collapsed)
        const copyBtnVisible = document.createElement('button');
        copyBtnVisible.textContent = '生データをコピー';
        copyBtnVisible.style.padding = '4px 8px'; copyBtnVisible.style.fontSize = '0.9em'; copyBtnVisible.style.cursor = 'pointer';
        rawWrap.appendChild(raw);
        rawWrap.appendChild(copyBtnVisible);
        detailsEl.appendChild(rawWrap);

        // copy handler (shared)
        const doCopy = async () => {
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(pre.textContent);
            } else {
              const range = document.createRange();
              range.selectNodeContents(pre);
              const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);
              document.execCommand('copy');
              sel.removeAllRanges();
            }
            copyNote.textContent = 'コピーしました';
            setTimeout(() => { copyNote.textContent = ''; }, 2000);
          } catch (e) {
            copyNote.textContent = 'コピー失敗';
            setTimeout(() => { copyNote.textContent = ''; }, 2000);
          }
        };
        copyBtnInside.addEventListener('click', doCopy);
        copyBtnVisible.addEventListener('click', doCopy);
      } else {
        badge.style.background = '#aa5500'; badge.textContent = 'エラー';
        short.textContent = 'エラー: ' + (j.msg || JSON.stringify(j));
        detailsEl.textContent = '';
      }
    } catch (e) {
      badge.style.background = '#aa5500'; badge.textContent = '実行エラー';
      short.textContent = e.message;
      detailsEl.textContent = '';
    }
  });

  // initial load of rules
  loadRules();
  
  // Wire test fire button
  document.getElementById('test-fire-btn')?.addEventListener('click', testFire);
});

// --- Notifications and Voice Alerts ---
let lastNotificationTimestamp = null;
let notificationCheckInterval = null;
let notificationPollingStarted = false; // Global flag to prevent multiple instances

async function checkNotifications() {
  const timestamp = new Date().toISOString();
  const stackTrace = new Error().stack;
  console.log('[NOTIFICATIONS] checkNotifications called at ' + timestamp);
  console.log('[NOTIFICATIONS] Call stack:', stackTrace);
  
  try {
    const res = await fetch('/api/notifications');
    if (!res.ok) return;
    const data = await res.json();
    if (data.status !== 'success') return;
    
    const notifications = data.notifications || [];
    if (notifications.length === 0) return;
    
    // Update fire history display
    updateFireHistory(notifications);
    
    // Get the latest notification
    const latest = notifications[0];
    const latestTimestamp = latest.timestamp;
    
    // If this is a new notification (different timestamp)
    if (lastNotificationTimestamp !== latestTimestamp) {
      lastNotificationTimestamp = latestTimestamp;
      
      // Play voice alert
      playVoiceAlert(latest.message);
      
      console.log('[NOTIFICATION]', latest);
    }
  } catch (e) {
    console.log('checkNotifications error', e);
  }
}

function updateFireHistory(notifications) {
  const listEl = document.getElementById('fire-history-list');
  if (!listEl) return;
  
  if (notifications.length === 0) {
    listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
    return;
  }
  
  // Display latest 20 notifications (USDJPY only)
  const usdJpyNotifications = notifications.filter(n => n.symbol === 'USDJPY');
  const displayNotifications = usdJpyNotifications.slice(0, 20);
  
  let html = '';
  displayNotifications.forEach(notif => {
    // Format timestamp: YY/MM/DD HH:mm
    const dt = new Date(notif.timestamp);
    const year = String(dt.getFullYear()).slice(-2);
    const month = String(dt.getMonth() + 1).padStart(2, '0');
    const day = String(dt.getDate()).padStart(2, '0');
    const hour = String(dt.getHours()).padStart(2, '0');
    const minute = String(dt.getMinutes()).padStart(2, '0');
    const timeStr = year + '/' + month + '/' + day + ' ' + hour + ':' + minute;
    
    html += '<div class="fire-item">';
    html += '<span class="fire-time">' + timeStr + '</span>';
    html += '<span class="fire-name">' + (notif.rule_name || '不明') + '</span>';
    html += '</div>';
  });
  
  listEl.innerHTML = html;
  
  // Apply current font size to newly created elements
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  applyFontSize(savedSize);
}

// Sync fire history height with table
function syncFireHistoryHeight() {
  const dashboard = document.getElementById('dashboard');
  const fireHistory = document.getElementById('fire-history');
  
  if (!dashboard || !fireHistory) return;
  
  // Get the actual height of the dashboard content
  const tableWrap = dashboard.querySelector('.table-wrap');
  if (!tableWrap) return;
  
  const table = tableWrap.querySelector('table');
  if (!table) return;
  
  // Get the exact table height
  const tableHeight = table.offsetHeight;
  
  // Set fire history to match table height exactly (accounting for padding)
  const fireHistoryPadding = 24; // 12px top + 12px bottom
  const headerHeight = document.getElementById('fire-history-header')?.offsetHeight || 0;
  const headerMargin = 10; // margin-bottom
  
  // Calculate available height for the list
  const availableHeight = tableHeight - fireHistoryPadding - headerHeight - headerMargin;
  
  // Set the fire history container to match table height
  fireHistory.style.height = tableHeight + 'px';
  
  console.log('[SYNC] Table height:', tableHeight, 'Fire history height:', tableHeight);
}

// Test fire button handler
async function testFire() {
  try {
    const res = await fetch('/api/test_fire', { method: 'POST' });
    const data = await res.json();
    
    if (data.status === 'success') {
      console.log('Test fire sent:', data);
      // Refresh notifications immediately
      setTimeout(checkNotifications, 500);
    } else {
      console.log('Test fire failed:', data);
      alert('テスト発火に失敗しました: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (e) {
    console.log('Test fire error:', e);
    alert('テスト発火エラー: ' + e.message);
  }
}

function playVoiceAlert(message, voiceSettings = null) {
  try {
    // Check if speech synthesis is supported
    if (!('speechSynthesis' in window)) {
      console.log('Speech synthesis not supported');
      return;
    }
    
    // Create utterance
    const utterance = new SpeechSynthesisUtterance(message);
    
    // Get global settings
    const globalVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
    const globalRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
    
    // Apply voice settings (rule-specific or global)
    utterance.lang = 'ja-JP';
    utterance.volume = globalVolume;
    utterance.rate = globalRate;
    
    // Set voice if specified
    if (voiceSettings && voiceSettings.voice_name) {
      const voices = speechSynthesis.getVoices();
      const selectedVoice = voices.find(v => v.name === voiceSettings.voice_name);
      if (selectedVoice) {
        utterance.voice = selectedVoice;
      }
    } else {
      // Use default Japanese voice
      const voices = speechSynthesis.getVoices();
      const japaneseVoice = voices.find(voice => voice.lang.startsWith('ja'));
      if (japaneseVoice) {
        utterance.voice = japaneseVoice;
      }
    }
    
    // Speak
    speechSynthesis.speak(utterance);
    
    console.log('Playing voice alert:', message, 'volume:', utterance.volume, 'rate:', utterance.rate);
  } catch (e) {
    console.log('playVoiceAlert error', e);
  }
}

// Start notification checking
document.addEventListener('DOMContentLoaded', () => {
  // Version check - prevent old code from running
  const REQUIRED_VERSION = '2025-11-08-v1';
  const currentVersion = localStorage.getItem('app_version');
  if (currentVersion !== REQUIRED_VERSION) {
    console.log('[NOTIFICATIONS] Version mismatch, waiting for reload');
    return;
  }
  
  // Check if already initialized
  if (notificationPollingStarted) {
    console.log('[NOTIFICATIONS] Already initialized, skipping');
    return;
  }
  notificationPollingStarted = true;
  
  const instanceId = Math.random().toString(36).substr(2, 9);
  console.log('[NOTIFICATIONS] Instance ID: ' + instanceId + ' - Page loaded - Version: ' + REQUIRED_VERSION);
  
  // Function to get current polling interval (in milliseconds)
  // Base interval: 5 minutes (300 seconds) + update delay offset
  const getPollingInterval = () => {
    const delaySecs = parseInt(localStorage.getItem('tv_update_delay') || '10');
    const baseInterval = 300; // 5 minutes in seconds
    const totalSeconds = baseInterval + delaySecs;
    return totalSeconds * 1000; // Convert to milliseconds
  };
  
  // Function to start polling
  const startNotificationPolling = () => {
    // CRITICAL: Clear ALL existing intervals to prevent duplicates
    // This is a nuclear option to ensure no old timers are running
    const maxTimerId = setTimeout(function(){}, 0);
    for (let i = 1; i <= maxTimerId; i++) {
      clearInterval(i);
    }
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Cleared all existing timers (1-' + maxTimerId + ')');
    
    if (notificationCheckInterval) {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Already running, skipping restart');
      return; // Already running
    }
    const intervalMs = getPollingInterval();
    const intervalSecs = intervalMs / 1000;
    const mins = Math.floor(intervalSecs / 60);
    const secs = Math.floor(intervalSecs % 60);
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Starting polling with interval: ' + intervalMs + 'ms (' + mins + 'm ' + secs + 's)');
    checkNotifications(); // Initial check
    notificationCheckInterval = setInterval(checkNotifications, intervalMs);
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Timer ID: ' + notificationCheckInterval);
  };
  
  // Function to stop polling
  const stopNotificationPolling = () => {
    if (notificationCheckInterval) {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Stopping polling');
      clearInterval(notificationCheckInterval);
      notificationCheckInterval = null;
    }
  };
  
  // Function to restart polling with new interval
  const restartNotificationPolling = () => {
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Restarting polling');
    stopNotificationPolling();
    startNotificationPolling();
  };
  
  // Start polling when page is visible
  startNotificationPolling();
  
  // Stop/resume polling when page visibility changes
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page hidden, stopping');
      stopNotificationPolling();
    } else {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page visible, resuming');
      startNotificationPolling();
    }
  });
  
  // Restart polling when update delay setting changes
  document.getElementById('updateDelayInput')?.addEventListener('change', () => {
    const newDelay = parseInt(document.getElementById('updateDelayInput').value);
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Update delay changed to ' + newDelay + 's, restarting polling');
    restartNotificationPolling();
  });
  
  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page unloading, cleanup');
    stopNotificationPolling();
    notificationPollingStarted = false;
  });
});
</script>
</body>
</html>
