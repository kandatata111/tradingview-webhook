<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>ダウ雲表 v2</title>
<style>
body { font-family: 'Yu Gothic', 'Meiryo', sans-serif; background: #1e3c72; color: #fff; padding: 0 !important; margin: 0 !important; }
.container { max-width: none; margin: 0 !important; padding: 0; }
.header-row { display:flex; align-items:center; justify-content:space-between; padding: 10px 10px 12px 6px; margin: 0 8px 14px 6px; border-bottom: 1px solid rgba(255,255,255,0.45); }
h1 { text-align: left; margin: 0; font-size: 1.55em; letter-spacing: 0.4px; text-shadow: none; }
#dashboard { margin: 0; padding: 0 8px 8px 6px; }
/* 設定パネルスタイル */
.settings { display: flex; gap: 12px; justify-content: flex-end; align-items: center; margin-bottom: 12px; }
.settings label { color: #fff; font-size: 0.95em; }
.settings select, .settings input[type="radio"] { margin-left: 6px; }

/* 設定モーダル */
.settings-button { background:transparent;color:#f5f7ff;border:1px solid rgba(255,255,255,0.8);padding:7px 16px;border-radius:999px;cursor:pointer;display:flex;align-items:center;gap:6px;transition:background 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
.settings-button::before { content:'\2699'; font-size:1.05em; }
.settings-button:hover { background:rgba(255,255,255,0.15); color:#ffffff; }
.modal-overlay { position:fixed; left:0;top:0;right:0;bottom:0; background: rgba(0,0,0,0.4); display:none; align-items:center; justify-content:center; z-index:9999 }
  .modal { background:rgba(255,255,255,0.18); color:#f5f7ff; padding:20px 22px; border-radius:14px; min-width:280px; position:relative; cursor:move; user-select:none; backdrop-filter:blur(14px); -webkit-backdrop-filter:blur(14px); border:1px solid rgba(255,255,255,0.35); box-shadow:0 18px 40px rgba(0,0,0,0.35); max-height:80vh; overflow:auto; }
.modal h3 { margin-top:0; cursor:move; font-weight:600; letter-spacing:0.5px; }
.modal .row { margin-bottom:12px }
.modal label { color:#f5f7ff; }
.modal select, .modal input[type="checkbox"], .modal input[type="radio"] { accent-color:#7ea6ff; }
.modal select { min-width:140px; background:rgba(15,27,65,0.7); color:#f5f7ff; border:1px solid rgba(255,255,255,0.35); border-radius:8px; padding:6px 10px; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.15); }
.modal button { background:rgba(10,20,55,0.6) !important; color:#f5f7ff !important; border:1px solid rgba(255,255,255,0.35) !important; padding:6px 12px !important; border-radius:8px !important; box-shadow:0 8px 18px rgba(0,0,0,0.35); transition:background 0.2s ease, transform 0.2s ease; }
.modal button:hover { background:rgba(30,60,140,0.7) !important; transform:translateY(-1px); }
  .modal .section-header { background:#000; color:#fff; padding:6px 10px; margin:8px 0 10px 0; border-radius:6px; font-weight:600; font-size:0.95em; letter-spacing:0.3px; display:flex; justify-content:space-between; align-items:center; }
  .section-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.5em; line-height:1; padding:0; margin:0; transition:transform 0.2s ease; }
  .section-toggle:hover { transform:scale(1.15); }
  .subsection-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
  .subsection-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.2em; line-height:1; padding:2px 6px; margin:0; transition:transform 0.2s ease; }
  .subsection-toggle:hover { opacity:0.7; }

  /* --- unify sub-item typography inside modal section bodies ---
     Use the "列の表示" labels as the canonical size/weight (0.9em/600)
     This affects labels, selects, buttons and inline texts within section bodies
  */
  .modal .section-body {
    font-size: 0.9em;
    font-weight: 400; /* reduced weight for subitems */
    color: inherit;
  }
  .modal .section-body label,
  .modal .section-body select,
  .modal .section-body button,
  .modal .section-body input,
  .modal .section-body .col-toggle + label,
  .modal .section-body .row-toggle + label {
    font-size: 0.9em;
    font-weight: 400; /* reduced weight for subitems */
    color: inherit;
  }

/* ライト／ダークモード（テーブル色は JS で変更しないように注意） */
.light-mode { background: #f5f5f5 !important; color: #111 !important; }
.light-mode .header-row { border-bottom: 1px solid rgba(0,0,0,0.5); }
.light-mode h1 { color: #111 !important; }
.light-mode .settings-button { color:#111; border-color: rgba(0,0,0,0.7); }
.light-mode .settings-button:hover { background: rgba(0,0,0,0.08); color:#000; }
.dark-mode { background: #1e3c72 !important; color: #fff !important; }

table { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; width: auto; border-collapse: collapse; background: #fff; color: #333; table-layout: auto; margin: 0; }
/* テーブルを角丸にするためのラッパー */
.table-wrap { border-radius: 8px; overflow: hidden; display: inline-block; }
th, td { padding: 4px; border: 1px solid #ddd; text-align: center; white-space: nowrap; width: auto; }
th { font-family: Arial; background: #667eea; color: white; }
.tf-label { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; color: #667eea; }
.up { color: #2962ff; font-weight: bold; }
.down { color: #ef4444; font-weight: bold; }
.loading { text-align: left; padding: 50px; }

/* 新規スタイル */
.header-black { background: #000 !important; color: #fff !important; }
.cell-black { background: #000 !important; color: #fff !important; }
.col-cloud-label { color: #000 !important; }
.price-row td:first-child { background: #fff !important; color: #000 !important; font-weight: bold; }
/* ヘッダーは現状のまま維持し、データ部(td)のみフォントを一段階細くする */
table th { font-weight: bold; font-size: 1.1em; }
table td { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; }
/* ダウ時間(9列目) と 交差時間(10列目) を右揃えにする */
table th:nth-child(9), table td:nth-child(9),
table th:nth-child(10), table td:nth-child(10),
table th:nth-child(11), table td:nth-child(11) {
  text-align: right;
}
/* ヘッダーのダウ時間と交差時間をセンター揃え */
table th:nth-child(9), table th:nth-child(10), table th:nth-child(11) {
  text-align: center;
}

/* 発火履歴ウィンドウ */
.main-content { display: flex; gap: 12px; align-items: flex-start; padding-left: 6px; }
#dashboard { flex: 0 0 auto; }
#fire-history { 
  flex: 0 0 300px; 
  background: rgba(255,255,255,0.1); 
  border: 1px solid rgba(255,255,255,0.25); 
  border-radius: 8px; 
  padding: 12px; 
  overflow: hidden;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  max-height: calc(100vh - 200px);
}

/* 通貨ごとのコンテナ */
.currency-section {
  display: flex;
  gap: 12px;
  align-items: flex-start;
  padding-bottom: 20px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 20px;
}
.currency-section.hidden {
  display: none;
}
.currency-dashboard {
  flex: 0 0 auto;
}
.currency-fire-history {
  flex: 1 1 auto;
  min-width: 300px;
  max-width: calc(100vw - 400px);
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 8px;
  padding: 12px;
  overflow: hidden;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}
.currency-fire-history-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
.currency-fire-history h3 {
  margin: 0;
  font-size: 1em;
  color: #f5f7ff;
  font-weight: 600;
}
.currency-fire-history button {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
.currency-fire-history button:hover {
  background: rgba(102, 126, 234, 0.4);
}
.currency-fire-history-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  max-height: 100%;
}
.fire-item {
  padding: 8px;
  margin-bottom: 6px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  font-size: 0.9em;
  border-left: 3px solid #667eea;
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.fire-item:hover {
  background: rgba(0, 0, 0, 0.3);
}
.fire-time {
  color: #a0c4ff;
  font-weight: 600;
  white-space: nowrap;
}
.fire-name {
  color: #ffd700;
  font-weight: 600;
}
.light-mode .currency-fire-history {
  background: rgba(0, 0, 0, 0.05);
  border-color: rgba(0, 0, 0, 0.2);
}
.light-mode .currency-fire-history-header {
  border-bottom-color: rgba(0, 0, 0, 0.2);
}
/* Light mode: make titles and buttons dark for readability */
.light-mode .currency-fire-history h3,
.light-mode #fire-history h3,
.light-mode .currency-fire-history .currency-fire-history-header h3 {
  color: #111 !important;
}
.light-mode .currency-fire-history button,
.light-mode #test-fire-btn,
.light-mode #clear-fire-history-btn {
  background: rgba(0,0,0,0.05);
  color: #111;
  border-color: rgba(0,0,0,0.6);
}
.light-mode .currency-fire-history button:hover,
.light-mode #test-fire-btn:hover,
.light-mode #clear-fire-history-btn:hover {
  background: rgba(0,0,0,0.08);
}
.light-mode .fire-item {
  background: rgba(0, 0, 0, 0.08);
  border-left-color: #667eea;
}
.light-mode .fire-time {
  color: #2962ff;
}
.light-mode .fire-name {
  color: #d97706;
}

#fire-history-header { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
#fire-history h3 { 
  margin: 0; 
  font-size: 1em;
  color: #f5f7ff; 
  font-weight: 600;
}
#test-fire-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
#test-fire-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
#clear-fire-history-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
#clear-fire-history-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
#fire-history-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  max-height: 100%;
}
.fire-item { 
  padding: 8px; 
  margin-bottom: 6px; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  font-size: 0.9em; 
  border-left: 3px solid #667eea;
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.fire-item:hover { background: rgba(0,0,0,0.3); }
.fire-time { color: #a0c4ff; font-weight: 600; white-space: nowrap; }
.fire-name { color: #ffd700; font-weight: 600; }
.light-mode #fire-history { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.2); }
.light-mode #fire-history-header { border-bottom-color: rgba(0,0,0,0.2); }
.light-mode #test-fire-btn { background: rgba(0,0,0,0.05); color: #111; border-color: rgba(0,0,0,0.6); }
.light-mode #test-fire-btn:hover { background: rgba(0,0,0,0.08); }
.light-mode #clear-fire-history-btn { background: rgba(0,0,0,0.05); color: #111; border-color: rgba(0,0,0,0.6); }
.light-mode #clear-fire-history-btn:hover { background: rgba(0,0,0,0.08); }
.light-mode .fire-item { background: rgba(0,0,0,0.08); border-left-color: #667eea; }
.light-mode .fire-time { color: #2962ff; }
.light-mode .fire-name { color: #d97706; }

/* Dark mode: make fire-history buttons high-contrast (white text + white-ish border) */
.dark-mode .currency-fire-history button,
.dark-mode #test-fire-btn,
.dark-mode #clear-fire-history-btn {
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.9);
}
.dark-mode .currency-fire-history button:hover,
.dark-mode #test-fire-btn:hover,
.dark-mode #clear-fire-history-btn:hover {
  background: rgba(255,255,255,0.06);
}

/* Light mode adjustments */
.light-mode .modal {
  color: #111 !important;
  background: rgba(255,255,255,0.05) !important;
}
.light-mode .modal select {
  color: #f5f7ff !important;
}
</style>
</head>
<body>
<div class="container">
<!-- タイトルと設定ボタンを横並び -->
<div class="header-row">
  <h1>ダウ雲表</h1>
  <button id="openSettings" class="settings-button">設定</button>
</div>

<!-- 設定モーダル（初期は非表示） -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <h3 id="settingsTitle" style="margin:0">各項目設定</h3>
    <button id="closeSettings" style="background:#333;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer">閉じる</button>
  </div>
    
    <!-- 表示調整セクション -->
  <div class="section-header" data-section="displayAdjust">表示調整 <button class="section-toggle" data-section="displayAdjust" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="displayAdjust">
  <div class="row">
      <label>モード</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="dark" id="modeDark"> ダーク</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="light" id="modeLight"> ライト</label>
    </div>
    <div class="row">
      <label for="fontSizeSelect">文字サイズ</label>
      <select id="fontSizeSelect" aria-label="表の文字サイズ">
        <option value="10">10px</option>
        <option value="11">11px</option>
        <option value="12">12px</option>
        <option value="13">13px</option>
        <option value="14">14px</option>
        <option value="15">15px</option>
        <option value="16">16px</option>
        <option value="17">17px</option>
        <option value="18">18px</option>
      </select>
    </div>
    <div class="row">
      <label for="timeFormatSelect">経過時間の表示</label>
      <select id="timeFormatSelect" aria-label="経過時間の表示形式">
        <option value="datetime">測定開始日時</option>
        <option value="dhm">日/時/分</option>
        <option value="hm">時/分</option>
        <option value="m">分のみ</option>
      </select>
    </div>
    <div class="row">
      <label for="updateDelayInput">更新時間の調整 (秒)</label>
      <input type="number" id="updateDelayInput" min="0" max="300" step="1" value="10" aria-label="データ更新の遅延時間（秒）" style="min-width:80px; background:rgba(15,27,65,0.7); color:#f5f7ff; border:1px solid rgba(255,255,255,0.35); border-radius:8px; padding:6px 10px; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.15);">
    </div>
    
    <!-- 列の表示セクション -->
  </div>
  <div class="section-header" data-section="columns">列の表示 <button class="section-toggle" data-section="columns" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="columns">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="1" checked> ダウ転</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="2" checked> 突破数</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="3" checked> 雲交差</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="4" checked> 各雲間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="5" checked> 価格間</label>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="6" checked> 雲角度</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="7" checked> 雲厚み</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="8" checked> ダウ時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="9" checked> 交差時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="10" checked> 時間差</label>
      </div>
    </div>
    
    <!-- 行の表示セクション -->
  </div>
  <div class="section-header" data-section="rows">行の表示 <button class="section-toggle" data-section="rows" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="rows">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="5m" checked> 5m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="15m" checked> 15m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="1H" checked> 1H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="4H" checked> 4H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="price" checked> 価格</label>
      </div>
    </div>
    
    <!-- 通貨フィルターセクション -->
  </div>
  <div class="section-header" data-section="currencies">通貨フィルター <button class="section-toggle" data-section="currencies" aria-expanded="true">▾</button></div>
  <div class="section-body" data-section-body="currencies">
  <div class="row">
      <div id="currencyFilterContainer" style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <!-- 通貨チェックボックスは動的に生成されます -->
      </div>
  </div>
  </div>

    <!-- 音声設定セクション（グローバル設定のみ） -->
    <div class="section-header" data-section="voice">音声設定 <button class="section-toggle" data-section="voice" aria-expanded="true">▾</button></div>
    <div class="section-body" data-section-body="voice">
    <div class="row">
      <label for="voiceVolume">音量</label>
      <input type="range" id="voiceVolume" min="0" max="1" step="0.01" value="0.8" aria-label="音量" style="min-width:150px;">
      <span id="voiceVolumeValue" style="margin-left:8px">80%</span>
    </div>
    <div class="row">
      <label for="voiceRate">音速</label>
      <input type="range" id="voiceRate" min="0.5" max="2.0" step="0.1" value="1.0" aria-label="音速" style="min-width:150px;">
      <span id="voiceRateValue" style="margin-left:8px">1.0x</span>
    </div>
    </div>

    <!-- 発火条件セクション -->
    <div class="section-header" data-section="rules">発火条件（ルール） <button class="section-toggle" data-section="rules" aria-expanded="true">▾</button></div>
    <div class="section-body" data-section-body="rules">
    <div class="row" style="display:flex;flex-direction:column;gap:10px">
      <div style="width:100%; max-height:220px; overflow:auto; border:1px solid rgba(255,255,255,0.08); padding:8px; border-radius:8px; background:rgba(0,0,0,0.12);">
        <div class="subsection-header">
          <strong>保存済みルール</strong>
          <div style="display:flex;gap:6px;align-items:center">
            <button id="newRuleBtn" style="font-size:0.9em;padding:4px 8px">新規ルール作成</button>
            <button class="subsection-toggle" data-subsection="savedRules" aria-expanded="true">▾</button>
          </div>
        </div>
        <div class="subsection-body" data-subsection-body="savedRules">
          <ul id="rulesList" style="list-style:none;padding:0;margin:0;display:block"></ul>
        </div>
      </div>

      <div style="width:100%; max-height:360px; overflow:auto; border:1px solid rgba(255,255,255,0.08); padding:8px; border-radius:8px; background:rgba(0,0,0,0.06);">
        <div class="subsection-header">
          <strong>ルール編集</strong>
          <button class="subsection-toggle" data-subsection="ruleEditor" aria-expanded="true">▾</button>
        </div>
        <div class="subsection-body" data-subsection-body="ruleEditor">
        <div style="display:flex;gap:8px;flex-direction:column">
          <div style="display:flex;flex-direction:column;gap:8px;width:100%">
            <div style="display:flex;align-items:center;gap:8px">
              <label style="font-size:0.9em;min-width:72px">ルール名：</label>
              <input id="ruleName" placeholder="ルール名" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit">
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <label style="font-size:0.9em;min-width:72px">通貨選択：</label>
              <select id="ruleScope" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:160px">
                <option value="">全選択</option>
              </select>
            </div>
          </div>
          
          <!-- 音声設定（ルール個別設定） -->
          <div style="margin-top:12px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.04);">
            <div style="font-weight:600;margin-bottom:6px">音声設定</div>
            <div style="display:flex;flex-direction:column;gap:6px">
              <label style="font-size:0.9em">
                音声メッセージ:
                <input id="voiceMessage" placeholder="例: ルールが発火しました" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:300px">
              </label>
              <label style="font-size:0.9em">
                <input type="checkbox" id="insertSymbol"> 通貨名挿入
                <select id="symbolInsertPosition" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;">
                  <option value="prefix">先頭</option>
                  <option value="suffix">最後</option>
                  <option value="both">先頭と最後</option>
                </select>
              </label>
              <label style="font-size:0.9em">
                <input type="checkbox" id="voiceDirectionBased"> 方向別アラーム
                <select id="voiceMessagePosition" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;">
                  <option value="prefix">先頭</option>
                  <option value="suffix">最後</option>
                  <option value="both">先頭と最後</option>
                </select>
              </label>
              <div id="directionMessages" style="display:none;flex-direction:row;gap:12px;margin-left:8px;align-items:center">
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  上昇：
                  <input id="voiceMessageUp" placeholder="例: 上昇トレンドが検出されました" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  下降：
                  <input id="voiceMessageDown" placeholder="例: 下降トレンドが検出されました" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
              </div>
              <label style="font-size:0.9em;display:flex;align-items:center;gap:8px">
                <input type="checkbox" id="playChimeFirst"> 最初に電子音を鳴らす：
                <select id="chimeSelect" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:160px">
                  <option value="">なし</option>
                </select>
              </label>
              <label style="font-size:0.9em;display:flex;align-items:center;gap:8px">
                音声選択:
                <select id="voiceSelect" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:200px">
                  <option value="">グローバル設定を使用</option>
                  <!-- 音声リストは動的に追加 -->
                </select>
                <button id="testVoiceBtn" style="padding:6px 12px;">テスト再生</button>
              </label>
            </div>
          </div>
          
          <!-- 雲整列条件 UI（ユーザー指定レイアウト） -->
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:6px;padding:6px;border-radius:6px;background:rgba(0,0,0,0.02);">
            <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">
              <strong style="margin-right:6px">雲整列条件</strong>
              <label style="font-size:0.9em"><input type="checkbox" id="alignAllTf"> 全時間</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="5m"> 5m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="15m"> 15m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="1H"> 1H</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="4H"> 4H</label>
            </div>
            <div style="display:flex;align-items:center;gap:12px">
              <div style="display:flex;align-items:center;gap:8px">
                <label style="font-size:0.9em">欠損</label>
                <select id="alignMissing" style="padding:6px;border-radius:6px;background:rgba(15,27,65,0.7);color:inherit;border:1px solid rgba(255,255,255,0.12)">
                  <option value="ignore">無視</option>
                  <option value="fail">不一致</option>
                </select>
                <span id="alignMissingTooltip" style="cursor:pointer;font-size:1.2em;color:white;">ⓘ</span>
              </div>
            </div>
            <div id="alignError" style="color:#ffb4b4;font-weight:600;margin-top:6px;display:none;width:100%"></div>
          </div>
          <div id="conditionsContainer" style="display:flex;flex-direction:column;gap:6px">
            <!-- 単純な1条件行のテンプレート -->
            <div class="cond-row" style="display:flex;gap:6px;align-items:center">
              <select class="cond-tf" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="5m">5m</option>
                <option value="15m">15m</option>
                <option value="1H">1H</option>
                <option value="4H">4H</option>
              </select>
              <select class="cond-field" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="dauten">ダウ転</option>
                <option value="bos_count">突破数</option>
                <option value="gc">雲交差</option>
                <option value="distance_from_prev">各雲間</option>
                <option value="distance_from_price">価格間</option>
                <option value="angle">雲角度</option>
                <option value="thickness">雲厚み</option>
                <option value="transfer_time_diff">転換時間差</option>
              </select>
              <select class="cond-op" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="==">==</option>
                <option value=">=">&gt;=</option>
                <option value=">">&gt;</option>
                <option value="<=">&lt;=</option>
                <option value="<">&lt;</option>
              </select>
              <input class="cond-value" placeholder="値" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit;width:120px">
              <button class="removeCond" style="padding:6px 12px">削除</button>
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button id="addCondBtn" style="padding:6px 12px">条件を追加</button>
            <button id="testRuleBtn" style="padding:6px 12px">ルールをテスト</button>
            <button id="saveRuleBtn" style="margin-left:auto;padding:6px 12px">ルールを保存</button>
          </div>
          <div style="margin-top:8px">
            <div style="font-weight:600;margin-bottom:4px">テスト結果</div>
            <div id="ruleTestResult" style="background:rgba(0,0,0,0.06);color:inherit;padding:8px;border-radius:6px;max-height:260px;overflow:auto">
              <div class="test-summary" style="display:flex;align-items:center;gap:10px">
                <div id="testBadge" style="font-weight:700;padding:6px 10px;border-radius:6px;background:#444;color:#fff">未実行</div>
                <div id="testShort" style="opacity:0.9">ルールを実行して結果を確認してください</div>
              </div>
              <div id="testDetails" style="margin-top:8px;font-size:0.9em;color:inherit">結果の詳細はここに表示されます。</div>
            </div>
          </div>
        </div>
        </div>
      </div>
    </div>
    </div>
  </div>
</div>

<div class="main-content">
  <div id="dashboards-container">
    <!-- 通貨ごとの表と発火履歴が動的に生成されます -->
  </div>
</div>

</div>
<script>
// Version check and cache buster - 2025-11-10-v2
(function() {
  const REQUIRED_VERSION = '2025-11-10-v2';
  const currentVersion = localStorage.getItem('app_version');
  if (currentVersion !== REQUIRED_VERSION) {
    console.log('[VERSION] Updating from', currentVersion, 'to', REQUIRED_VERSION);
    localStorage.setItem('app_version', REQUIRED_VERSION);
    // Force hard reload to clear cache
    console.log('[VERSION] Hard reload required - clearing cache');
    window.location.reload(true);
    return;
  }
})();

// 通貨名マッピング（サーバー側と同じ）
const currencyNames = {
  'USDJPY': 'ドル円',
  'EURUSD': 'ユーロドル',
  'GBPUSD': 'ポンドドル',
  'GBPJPY': 'ポンド円',
  'AUDUSD': 'オージードル',
  'AUDJPY': 'オージー円',
  'NZDUSD': 'ニュージードル',
  'NZDJPY': 'ニュージー円',
  'CADJPY': 'カナダ円',
  'CHFJPY': 'スイス円',
  'EURJPY': 'ユーロ円',
  'GBPAUD': 'ポンドオージー',
  'EURGBP': 'ユーロポンド',
  'USDCAD': 'ドルカナダ',
  'USDCHF': 'ドルスイス'
};

// グローバル変数: 現在のダッシュボードデータ（テスト時に使用）
let currentDashboardData = null;

// 設定パネルの動作: モード切替（body にクラス付与）とフォントサイズの適用
function applyMode(mode) {
  document.body.classList.remove('light-mode','dark-mode');
  if (mode === 'light') document.body.classList.add('light-mode');
  else document.body.classList.add('dark-mode');
}

function applyFontSize(px) {
  // テーブルの th と td にのみフォントサイズを適用（セルの色は変更しない）
  const els = document.querySelectorAll('table th, table td');
  els.forEach(el => {
    el.style.fontSize = px + 'px';
  });
  
  // 発火履歴ウィンドウの全要素にフォントサイズを適用
  const fireHistoryEls = document.querySelectorAll('.currency-fire-history h3, .currency-fire-history button, .fire-item, .fire-time, .fire-name, .currency-fire-history-list');
  fireHistoryEls.forEach(el => {
    el.style.fontSize = px + 'px';
  });
  
  // 発火履歴ウィンドウの横幅を文字サイズに合わせて調整
  // 基本: 300px (14px時) + 追加幅
  const baseFontSize = 14;
  const additionalWidth = Math.max(0, (px - baseFontSize) * 8); // 文字サイズが1px増えるごとに8px横幅を増やす
  const newWidth = 300 + additionalWidth;
  
  const fireHistories = document.querySelectorAll('.currency-fire-history');
  fireHistories.forEach(fh => {
    fh.style.minWidth = newWidth + 'px';
  });
}

function applyColumnVisibility() {
  const cols = document.querySelectorAll('.col-toggle');
  cols.forEach(cb => {
    const colIndex = parseInt(cb.dataset.col);
    const visible = cb.checked;
    // colIndex は 1-indexed（雲整列は0列目、ダウ転は1列目...）
    const selector = `table th:nth-child(${colIndex + 1}), table td:nth-child(${colIndex + 1})`;
    document.querySelectorAll(selector).forEach(el => {
      el.style.display = visible ? '' : 'none';
    });
  });
}

function applyRowVisibility() {
  const rows = document.querySelectorAll('.row-toggle');
  rows.forEach(cb => {
    const rowLabel = cb.dataset.row;
    const visible = cb.checked;
    // 各行は tf-label セルの textContent で識別
    const allRows = document.querySelectorAll('table tr');
    allRows.forEach(tr => {
      const labelCell = tr.querySelector('.tf-label');
      if (labelCell) {
        const text = labelCell.textContent.trim();
        if ((rowLabel === 'price' && text === '価格') ||
            (rowLabel === '5m' && text === '5m') ||
            (rowLabel === '15m' && text === '15m') ||
            (rowLabel === '1H' && text === '1H') ||
            (rowLabel === '4H' && text === '4H')) {
          tr.style.display = visible ? '' : 'none';
        }
      }
    });
  });
}

function applyCurrencyFilter() {
  const currencies = document.querySelectorAll('.currency-toggle');
  const enabled = new Set();
  currencies.forEach(cb => {
    if (cb.checked) enabled.add(cb.dataset.currency);
  });
  
  // 通貨ごとのセクションを表示/非表示
  document.querySelectorAll('.currency-section').forEach(section => {
    const symbol = section.dataset.symbol;
    if (enabled.has(symbol)) {
      section.classList.remove('hidden');
    } else {
      section.classList.add('hidden');
    }
  });
}

function updateCurrencyFilter(availableCurrencies) {
  const container = document.getElementById('currencyFilterContainer');
  const savedCurrencies = JSON.parse(localStorage.getItem('tv_currencies') || '{}');
  
  // 既存のチェックボックスの通貨を記録
  const existingCurrencies = new Set();
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    existingCurrencies.add(cb.dataset.currency);
  });
  
  // 新しい通貨があれば追加
  availableCurrencies.forEach(currency => {
    if (!existingCurrencies.has(currency)) {
      const label = document.createElement('label');
      label.style.fontSize = '0.9em';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'currency-toggle';
      checkbox.dataset.currency = currency;
      checkbox.checked = (savedCurrencies[currency] !== false); // デフォルトtrue
      
      checkbox.addEventListener('change', () => {
        const currencies = {};
        document.querySelectorAll('.currency-toggle').forEach(cb => {
          currencies[cb.dataset.currency] = cb.checked;
        });
        localStorage.setItem('tv_currencies', JSON.stringify(currencies));
        applyCurrencyFilter();
      });
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(' ' + currency));
      container.appendChild(label);
    }
  });
  
  // 保存された設定を適用
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    const currency = cb.dataset.currency;
    cb.checked = (savedCurrencies[currency] !== false);
  });
  
  applyCurrencyFilter();
}

function loadSettings() {
  const savedMode = localStorage.getItem('tv_mode') || 'dark';
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  const savedCols = JSON.parse(localStorage.getItem('tv_cols') || '{}');
  const savedRows = JSON.parse(localStorage.getItem('tv_rows') || '{}');
  const savedTimeFormat = localStorage.getItem('tv_time_format') || 'datetime';
  const savedUpdateDelay = localStorage.getItem('tv_update_delay') || '10';
  const savedVoiceVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
  const savedVoiceRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
  
  // set UI
  document.getElementById('modeDark').checked = (savedMode === 'dark');
  document.getElementById('modeLight').checked = (savedMode === 'light');
  document.getElementById('fontSizeSelect').value = savedSize;
  document.getElementById('timeFormatSelect').value = savedTimeFormat;
  document.getElementById('updateDelayInput').value = savedUpdateDelay;
  document.getElementById('voiceVolume').value = savedVoiceVolume;
  document.getElementById('voiceVolumeValue').textContent = Math.round(savedVoiceVolume * 100) + '%';
  document.getElementById('voiceRate').value = savedVoiceRate;
  document.getElementById('voiceRateValue').textContent = savedVoiceRate.toFixed(1) + 'x';
  
  // 列チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    const col = cb.dataset.col;
    cb.checked = (savedCols[col] !== false); // デフォルトtrue
  });
  
  // 行チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    const row = cb.dataset.row;
    cb.checked = (savedRows[row] !== false); // デフォルトtrue
  });
  
  applyMode(savedMode);
  applyFontSize(savedSize);
  applyColumnVisibility();
  applyRowVisibility();
}

function wireSettings() {
  document.getElementById('modeDark').addEventListener('change', e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','dark'); applyMode('dark'); }
  });
  document.getElementById('modeLight').addEventListener('change', e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','light'); applyMode('light'); }
  });
  document.getElementById('fontSizeSelect').addEventListener('change', e => {
    localStorage.setItem('tv_font_size', e.target.value);
    applyFontSize(e.target.value);
  });
  
  // 列表示チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    cb.addEventListener('change', () => {
      const cols = {};
      document.querySelectorAll('.col-toggle').forEach(c => {
        cols[c.dataset.col] = c.checked;
      });
      localStorage.setItem('tv_cols', JSON.stringify(cols));
      applyColumnVisibility();
    });
  });
  
  // 行表示チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    cb.addEventListener('change', () => {
      const rows = {};
      document.querySelectorAll('.row-toggle').forEach(r => {
        rows[r.dataset.row] = r.checked;
      });
      localStorage.setItem('tv_rows', JSON.stringify(rows));
      applyRowVisibility();
    });
  });
  
  // 経過時間形式プルダウン
  document.getElementById('timeFormatSelect').addEventListener('change', e => {
    localStorage.setItem('tv_time_format', e.target.value);
    load(); // 再読み込みして表示を更新
  });
  
  // 更新時間の調整
  document.getElementById('updateDelayInput').addEventListener('change', async e => {
    const delay = parseInt(e.target.value);
    if (isNaN(delay) || delay < 0 || delay > 300) {
      alert('更新時間は0-300秒の範囲で入力してください');
      e.target.value = localStorage.getItem('tv_update_delay') || '10';
      return;
    }
    localStorage.setItem('tv_update_delay', delay.toString());
    // サーバーに設定を保存
    try {
      const res = await fetch('/api/settings', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ update_delay_seconds: delay })
      });
      const data = await res.json();
      if (data.status !== 'success') {
        alert('設定保存に失敗しました: ' + (data.msg || '不明なエラー'));
      }
    } catch (err) {
      console.error('設定保存エラー:', err);
      alert('設定保存中にエラーが発生しました');
    }
    // タイマーを再設定
    scheduleNextUpdate();
  });
  
  // 音声設定（グローバル）
  document.getElementById('voiceVolume').addEventListener('input', e => {
    const vol = parseFloat(e.target.value);
    document.getElementById('voiceVolumeValue').textContent = Math.round(vol * 100) + '%';
    localStorage.setItem('tv_voice_volume', vol.toString());
  });
  document.getElementById('voiceRate').addEventListener('input', e => {
    const rate = parseFloat(e.target.value);
    document.getElementById('voiceRateValue').textContent = rate.toFixed(1) + 'x';
    localStorage.setItem('tv_voice_rate', rate.toString());
  });
}

function wireSectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_sections') || '{}');
    document.querySelectorAll('.section-toggle').forEach(btn => {
      const sec = btn.dataset.section;
      const body = document.querySelector(`.section-body[data-section-body="${sec}"]`);
      if (!body) return;
      const expanded = (saved[sec] !== undefined) ? !!saved[sec] : true;
      body.style.display = expanded ? '' : 'none';
      btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      btn.textContent = expanded ? '▾' : '▸';
      btn.addEventListener('click', () => {
        const cur = body.style.display !== 'none';
        const next = !cur;
        body.style.display = next ? '' : 'none';
        btn.setAttribute('aria-expanded', next ? 'true' : 'false');
        btn.textContent = next ? '▾' : '▸';
        const s = JSON.parse(localStorage.getItem('tv_sections') || '{}');
        s[sec] = next;
        localStorage.setItem('tv_sections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSectionToggles error', e);
  }
}

// Wire subsection toggles (for saved rules and rule editor)
function wireSubsectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
    document.querySelectorAll('.subsection-toggle').forEach(btn => {
      const subsec = btn.dataset.subsection;
      const body = document.querySelector(`.subsection-body[data-subsection-body="${subsec}"]`);
      if (!body) return;
      const expanded = (saved[subsec] !== undefined) ? !!saved[subsec] : true;
      body.style.display = expanded ? '' : 'none';
      btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      btn.textContent = expanded ? '▾' : '▸';
      btn.addEventListener('click', () => {
        const cur = body.style.display !== 'none';
        const next = !cur;
        body.style.display = next ? '' : 'none';
        btn.setAttribute('aria-expanded', next ? 'true' : 'false');
        btn.textContent = next ? '▾' : '▸';
        const s = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
        s[subsec] = next;
        localStorage.setItem('tv_subsections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSubsectionToggles error', e);
  }
}

// Populate the rule scope select (通貨選択) with available currencies
function populateRuleScopeSelect(availableCurrencies) {
  try {
    const sel = document.getElementById('ruleScope');
    if (!sel) return;
    const cur = sel.value;
    // Always keep the default '全選択' option
    sel.innerHTML = '';
    const optAll = document.createElement('option'); optAll.value = ''; optAll.textContent = '全選択'; sel.appendChild(optAll);
    (availableCurrencies || []).forEach(sym => {
      const o = document.createElement('option'); o.value = sym; o.textContent = sym; sel.appendChild(o);
    });
    // restore previous selection if still present
    if (cur && [...sel.options].some(o => o.value === cur)) sel.value = cur;
  } catch (e) { console.log('populateRuleScopeSelect error', e); }
}

// Populate voice select with available voices
function populateVoiceSelect() {
  if (!('speechSynthesis' in window)) return;
  
  const select = document.getElementById('voiceSelect');
  if (!select) return;
  const currentValue = select.value;
  
  select.innerHTML = '';
  
  const voices = speechSynthesis.getVoices();
  const allowedVoices = {
    'Microsoft 七海 Online (Natural) - Japanese (Japan)': '七海［女性］',
    'Microsoft 圭太 Online (Natural) - Japanese (Japan)': '圭太［男性］',
    'Microsoft 碧衣 Online (Natural) - Japanese (Japan)': '碧衣［女性］',
    'Microsoft 大智 Online (Natural) - Japanese (Japan)': '大智［男性］',
    'Microsoft 真夕 Online (Natural) - Japanese (Japan)': '真夕［女性］',
    'Microsoft 直紀 Online (Natural) - Japanese (Japan)': '直紀［男性］',
    'Microsoft 志織 Online (Natural) - Japanese (Japan)': '志織［女性］'
  };
  
  voices.forEach(voice => {
    if (voice.lang.startsWith('ja') && allowedVoices[voice.name]) {
      const option = document.createElement('option');
      option.value = voice.name;
      option.textContent = allowedVoices[voice.name];
      select.appendChild(option);
    }
  });
  
  // Restore previous selection if it still exists
  if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
    select.value = currentValue;
  }
}

// Populate chime select with available chime files
async function populateChimeSelect() {
  const select = document.getElementById('chimeSelect');
  if (!select) return;
  const currentValue = select.value;
  
  select.innerHTML = '<option value="">なし</option>';
  
  try {
    const response = await fetch('/api/chime_files');
    const data = await response.json();
    if (data.status === 'success') {
      data.files.forEach(file => {
        const option = document.createElement('option');
        option.value = file;
        option.textContent = file.replace('.mp3', '');
        select.appendChild(option);
      });
    }
  } catch (e) {
    console.log('Error fetching chime files:', e);
    // Fallback to static list
    const chimeFiles = [
      'お寺の鐘.mp3',
      'きらきら輝く6.mp3',
      'ほら貝を吹き鳴らす.mp3',
      'ドンドンパフパフ.mp3',
      'ラッパのファンファーレ.mp3',
      'レベルアップ.mp3',
      '放送開始チャイム.mp3',
      '教会の鐘2.mp3',
      '歓声と拍手.mp3',
      '決定ボタンを押す4.mp3',
      '決定ボタンを押す5.mp3',
      '男衆「イエーイ！」.mp3',
      '男衆「イヤッホー！」.mp3',
      '突撃ラッパ.mp3',
      '警報が鳴る.mp3',
      '開演ブザー.mp3'
    ];
    chimeFiles.forEach(file => {
      const option = document.createElement('option');
      option.value = file;
      option.textContent = file.replace('.mp3', '');
      select.appendChild(option);
    });
  }
  
  // Restore previous selection if it still exists
  if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
    select.value = currentValue;
  }
}

// 初期化: 設定を読み込み、UI を配線
document.addEventListener('DOMContentLoaded', async () => {
  try { 
    loadSettings(); 
    wireSettings(); 
    wireSectionToggles(); 
    wireSubsectionToggles();
    
    // サーバーから最新の更新遅延設定を取得して同期
    try {
      const res = await fetch('/api/settings');
      const data = await res.json();
      if (data.status === 'success' && data.settings) {
        const serverDelay = data.settings.update_delay_seconds || 10;
        document.getElementById('updateDelayInput').value = serverDelay.toString();
        localStorage.setItem('tv_update_delay', serverDelay.toString());
      }
    } catch (err) {
      console.log('サーバー設定取得エラー:', err);
    }
    
    // Populate voice and chime selects
    populateVoiceSelect();
    await populateChimeSelect();
  } catch (err) { console.log('settings init error', err); }
});

// モーダル開閉とドラッグ機能
document.addEventListener('DOMContentLoaded', () => {
  const openBtn = document.getElementById('openSettings');
  const closeBtn = document.getElementById('closeSettings');
  const overlay = document.getElementById('settingsModal');
  const modal = document.querySelector('.modal');
  
  openBtn?.addEventListener('click', () => { overlay.style.display = 'flex'; });
  closeBtn?.addEventListener('click', () => { overlay.style.display = 'none'; });
  // クリックでオーバーレイを閉じる（モーダル内は除外）
  overlay?.addEventListener('click', (e) => { if (e.target === overlay) overlay.style.display = 'none'; });
  
  // モーダルのドラッグ機能
  let isDragging = false, offsetX = 0, offsetY = 0;
  
  modal?.addEventListener('mousedown', e => {
    // input/select/button はドラッグ開始しない
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') return;
    isDragging = true;
    const rect = modal.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;
    modal.style.position = 'fixed';
    modal.style.margin = '0';
  });
  
  document.addEventListener('mousemove', e => {
    if (!isDragging) return;
    e.preventDefault();
    modal.style.left = (e.clientX - offsetX) + 'px';
    modal.style.top = (e.clientY - offsetY) + 'px';
  });
  
  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
});

// 経過時間変換関数
function formatElapsedTime(datetimeStr, format) {
  if (!datetimeStr || datetimeStr === '-' || datetimeStr === '') return '-';
  
  // format === 'datetime' の場合はそのまま返す
  if (format === 'datetime') return datetimeStr;
  
  console.log('formatElapsedTime called:', datetimeStr, 'format:', format);
  
  // datetimeStr をパースして経過時間（分）を計算
  // 想定形式: "YY/MM/DD/HH:MM" (例: "25/10/31/21:35")
  try {
    const now = new Date();
    const segments = datetimeStr.trim().split('/');
    
    if (segments.length < 4) {
      console.log('Invalid format, expected YY/MM/DD/HH:MM, got:', segments);
      return datetimeStr;
    }
    
    // YY/MM/DD/HH:MM 形式をパース
    const year = 2000 + parseInt(segments[0], 10); // YY を YYYY に変換
    const month = parseInt(segments[1], 10) - 1; // 0-indexed
    const day = parseInt(segments[2], 10);
    
    // 時間部分を処理 (HH:MM)
    const timePart = segments[3]; // "HH:MM"
    const timeSegments = timePart.split(':');
    
    if (timeSegments.length < 2) {
      console.log('Invalid time format:', timePart);
      return datetimeStr;
    }
    
    const hour = parseInt(timeSegments[0], 10);
    const minute = parseInt(timeSegments[1], 10);
    
    const startTime = new Date(year, month, day, hour, minute);
    const elapsedMs = now - startTime;
    const elapsedMinutes = Math.floor(elapsedMs / 60000);
    
    // 5分刻みに丸める
    const roundedElapsedMinutes = Math.floor(elapsedMinutes / 5) * 5;
    
    console.log('Parsed:', { year, month, day, hour, minute, elapsedMinutes, roundedElapsedMinutes });
    
    if (elapsedMinutes < 0) {
      console.log('Negative elapsed time');
      return datetimeStr; // 未来の日時は元の文字列
    }
    
    if (format === 'm') {
      // 分のみ: "7320m"
      return roundedElapsedMinutes + 'm';
    } else if (format === 'hm') {
      // 時/分: "122:00" または "05:00"
      const hours = Math.floor(roundedElapsedMinutes / 60);
      const mins = roundedElapsedMinutes % 60;
      return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    } else if (format === 'dhm') {
      // 日/時/分: "05/02:00"
      const days = Math.floor(roundedElapsedMinutes / 1440);
      const remainMins = roundedElapsedMinutes % 1440;
      const hours = Math.floor(remainMins / 60);
      const mins = remainMins % 60;
      return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    }
    
    return datetimeStr;
  } catch (e) {
    console.error('formatElapsedTime error:', e, 'input:', datetimeStr);
    return datetimeStr;
  }
}

function calculateTransferTimeDiff(cloud) {
  const dautenTimeStr = cloud.dauten_start_time_str;
  const crossTimeStr = cloud.elapsed_str;
  if (!dautenTimeStr || !crossTimeStr || dautenTimeStr === '-' || crossTimeStr === '-') return { diff: null, sameDirection: false };
  
  const dautenDir = cloud.dauten; // 'up' or 'down'
  const crossDir = cloud.gc; // true or false
  
  // 同方向チェック: dauten 'up' matches gc true (GC), dauten 'down' matches gc false (DC)
  const dautenUp = dautenDir === 'up';
  const crossUp = crossDir === true;
  const sameDirection = dautenUp === crossUp;
  
  if (!sameDirection) return { diff: null, sameDirection: false };
  
  // 時間差計算
  function parseTime(str) {
    if (!str || str === '-') return null;
    const segments = str.split('/');
    if (segments.length < 4) return null;
    const year = 2000 + parseInt(segments[0]);
    const month = parseInt(segments[1]) - 1;
    const day = parseInt(segments[2]);
    const timePart = segments[3];
    let hour = 0, minute = 0;
    if (timePart.includes(':')) {
      const tp = timePart.split(':');
      hour = parseInt(tp[0]);
      minute = parseInt(tp[1]);
    } else {
      hour = parseInt(timePart);
    }
    return new Date(year, month, day, hour, minute);
  }
  
  const dautenTime = parseTime(dautenTimeStr);
  const crossTime = parseTime(crossTimeStr);
  if (!dautenTime || !crossTime) return { diff: null, sameDirection: false };
  
  const diffMs = Math.abs(dautenTime - crossTime);
  const diffMin = Math.floor(diffMs / 60000);
  return { diff: diffMin, sameDirection: true };
}

function formatTimeDiff(diffMin, format) {
  if (format === 'datetime') return '-';
  if (diffMin === null) return '-';
  if (format === 'm') return diffMin + 'm';
  if (format === 'hm') {
    const hours = Math.floor(diffMin / 60);
    const mins = diffMin % 60;
    return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  if (format === 'dhm') {
    const days = Math.floor(diffMin / 1440);
    const remainMins = diffMin % 1440;
    const hours = Math.floor(remainMins / 60);
    const mins = remainMins % 60;
    return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  return diffMin + 'm';
}

async function load() {
  const update_at = new Date().toISOString();
  console.log('[CLIENT UPDATE START]', update_at);
  console.log('Loading data...');
  try {
    const r = await fetch('/current_states');
    console.log('Response status:', r.status);
    
    if (!r.ok) {
      throw new Error('HTTP ' + r.status);
    }
    
    const data = await r.json();
    console.log('Data received:', data);
    
    if (data.status === 'success' && data.states.length > 0) {
      // 現在のダッシュボードデータを保存（テスト時に使用）
      currentDashboardData = data.states;
      
      // 利用可能な通貨を抽出
      const availableCurrencies = [...new Set(data.states.map(s => s.symbol))];
  updateCurrencyFilter(availableCurrencies);
  // Populate rule editor scope select with current available currencies
  try { populateRuleScopeSelect(availableCurrencies); } catch (e) { console.log('populateRuleScopeSelect call error', e); }
      
      // 通貨ごとにコンテナを生成
      const container = document.getElementById('dashboards-container');
      container.innerHTML = '';
      
      availableCurrencies.forEach(symbol => {
        // 各通貨のセクションを作成
        const section = document.createElement('div');
        section.className = 'currency-section';
        section.dataset.symbol = symbol;
        
        const isVisible = JSON.parse(localStorage.getItem('tv_currencies') || '{}')[symbol] !== false;
        if (!isVisible) {
          section.classList.add('hidden');
        }
        
        // 通貨ごとのテーブルを作成
        const dashboardDiv = document.createElement('div');
        dashboardDiv.className = 'currency-dashboard';
        section.appendChild(dashboardDiv);
        
        // 通貨ごとの発火履歴ウィンドウを作成
        const fireHistoryDiv = document.createElement('div');
        fireHistoryDiv.className = 'currency-fire-history';
        fireHistoryDiv.dataset.symbol = symbol;
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'currency-fire-history-header';
        
        const titleH3 = document.createElement('h3');
        titleH3.textContent = symbol + '発火履歴';
        
        const buttonsDiv = document.createElement('div');
        buttonsDiv.style.display = 'flex';
        buttonsDiv.style.gap = '8px';
        
        const testBtn = document.createElement('button');
        testBtn.textContent = 'テスト発火';
        testBtn.dataset.symbol = symbol;
        testBtn.addEventListener('click', () => testFire(symbol));
        
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'クリア';
        clearBtn.dataset.symbol = symbol;
        clearBtn.addEventListener('click', () => clearFireHistory(symbol));
        
        buttonsDiv.appendChild(testBtn);
        buttonsDiv.appendChild(clearBtn);
        
        headerDiv.appendChild(titleH3);
        headerDiv.appendChild(buttonsDiv);
        fireHistoryDiv.appendChild(headerDiv);
        
        const listDiv = document.createElement('div');
        listDiv.className = 'currency-fire-history-list';
        listDiv.dataset.symbol = symbol;
        listDiv.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
        
        fireHistoryDiv.appendChild(listDiv);
        section.appendChild(fireHistoryDiv);
        
        container.appendChild(section);
        
        // テーブルを生成
        renderCurrencyTable(symbol, data.states, dashboardDiv);
      });
      
      // テーブル再描画後に設定を再適用
      try {
        const sz = localStorage.getItem('tv_font_size') || document.getElementById('fontSizeSelect')?.value || '14';
        applyFontSize(sz);
        applyColumnVisibility();
        applyRowVisibility();
      } catch (e) { /* ignore */ }
      
      // 高さ同期を実行
      setTimeout(syncAllFireHistoryHeights, 100);
    } else {
      document.getElementById('dashboards-container').innerHTML = '<div class="loading">データなし</div>';
    }
  } catch (e) {
    document.getElementById('dashboards-container').innerHTML = '<div class="loading">エラー: ' + e.message + '</div>';
  }
}

// 通貨ごとのテーブルを生成する関数
function renderCurrencyTable(symbol, allStates, container) {
  const state5m = allStates.find(x => x.symbol === symbol && x.tf === '5');
  const state15m = allStates.find(x => x.symbol === symbol && x.tf === '15');
  const state1h = allStates.find(x => x.symbol === symbol && x.tf === '60');
  const state4h = allStates.find(x => x.symbol === symbol && x.tf === '240');
  
  if (!state5m) {
    container.innerHTML = '<div class="loading">5mデータがありません</div>';
    return;
  }
  
  // 更新時刻を計算（JST）
  const updateTime = state5m.timestamp ? new Date(state5m.timestamp).toLocaleString('ja-JP', {timeZone: 'Asia/Tokyo', hour12: false}).split(' ')[1] : 'N/A';
  
  // 5m のクラウド配列をベースに統合
  const mergedClouds = (state5m.clouds || []).map(cloud => {
    const merged = {...cloud};
    
    if (cloud.label === '15m' && state15m) {
      merged.dauten = state15m.clouds?.[0]?.dauten || cloud.dauten;
      merged.bos_count = state15m.daytrade?.bos || cloud.bos_count;
      merged.dauten_start_time_str = state15m.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
      merged.elapsed_str = state15m.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
    } else if (cloud.label === '1H' && state1h) {
      merged.dauten = state1h.clouds?.[0]?.dauten || cloud.dauten;
      merged.bos_count = state1h.daytrade?.bos || cloud.bos_count;
      merged.dauten_start_time_str = state1h.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
      merged.elapsed_str = state1h.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
    } else if (cloud.label === '4H' && state4h) {
      merged.dauten = state4h.clouds?.[0]?.dauten || cloud.dauten;
      merged.bos_count = state4h.daytrade?.bos || cloud.bos_count;
      merged.dauten_start_time_str = state4h.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
      merged.elapsed_str = state4h.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
    } else if (cloud.label === '5m') {
      merged.bos_count = state5m.daytrade?.bos || cloud.bos_count;
    } else if (cloud.label !== '5m') {
      merged.dauten = '';
      merged.bos_count = null;
      merged.dauten_start_time_str = '';
      merged.elapsed_str = '';
    }
    
    return merged;
  });
  
  // row_order に従って行を並べ替え
  const rowOrder = state5m.row_order || ['5m', '15m', 'price', '1H', '4H'];
  const orderedRows = [];
  
  rowOrder.forEach(label => {
    if (label === 'price') {
      orderedRows.push({ type: 'price', price: state5m.price });
    } else {
      const cloud = mergedClouds.find(c => c.label === label);
      if (cloud) {
        orderedRows.push({ type: 'cloud', ...cloud });
      }
    }
  });
  
  let html = '<div class="table-wrap"><table><tr><th colspan="11" style="text-align: center;">' + state5m.symbol + ' - ' + state5m.price + '<span style="float: right;">更新 ' + updateTime + '</span></th></tr>';
  html += '<tr><th class="header-black">雲整列</th><th class="header-black">ダウ転</th><th class="header-black">突破数</th><th class="header-black">雲交差</th><th class="header-black">各雲間</th><th class="header-black">価格間</th><th class="header-black">雲角度</th><th class="header-black">雲厚み</th><th class="header-black">ダウ時間</th><th class="header-black">交差時間</th><th class="header-black">時間差</th></tr>';

  orderedRows.forEach(row => {
    if (row.type === 'price') {
      html += '<tr class="price-row"><td class="tf-label">価格</td>';
      html += '<td colspan="10"></td></tr>';
    } else {
      const c = row;
      html += '<tr>';
      
      let tfBgColor = '';
      if (c.label === '5m') tfBgColor = '#a9e88c';
      else if (c.label === '15m') tfBgColor = '#fbd0b2';
      else if (c.label === '1H') tfBgColor = '#8dc7fc';
      else if (c.label === '4H') tfBgColor = '#fa8dfe';
      
      if (tfBgColor) {
        html += '<td class="tf-label" style="background:' + tfBgColor + '; color:#000">' + c.label + '</td>';
      } else {
        html += '<td class="tf-label col-cloud-label">' + c.label + '</td>';
      }

      let dautenColor = '';
      if (c.dauten === 'up') dautenColor = '#2962ff';
      else if (c.dauten === 'down') dautenColor = '#f23645';

      let gcColor = '';
      if (c.gc === true) gcColor = '#2962ff';
      else if (c.gc === false) gcColor = '#f23645';

      let bosVal = c.bos_count;

      const toNum = v => (v === null || v === undefined || v === '' ? null : Number(v));
      const prev = toNum(c.distance_from_prev);
      const prevColor = (prev !== null ? (prev > 0 ? '#2962ff' : (prev < 0 ? '#f23645' : '')) : '');
      const dp = toNum(c.distance_from_price);
      const dpColor = (dp !== null ? (dp > 0 ? '#2962ff' : (dp < 0 ? '#f23645' : '')) : '');
      const ang = toNum(c.angle);
      const angColor = (ang !== null ? (ang > 0 ? '#2962ff' : (ang < 0 ? '#f23645' : '')) : '');
      const th = toNum(c.thickness);
      const thColor = (th !== null ? (th > 0 ? '#2962ff' : (th < 0 ? '#f23645' : '')) : '');

      if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';
      else html += '<td>' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';

      const displayBos = (bosVal === null || bosVal === undefined || bosVal === '' ? '-' : bosVal);
      if (dautenColor) {
        html += '<td style="background:' + dautenColor + '; color:#fff">' + displayBos + '</td>';
      } else {
        html += '<td>' + displayBos + '</td>';
      }

      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (c.gc ? '▲GC' : '▼DC') + '</td>';
      else html += '<td>' + (c.gc ? '▲GC' : '▼DC') + '</td>';

      if (prevColor) html += '<td style="background:' + prevColor + '; color:#fff">' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';

      if (dpColor) html += '<td style="background:' + dpColor + '; color:#fff">' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';

      if (angColor) html += '<td style="background:' + angColor + '; color:#fff">' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';
      else html += '<td>' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';

      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (th !== null ? th.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (th !== null ? th.toFixed(1) : '-') + '</td>';

      const timeFormat = localStorage.getItem('tv_time_format') || 'datetime';
      
      const dautenTimeFormatted = formatElapsedTime(c.dauten_start_time_str || '-', timeFormat);
      if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + dautenTimeFormatted + '</td>';
      else html += '<td>' + dautenTimeFormatted + '</td>';

      const elapsedTimeFormatted = formatElapsedTime(c.elapsed_str || '-', timeFormat);
      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + elapsedTimeFormatted + '</td>';
      else html += '<td>' + elapsedTimeFormatted + '</td>';

      const timeDiffResult = calculateTransferTimeDiff(c);
      const timeDiffFormatted = formatTimeDiff(timeDiffResult.diff, timeFormat);
      let timeDiffBg = '';
      let timeDiffColor = '#fff';
      if (timeDiffResult.sameDirection) {
        timeDiffBg = dautenColor || '';
      } else {
        timeDiffBg = 'rgba(128,128,128,0.5)';
      }
      if (timeDiffBg) {
        html += '<td style="background:' + timeDiffBg + '; color:' + timeDiffColor + '">' + timeDiffFormatted + '</td></tr>';
      } else {
        html += '<td style="color:' + timeDiffColor + '">' + timeDiffFormatted + '</td></tr>';
      }
    }
  });

  html += '</table></div>';
  container.innerHTML = html;
}

// 初期読み込みと定期的な更新
let updateTimer = null;

function computeNextUpdateTimeout(delaySeconds) {
  const now = new Date();
  const next = new Date(now);
  
  // Reset seconds and milliseconds first
  next.setSeconds(0, 0);

  // Align minutes to the next 5-minute boundary
  const minute = next.getMinutes();
  const remainder = minute % 5;
  if (remainder !== 0) {
    next.setMinutes(minute + (5 - remainder));
  } else {
    // If already on a 5-minute boundary, move to the next one
    next.setMinutes(minute + 5);
  }

  // Add delay seconds to the 5-minute boundary
  next.setSeconds(delaySeconds);

  // If the calculated time is in the past, move to the next 5-minute boundary
  if (next <= now) {
    next.setMinutes(next.getMinutes() + 5);
  }

  return { timeout: next.getTime() - now.getTime(), target: next };
}

async function executeScheduledUpdate() {
  console.log(`[TIMER] Executing scheduled update at ${new Date().toLocaleString('ja-JP', { hour12: false })}`);
  try {
    await load();
    console.log(`[TIMER] Update completed successfully`);
  } catch (error) {
    console.error(`[TIMER] Update failed:`, error);
  }
}

function scheduleNextUpdate() {
  if (updateTimer) {
    clearTimeout(updateTimer);
    updateTimer = null;
  }

  const delay = parseInt(localStorage.getItem('tv_update_delay') || '10', 10);
  const { timeout, target } = computeNextUpdateTimeout(delay);

  const secondsUntil = Math.round(timeout / 1000);
  const targetStr = target.toLocaleString('ja-JP', { hour12: false });
  console.log(`[TIMER] Next update scheduled at ${targetStr} (in ${secondsUntil}s)`);

  updateTimer = setTimeout(async () => {
    await executeScheduledUpdate();
    scheduleNextUpdate(); // Reschedule after execution
  }, timeout);
}

document.addEventListener('DOMContentLoaded', async () => {
  await load();
  scheduleNextUpdate();
});


// --- Rules UI / API ---
async function loadRules() {
  try {
    const r = await fetch('/rules');
    if (!r.ok) return;
    const data = await r.json();
    if (data.status !== 'success') return;
    renderRulesList(data.rules || []);
    // populate scope select with available symbols (currencies)
    const scopeSelect = document.getElementById('ruleScope');
    const avail = [...new Set((data.rules || []).map(x => x.scope && x.scope.symbol).filter(Boolean))];
    // keep existing options but add any new
    avail.forEach(s => {
      if (![...scopeSelect.options].some(o => o.value === s)) {
        const opt = document.createElement('option'); opt.value = s; opt.textContent = s; scopeSelect.appendChild(opt);
      }
    });
  } catch (e) { console.log('loadRules error', e); }
}

function renderRulesList(rules) {
  // Sort rules: enabled first (by updated_at desc), then disabled (by updated_at desc)
  const sortedRules = rules.sort((a, b) => {
    const aEnabled = a.enabled !== false;
    const bEnabled = b.enabled !== false;
    if (aEnabled !== bEnabled) {
      return bEnabled - aEnabled; // enabled (true=1) comes before disabled (false=0)
    }
    // Same enabled status: sort by updated_at descending (most recent first)
    const aTime = a.updated_at || a.created_at || '';
    const bTime = b.updated_at || b.created_at || '';
    return bTime.localeCompare(aTime);
  });
  
  const ul = document.getElementById('rulesList'); ul.innerHTML = '';
  sortedRules.forEach(rule => {
    const li = document.createElement('li'); li.style.padding = '6px 4px'; li.style.borderBottom = '1px solid rgba(255,255,255,0.04)';
    li.style.display = 'flex'; li.style.alignItems = 'center'; li.style.justifyContent = 'space-between';
    
    const left = document.createElement('div'); left.style.display = 'flex'; left.style.alignItems = 'center'; left.style.gap = '8px';
    const btns = document.createElement('div'); btns.style.display = 'flex'; btns.style.gap = '6px';
    
    // 有効/無効トグルボタン
    const toggle = document.createElement('button');
    const isEnabled = rule.enabled !== false; // デフォルトは有効
    toggle.textContent = isEnabled ? '有効' : '無効';
    toggle.style.padding = '4px 8px';
    toggle.style.fontWeight = '600';
    toggle.style.background = isEnabled ? 'rgba(46, 160, 67, 0.2)' : 'rgba(176, 42, 42, 0.2)';
    toggle.style.color = isEnabled ? '#4ade80' : '#f87171';
    toggle.style.border = isEnabled ? '1px solid #4ade80' : '1px solid #f87171';
    toggle.style.borderRadius = '4px';
    toggle.style.cursor = 'pointer';
    toggle.addEventListener('click', async () => {
      try {
        const newEnabled = !isEnabled;
        const updatedRule = { ...rule, enabled: newEnabled };
        const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(updatedRule) });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('更新に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('toggle error', e); alert('トグルエラー: ' + e.message); }
    });
    
    const edit = document.createElement('button'); edit.textContent = '編集'; edit.style.padding = '4px 8px';
    const del = document.createElement('button'); del.textContent = '削除'; del.style.padding = '4px 8px';
    edit.addEventListener('click', () => openRuleEditor(rule));
    del.addEventListener('click', async () => {
      if (!confirm('ルールを削除しますか?')) return;
      try {
        const res = await fetch('/rules/' + encodeURIComponent(rule.id), { method: 'DELETE' });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('削除に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('delete error', e); alert('削除エラー: ' + e.message); }
    });
    
    btns.appendChild(toggle); btns.appendChild(edit); btns.appendChild(del);
    // According to request, place buttons first then rule name to the right
    const title = document.createElement('div'); 
    title.textContent = rule.name || rule.id; 
    title.style.fontWeight = '600'; 
    title.style.marginLeft = '12px';
    title.style.opacity = isEnabled ? '1' : '0.5'; // 無効な場合は薄く表示
    btns.style.opacity = isEnabled ? '1' : '0.5'; // ボタンも薄く表示
    left.appendChild(btns); left.appendChild(title);
    li.appendChild(left);
    ul.appendChild(li);
  });
}

function openRuleEditor(rule) {
  // populate editor fields
  console.log('[DEBUG] Editing rule:', JSON.stringify(rule, null, 2));
  document.getElementById('ruleName').value = rule.name || '';
  const scopeSel = document.getElementById('ruleScope');
  if (rule.scope && rule.scope.symbol) { scopeSel.value = rule.scope.symbol; }
  else { scopeSel.value = ''; }
  // clear conditions
  const condCont = document.getElementById('conditionsContainer'); condCont.innerHTML = '';
  const conds = (rule.rule && rule.rule.conditions) || [];
  if (conds.length === 0) addConditionRow();
  conds.forEach(c => {
    const row = createConditionRow(c);
    condCont.appendChild(row);
  });
    // populate alignment UI if present
  try {
    const align = rule.rule && rule.rule.alignment;
    if (align) {
      // clear all
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      (align.tfs || []).forEach(tf => {
        const el = document.querySelector('.align-tf[data-tf="' + tf + '"]');
        if(el) el.checked = true;
      });
      if (align.missing) document.getElementById('alignMissing').value = align.missing;
    } else {
      // reset to defaults
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      document.getElementById('alignMissing').value = 'ignore';
    }
  } catch(e) { /* ignore */ }
  
  // populate voice settings
  const voice = rule.rule && rule.rule.voice;
  const isDirectionBased = voice && (voice.message_up !== undefined || voice.message_down !== undefined);
  document.getElementById('voiceDirectionBased').checked = isDirectionBased;
  document.getElementById('directionMessages').style.display = isDirectionBased ? 'flex' : 'none';
  document.getElementById('voiceMessagePosition').value = (voice && voice.message_position) || 'suffix';
  
  // Always populate common message if present
  document.getElementById('voiceMessage').value = (voice && voice.message) || '';
  
  // Populate direction-based messages if present
  if (isDirectionBased) {
    document.getElementById('voiceMessageUp').value = (voice && voice.message_up) || '';
    document.getElementById('voiceMessageDown').value = (voice && voice.message_down) || '';
  } else {
    document.getElementById('voiceMessageUp').value = '';
    document.getElementById('voiceMessageDown').value = '';
  }
  
  document.getElementById('voiceSelect').value = (voice && voice.voice_name) || '';
  
  // Populate chime settings
  document.getElementById('playChimeFirst').checked = !!(voice && voice.chime_file);
  document.getElementById('chimeSelect').value = (voice && voice.chime_file) || '';
  
  // Populate symbol insert setting
  document.getElementById('insertSymbol').checked = !!(voice && voice.insert_symbol);
  document.getElementById('symbolInsertPosition').value = (voice && voice.symbol_insert_position) || 'prefix';
  
  // store editing id on save button
  document.getElementById('saveRuleBtn').dataset.editing = rule.id;
}

// --- 雲整列: helper ---
function getAlignmentSettingsFromUI(){
  const tfs = Array.from(document.querySelectorAll('.align-tf')).filter(cb=>cb.checked).map(cb=>cb.dataset.tf);
  const missing = document.getElementById('alignMissing').value; // 'ignore' or 'fail'
  return { tfs, missing };
}

function validateAlignmentForSave(){
  const s = getAlignmentSettingsFromUI();
  const errEl = document.getElementById('alignError'); errEl.style.display = 'none'; errEl.textContent = '';
  if(s.tfs.length === 0){
    // No TFs selected, that's fine - alignment is optional
    return {ok:true, msg:'no_alignment_selected'};
  }
  if(s.tfs.length === 1){
    errEl.style.display='block'; errEl.textContent='エラー: 判定対象の時間は 2 個以上選択してください';
    return {ok:false, msg:'need_2_tfs'};
  }
  return {ok:true, msg:'ok'};
}

// wire align checkbox changes to keep UI consistent
document.addEventListener('DOMContentLoaded', ()=>{
  document.querySelectorAll('.align-tf').forEach(cb=> cb.addEventListener('change', ()=>{ /* no-op for now; validation on save/test */ }));
  document.getElementById('alignAllTf').addEventListener('change', (e) => {
    const checked = e.target.checked;
    document.querySelectorAll('.align-tf').forEach(cb => cb.checked = checked);
  });
});

function createConditionRow(c) {
  const div = document.createElement('div'); div.className = 'cond-row'; div.style.display='flex'; div.style.gap='6px'; div.style.alignItems='center';
  const tf = document.createElement('select'); tf.className='cond-tf'; tf.style.padding='6px'; tf.style.borderRadius='6px'; tf.style.background='rgba(15,27,65,0.7)'; tf.style.color='inherit'; tf.style.border='1px solid rgba(255,255,255,0.12)'; tf.innerHTML = '<option value="5m">5m</option><option value="15m">15m</option><option value="1H">1H</option><option value="4H">4H</option>';
  const field = document.createElement('select'); field.className='cond-field'; field.style.padding='6px'; field.style.borderRadius='6px'; field.style.background='rgba(15,27,65,0.7)'; field.style.color='inherit'; field.style.border='1px solid rgba(255,255,255,0.12)'; field.innerHTML = '<option value="dauten">ダウ転</option><option value="bos_count">突破数</option><option value="gc">雲交差</option><option value="distance_from_prev">各雲間</option><option value="distance_from_price">価格間</option><option value="angle">雲角度</option><option value="thickness">雲厚み</option><option value="transfer_time_diff">転換時間差</option>';
  const op = document.createElement('select'); op.className='cond-op'; op.style.padding='6px'; op.style.borderRadius='6px'; op.style.background='rgba(15,27,65,0.7)'; op.style.color='inherit'; op.style.border='1px solid rgba(255,255,255,0.12)'; op.innerHTML = '<option value==>==</option><option value=">=">&gt;=</option><option value=">">&gt;</option><option value="<=">&lt;=</option><option value="<">&lt;</option>';
  const val = document.createElement('input'); val.className='cond-value'; val.placeholder='値'; val.style.padding='6px'; val.style.borderRadius='6px'; val.style.border='1px solid rgba(255,255,255,0.08)'; val.style.background='transparent'; val.style.color='inherit'; val.style.width='120px';
  const rem = document.createElement('button'); rem.className='removeCond'; rem.textContent='削除'; rem.style.padding='6px 12px';
  rem.addEventListener('click', () => div.remove());
  div.append(tf, field, op, val, rem);

  // hide/remove op/val when field is one of the toggle-only/time/numeric-threshold types
  function updateCondVisibility() {
    try {
      const hideBoth = ['dauten','bos_count','gc','dauten_start_time_str','cross_start_time'];
      const hideOpOnly = ['distance_from_prev','distance_from_price','angle','thickness','transfer_time_diff'];
      
      if (hideBoth.includes(field.value)) {
        // remove both op and val from DOM
        if (op.parentNode === div) div.removeChild(op);
        if (val.parentNode === div) div.removeChild(val);
      } else if (hideOpOnly.includes(field.value)) {
        // remove only op, keep val for numeric input
        if (op.parentNode === div) div.removeChild(op);
        if (val.parentNode !== div) div.insertBefore(val, rem);
        val.style.display = '';
        val.placeholder = '閾値';
      } else {
        // ensure both op and val are present before the remove button
        if (op.parentNode !== div) div.insertBefore(op, rem);
        if (val.parentNode !== div) div.insertBefore(val, rem);
        op.style.display = '';
        val.style.display = '';
        val.placeholder = '値';
      }
    } catch (e) { /* ignore */ }
  }

  field.addEventListener('change', updateCondVisibility);
  // Set values from loaded rule BEFORE calling initial visibility update
  if (c) {
    tf.value = c.label || tf.value;
    field.value = c.field || field.value;
    op.value = c.op || op.value;
    val.value = c.value || '';
  }
  // initial visibility (AFTER setting field value so it checks the correct field type)
  updateCondVisibility();
  return div;
}

function addConditionRow() {
  const cont = document.getElementById('conditionsContainer');
  const r = createConditionRow(); cont.appendChild(r);
}

document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('newRuleBtn')?.addEventListener('click', () => {
    document.getElementById('ruleName').value = '';
    document.getElementById('conditionsContainer').innerHTML = '';
    addConditionRow();
    document.getElementById('saveRuleBtn').dataset.editing = '';
    
    // clear voice settings
    document.getElementById('voiceMessage').value = '';
    document.getElementById('voiceMessageUp').value = '';
    document.getElementById('voiceMessageDown').value = '';
    document.getElementById('voiceDirectionBased').checked = false;
    document.getElementById('directionMessages').style.display = 'none';
    document.getElementById('voiceMessagePosition').value = 'suffix';
    document.getElementById('voiceSelect').value = '';
    document.getElementById('playChimeFirst').checked = false;
    document.getElementById('chimeSelect').value = '';
  });
  // Wire '条件を追加' button to append a new condition row
  document.getElementById('addCondBtn')?.addEventListener('click', addConditionRow);
  
  // Wire voice direction based checkbox
  document.getElementById('voiceDirectionBased')?.addEventListener('change', e => {
    const directionDiv = document.getElementById('directionMessages');
    directionDiv.style.display = e.target.checked ? 'flex' : 'none';
  });
  
  // Wire tooltip for alignMissing
  document.getElementById('alignMissingTooltip')?.addEventListener('click', () => {
    alert(`・無視\n欠損した TF を判定から除外し、残りの TF で整列条件を評価します。データが一部欠けていても、条件を満たせば整列成立とみなします。\n例1: 5m、15m、1H、4H全てチェック、15m欠損の場合、15mを除外して5m、1H、4Hの順序が雲の順番と一致すれば成立。\n例2: 5m、15m、1H、4H全てチェック、雲が5m、15m、4H、1H、4H欠損の場合、4Hを除外して5m、15m、1Hの順序が一致して発火。\n\n・不一致\n欠損した TF があれば、即座に整列条件を不成立と判定します。データが完全でないと条件を満たさない厳格な扱いになります。\n例: 5m、15m、1H、4H全てチェック、15m欠損の場合、欠損があるため不成立。`);
  });
  
  // Wire test voice button
  document.getElementById('testVoiceBtn')?.addEventListener('click', () => {
    const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
    const voiceName = document.getElementById('voiceSelect').value;
    const messagePosition = document.getElementById('voiceMessagePosition').value;
    const playChime = document.getElementById('playChimeFirst').checked;
    const chimeFile = document.getElementById('chimeSelect').value;
    const insertSymbol = document.getElementById('insertSymbol').checked;
    const ruleScope = document.getElementById('ruleScope').value;
    
    let testMessage = '';
    if (isDirectionBased) {
      const messageUp = document.getElementById('voiceMessageUp').value.trim();
      const messageDown = document.getElementById('voiceMessageDown').value.trim();
      const directionMessage = messageUp || 'テストメッセージ（上昇）';
      const baseMessage = document.getElementById('voiceMessage').value.trim() || 'ルールが発火しました';
      
      if (messagePosition === 'prefix') {
        testMessage = directionMessage + ' ' + baseMessage;
      } else if (messagePosition === 'suffix') {
        testMessage = baseMessage + ' ' + directionMessage;
      } else if (messagePosition === 'both') {
        testMessage = directionMessage + ' ' + baseMessage + ' ' + directionMessage;
      }
    } else {
      testMessage = document.getElementById('voiceMessage').value.trim() || 'テストメッセージ';
    }
    
    // 通貨名挿入処理
    if (insertSymbol && ruleScope) {
      const japaneseName = currencyNames[ruleScope] || ruleScope;
      const symbolInsertPosition = document.getElementById('symbolInsertPosition').value;
      if (testMessage.includes('{symbol}')) {
        testMessage = testMessage.replace('{symbol}', japaneseName);
      } else {
        if (symbolInsertPosition === 'prefix') {
          testMessage = japaneseName + ' ' + testMessage;
        } else if (symbolInsertPosition === 'suffix') {
          testMessage = testMessage + ' ' + japaneseName;
        } else if (symbolInsertPosition === 'both') {
          testMessage = japaneseName + ' ' + testMessage + ' ' + japaneseName;
        }
      }
    }
    
    const voiceSettings = {};
    if (voiceName) voiceSettings.voice_name = voiceName;
    if (playChime && chimeFile) voiceSettings.chime_file = chimeFile;
    if (insertSymbol && ruleScope) {
      voiceSettings.insert_symbol = true;
      voiceSettings.symbol_insert_position = document.getElementById('symbolInsertPosition').value;
    }
    const rateSuffix = testMessage ? '' : '。音速は' + document.getElementById('voiceRate').value + '倍です。';
    playVoiceAlert(testMessage + rateSuffix, voiceSettings, ruleScope || 'USDJPY');
  });
  
  // Populate voice select with available voices
  function populateVoiceSelect() {
    if (!('speechSynthesis' in window)) return;
    
    const select = document.getElementById('voiceSelect');
    const currentValue = select.value;
    
    select.innerHTML = '';
    
    const voices = speechSynthesis.getVoices();
    const allowedVoices = {
      'Microsoft 七海 Online (Natural) - Japanese (Japan)': '七海［女性］',
      'Microsoft 圭太 Online (Natural) - Japanese (Japan)': '圭太［男性］',
      'Microsoft 碧衣 Online (Natural) - Japanese (Japan)': '碧衣［女性］',
      'Microsoft 大智 Online (Natural) - Japanese (Japan)': '大智［男性］',
      'Microsoft 真夕 Online (Natural) - Japanese (Japan)': '真夕［女性］',
      'Microsoft 直紀 Online (Natural) - Japanese (Japan)': '直紀［男性］',
      'Microsoft 志織 Online (Natural) - Japanese (Japan)': '志織［女性］'
    };
    
    voices.forEach(voice => {
      if (voice.lang.startsWith('ja') && allowedVoices[voice.name]) {
        const option = document.createElement('option');
        option.value = voice.name;
        option.textContent = allowedVoices[voice.name];
        select.appendChild(option);
      }
    });
    
    // Restore previous selection if it still exists
    if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
      select.value = currentValue;
    }
  }
  
  // Populate chime select with available chime files
  async function populateChimeSelect() {
    const select = document.getElementById('chimeSelect');
    const currentValue = select.value;
    
    select.innerHTML = '<option value="">なし</option>';
    
    try {
      const response = await fetch('/api/chime_files');
      const data = await response.json();
      if (data.status === 'success') {
        data.files.forEach(file => {
          const option = document.createElement('option');
          option.value = file;
          option.textContent = file.replace('.mp3', '');
          select.appendChild(option);
        });
      }
    } catch (e) {
      console.log('Error fetching chime files:', e);
      // Fallback to static list
      const chimeFiles = [
        'お寺の鐘.mp3',
        'きらきら輝く6.mp3',
        'ほら貝を吹き鳴らす.mp3',
        'ドンドンパフパフ.mp3',
        'ラッパのファンファーレ.mp3',
        'レベルアップ.mp3',
        '放送開始チャイム.mp3',
        '教会の鐘2.mp3',
        '歓声と拍手.mp3',
        '決定ボタンを押す4.mp3',
        '決定ボタンを押す5.mp3',
        '男衆「イエーイ！」.mp3',
        '男衆「イヤッホー！」.mp3',
        '突撃ラッパ.mp3',
        '警報が鳴る.mp3',
        '開演ブザー.mp3'
      ];
      chimeFiles.forEach(file => {
        const option = document.createElement('option');
        option.value = file;
        option.textContent = file.replace('.mp3', '');
        select.appendChild(option);
      });
    }
    
    // Restore previous selection if it still exists
    if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
      select.value = currentValue;
    }
  }
  
  // Populate voices when available
  if (speechSynthesis.onvoiceschanged !== undefined) {
    speechSynthesis.onvoiceschanged = populateVoiceSelect;
  }
  populateVoiceSelect();
  populateChimeSelect();
  
  document.getElementById('saveRuleBtn')?.addEventListener('click', async () => {
    // validate alignment first
    const alignValid = validateAlignmentForSave();
    if(!alignValid.ok){ return; }

    const name = document.getElementById('ruleName').value || ('rule-' + Date.now());
    const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
    const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
    const conditions = condRows.map(r => {
      const tf = r.querySelector('.cond-tf').value;
      const fld = r.querySelector('.cond-field').value;
      const opEl = r.querySelector('.cond-op');
      const valEl = r.querySelector('.cond-value');
      const opVal = opEl ? opEl.value : null;
      const valVal = valEl ? valEl.value : null;
      return { label: tf, field: fld, op: opVal, value: valVal };
    });
  const alignment = getAlignmentSettingsFromUI();
  const ruleObj = { conditions: conditions };
  // include alignment only if TFs selected
  if(alignment.tfs && alignment.tfs.length > 0){ ruleObj.alignment = alignment; }
  
  // include voice settings
  const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
  const voiceName = document.getElementById('voiceSelect').value;
  const messagePosition = document.getElementById('voiceMessagePosition').value;
  const commonMessage = document.getElementById('voiceMessage').value.trim();
  const messageUp = document.getElementById('voiceMessageUp').value.trim();
  const messageDown = document.getElementById('voiceMessageDown').value.trim();
  const playChime = document.getElementById('playChimeFirst').checked;
  const chimeFile = document.getElementById('chimeSelect').value;
  
  console.log('[DEBUG] Voice settings - isDirectionBased:', isDirectionBased, 'voiceName:', voiceName, 'messagePosition:', messagePosition);
  console.log('[DEBUG] Messages - common:', commonMessage, 'up:', messageUp, 'down:', messageDown);
  console.log('[DEBUG] Chime - playChime:', playChime, 'chimeFile:', chimeFile);
  
  // Check if any voice setting exists
  if (commonMessage || messageUp || messageDown || voiceName || (playChime && chimeFile)) {
    ruleObj.voice = {};
    
    // Always save common message if present
    if (commonMessage) {
      ruleObj.voice.message = commonMessage;
    }
    
    // Save direction-based messages if direction-based mode is enabled
    if (isDirectionBased) {
      ruleObj.voice.message_up = messageUp;
      ruleObj.voice.message_down = messageDown;
      ruleObj.voice.message_position = messagePosition;
    }
    
    // Always save voice name if selected
    if (voiceName) {
      ruleObj.voice.voice_name = voiceName;
    }
    
    // Save chime settings
    if (playChime && chimeFile) {
      ruleObj.voice.chime_file = chimeFile;
    }
    
    // Save symbol insert setting
    if (document.getElementById('insertSymbol').checked) {
      ruleObj.voice.insert_symbol = true;
      ruleObj.voice.symbol_insert_position = document.getElementById('symbolInsertPosition').value;
    } else {
      delete ruleObj.voice.insert_symbol;
      delete ruleObj.voice.symbol_insert_position;
    }
  }
  
  console.log('[DEBUG] ruleObj after voice settings:', JSON.stringify(ruleObj, null, 2));
  
    const payload = { id: document.getElementById('saveRuleBtn').dataset.editing || name, name: name, enabled: true, scope: scope, rule: ruleObj };
    console.log('[DEBUG] Saving payload:', JSON.stringify(payload, null, 2));
    try {
      const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
      const j = await res.json();
      if (j.status === 'success') { 
        alert('ルールを保存しました'); 
        // ルール一覧を再度読み込んで、最新のデータを取得
        await loadRules();
        // 保存したルールを再度開いて、UIを最新の状態に更新
        try {
          const rulesRes = await fetch('/rules');
          const rulesData = await rulesRes.json();
          if (rulesData.status === 'success') {
            const savedRule = rulesData.rules.find(r => r.id === payload.id);
            if (savedRule) {
              console.log('[DEBUG] Reloading saved rule for display:', JSON.stringify(savedRule, null, 2));
              openRuleEditor(savedRule);
            }
          }
        } catch (e) {
          console.log('Error reloading rule after save:', e);
        }
      }
      else { alert('保存失敗: ' + (j.msg || JSON.stringify(j))); }
    } catch (e) { console.log('save error', e); alert('保存時エラー: ' + e.message); }
  });

  document.getElementById('testRuleBtn')?.addEventListener('click', async () => {
    const panel = document.getElementById('ruleTestResult');
    const badge = document.getElementById('testBadge');
    const short = document.getElementById('testShort');
    const detailsEl = document.getElementById('testDetails');

    badge.style.background = '#777'; badge.textContent = '実行中...';
    short.textContent = '';
    detailsEl.innerHTML = '';

    // build payload
    const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
    const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
    const conditions = condRows.map(r => {
      const tf = r.querySelector('.cond-tf').value;
      const fld = r.querySelector('.cond-field').value;
      const opEl = r.querySelector('.cond-op');
      const valEl = r.querySelector('.cond-value');
      const opVal = opEl ? opEl.value : null;
      const valVal = valEl ? (valEl.value || null) : null;
      return { label: tf, field: fld, op: opVal, value: valVal };
    });
  const payload = { rule: { logic: 'AND', conditions: conditions }, scope: scope };
  const alignment = getAlignmentSettingsFromUI();
  if(alignment.tfs && alignment.tfs.length > 0){ payload.rule.alignment = alignment; }

    // alignment validation - we show a non-blocking warning
    const alignValid = validateAlignmentForSave();
    if(!alignValid.ok){ short.textContent = '注意: ' + alignValid.msg; }

    // テスト時に現在のダッシュボードデータを state_override として送信
    // 5m JSONには全TFの雲位置データが含まれているため、5mを優先的に使用
    if (currentDashboardData && currentDashboardData.length > 0) {
      let selectedState = null;
      const ruleSymbol = scope.symbol;
      
      if (ruleSymbol) {
        // ルールが特定の通貨に限定されている場合、その通貨の5mデータを使用
        selectedState = currentDashboardData.find(s => s.symbol === ruleSymbol && (s.tf === '5' || s.tf === '5m'));
        
        // 5mが見つからなければ、その通貨の任意のデータを使用
        if (!selectedState) {
          selectedState = currentDashboardData.find(s => s.symbol === ruleSymbol);
        }
      } else {
        // 通貨指定なしの場合、最初の5mデータを使用
        selectedState = currentDashboardData.find(s => s.tf === '5' || s.tf === '5m');
        
        // 5mが見つからなければ最初のデータを使用
        if (!selectedState) {
          selectedState = currentDashboardData[0];
        }
      }
      
      if (selectedState) {
        payload.state_override = selectedState;
      }
    }

    try {
      const res = await fetch('/rules/test', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
      const j = await res.json();
      if (j.status === 'success') {
        const matched = !!j.matched;
  // badge — show compact OK/NG
  if (matched) { badge.style.background = '#2d8a3d'; badge.textContent = 'OK'; }
  else { badge.style.background = '#b02a2a'; badge.textContent = 'NG'; }

        // short summary
        const condCount = Array.isArray(payload.rule.conditions) ? payload.rule.conditions.length : 0;
        const passCount = Array.isArray(j.details) ? j.details.filter(d => d.result).length : (matched ? condCount : 0);
  short.textContent = `判定: ${matched ? 'OK' : 'NG'} — 条件合致 ${passCount}/${condCount}${payload.rule.alignment ? ' / 雲整列を含む' : ''}`;

        // human-readable details
        if (Array.isArray(j.details) && j.details.length > 0) {
          const ul = document.createElement('ul');
          ul.style.margin = '6px 0 0 14px'; ul.style.padding = '0'; ul.style.listStyle = 'disc';
          j.details.forEach(d => {
            const li = document.createElement('li');
            try {
              const rawName = d.cond || (d.label ? `${d.label}.${d.field}` : JSON.stringify(d));
              // field -> Japanese name map
              const fieldMap = {
                'alignment':'雲整列', '雲整列':'雲整列',
                'dauten':'ダウ転換', 'gc':'雲交差', 'bos_count':'突破数', 'daytrade_bos':'突破数',
                'distance_from_prev':'各雲間', 'distance_from_price':'価格間',
                'angle':'雲角度', 'thickness':'雲厚み', 'transfer_time_diff':'転換時間差',
                'presence_check':'存在確認', 'direction_consistency':'方向一貫性'
              };

              // derive display name - extract field part after dot if present
              let name = rawName;
              const key = d.field || d.cond || rawName;
              
              // if cond contains a dot (e.g., "5m.dauten"), extract the field part
              if (typeof rawName === 'string' && rawName.includes('.')) {
                const parts = rawName.split('.');
                const tfPart = parts[0];  // e.g., "5m"
                const fieldPart = parts[1]; // e.g., "dauten"
                const mappedField = fieldMap[fieldPart] || fieldPart;
                name = `${tfPart}.${mappedField}`;
              } else if (fieldMap[key]) {
                name = fieldMap[key];
              }

              // OK/NG
              const ok = d.result ? 'OK' : 'NG';

              // helper to format actual values (handle undefined/null)
              const formatActual = (val, fld) => {
                if (val === undefined || val === null || val === '-') return '未測定';
                // normalize some known display values
                if (fld && fld.includes('dauten')) {
                  if (val === 'up' || val === '上' || val === 'upward' || val === '▲' || val === '上昇') return '上昇';
                  if (val === 'down' || val === '下' || val === 'downward' || val === '▼' || val === '下降') return '下降';
                  return String(val);
                }
                if (fld && fld.includes('gc')) {
                  if (String(val).toUpperCase() === 'GC') return 'GC';
                  if (String(val).toUpperCase() === 'DC') return 'DC';
                  return String(val);
                }
                return (typeof val === 'number') ? (Number(val).toFixed(2).replace(/\.00$/,'')) : String(val);
              };

              // build message by condition type / available fields
              let msg = '';

              // known reason translations
              const reasonMap = {
                'presence_check':'存在確認', 'missing_field':'データ欠損', 'invalid_threshold':'無効な閾値',
                'directions_mismatch':'方向不一致', 'missing_fail':'欠損で不成立', 'effective_lt_n':'有効数が閾値未満',
                'no_threshold_provided':'閾値未設定', 'invalid_direction':'無効な方向指定',
                'no_selection':'TF未選択', 'need_at_least_2':'最低2つのTFが必要',
                'too_few_effective_tfs':'有効TFが2つ未満', 'order_mismatch':'順序不一致', 'no_row_order':'雲順序データなし'
              };
              if (d.reason) {
                const reasonText = reasonMap[d.reason] || d.reason;
                // if directions array is present (for direction_consistency), show them
                if (d.directions && Array.isArray(d.directions)) {
                  msg = `（${reasonText}：${d.directions.join('、')}）`;
                } else if (d.dauten_dir !== undefined || d.cross_dir !== undefined) {
                  // show debug info for invalid_direction errors
                  msg = `（${reasonText}：ダウ方向=${d.dauten_dir || '?'}、交差方向=${d.cross_dir || '?'}）`;
                } else {
                  msg = `（${reasonText}）`;
                }
              } else if (d.match_up !== undefined || d.match_down !== undefined) {
                const up = d.match_up !== undefined ? d.match_up : '-';
                const down = d.match_down !== undefined ? d.match_down : '-';
                msg = `（上昇：${up} ／ 下降：${down}`;
                if (d.threshold !== undefined) msg += `、閾値：${d.threshold}`;
                msg += '）';
              } else if (d.threshold !== undefined || d.value !== undefined) {
                const thr = d.threshold !== undefined ? d.threshold : d.value;
                const fieldKey = d.field || (d.cond ? d.cond.split('.')[1] : '');
                const actual = formatActual(d.actual, fieldKey || d.cond);
                // special-wording for some fields
                if ((fieldKey === 'dauten') || (d.cond && d.cond.indexOf('dauten') !== -1)) {
                  msg = `（期待方向：${thr}、実測：${actual}）`;
                } else if ((fieldKey === 'gc') || (d.cond && d.cond.indexOf('gc') !== -1)) {
                  msg = `（期待：${thr}、実測：${actual}）`;
                } else if ((fieldKey === 'bos_count') || (fieldKey === 'daytrade_bos') || (d.cond && d.cond.indexOf('bos_count') !== -1)) {
                  msg = `（閾値：${thr} 回、実測：${actual}）`;
                } else if ((fieldKey === 'transfer_time_diff') || (d.cond && d.cond.indexOf('transfer_time_diff') !== -1)) {
                  msg = `（閾値：${thr} 分、実測：${actual} 分）`;
                } else if ((fieldKey === 'angle') || (d.cond && d.cond.indexOf('angle') !== -1)) {
                  msg = `（閾値：${thr}°、実測：${actual}°）`;
                } else if ((fieldKey === 'distance_from_prev') || (d.cond && d.cond.indexOf('distance_from_prev') !== -1)) {
                  msg = `（閾値：${thr} pips、実測：${actual} pips）`;
                } else if ((fieldKey === 'distance_from_price') || (d.cond && d.cond.indexOf('distance_from_price') !== -1)) {
                  msg = `（閾値：${thr} pips、実測：${actual} pips）`;
                } else if ((fieldKey === 'thickness') || (d.cond && d.cond.indexOf('thickness') !== -1)) {
                  msg = `（閾値：${thr} pips、実測：${actual} pips）`;
                } else {
                  msg = `（閾値：${thr}、実測：${actual}）`;
                }
              } else if (d.delta_min !== undefined) {
                const actualVal = (d.delta_min === undefined || d.delta_min === null) ? '未測定' : Number(d.delta_min).toFixed(1);
                const thr = d.threshold !== undefined ? d.threshold : (d.value !== undefined ? d.value : '-');
                msg = `（閾値：${thr} 分、実測：${actualVal} 分）`;
              } else if (d.actual !== undefined) {
                const actual = formatActual(d.actual, d.field || d.cond);
                msg = `（実測：${actual}）`;
              } else if (d.found_in) {
                const fi = d.found_in;
                msg = `（取得元：TF=${fi.state_tf || fi.tf || '-'}、雲=${fi.cloud_label || fi.cloud || '-'}）`;
              }

              li.textContent = `${name}：${ok} ${msg}`.trim();
            } catch (e) { li.textContent = JSON.stringify(d); }
            ul.appendChild(li);
          });
          detailsEl.appendChild(ul);
        } else {
          detailsEl.textContent = '詳細情報はありません。';
        }

        // collapsible raw JSON with copy button (visible copy button placed next to the toggle)
        const raw = document.createElement('details');
        raw.style.marginTop = '8px';
        const sum = document.createElement('summary'); sum.textContent = '生データを表示'; raw.appendChild(sum);

        const pre = document.createElement('pre');
        pre.style.maxHeight = '240px'; pre.style.overflow = 'auto'; pre.style.background = 'transparent'; pre.style.color = 'inherit'; pre.style.whiteSpace = 'pre-wrap'; pre.style.userSelect = 'text';
        pre.textContent = JSON.stringify(j, null, 2);
        raw.appendChild(pre);

        // copy area inside details (for expanded view)
        const copyWrap = document.createElement('div');
        copyWrap.style.display = 'flex'; copyWrap.style.gap = '8px'; copyWrap.style.alignItems = 'center'; copyWrap.style.marginTop = '6px';
        const copyBtnInside = document.createElement('button');
        copyBtnInside.textContent = '生データをコピー';
        copyBtnInside.style.padding = '4px 8px'; copyBtnInside.style.fontSize = '0.9em'; copyBtnInside.style.cursor = 'pointer';
        const copyNote = document.createElement('span');
        copyNote.style.opacity = '0.85'; copyNote.style.fontSize = '0.9em'; copyNote.textContent = '';
        copyWrap.appendChild(copyBtnInside);
        copyWrap.appendChild(copyNote);
        raw.appendChild(copyWrap);

        // wrapper to hold details and a visible copy button next to the summary
        const rawWrap = document.createElement('div');
        rawWrap.style.display = 'flex'; rawWrap.style.alignItems = 'center'; rawWrap.style.gap = '8px';
        // visible copy button placed to the right of the summary (works even when details is collapsed)
        const copyBtnVisible = document.createElement('button');
        copyBtnVisible.textContent = '生データをコピー';
        copyBtnVisible.style.padding = '4px 8px'; copyBtnVisible.style.fontSize = '0.9em'; copyBtnVisible.style.cursor = 'pointer';
        rawWrap.appendChild(raw);
        rawWrap.appendChild(copyBtnVisible);
        detailsEl.appendChild(rawWrap);

        // copy handler (shared)
        const doCopy = async () => {
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(pre.textContent);
            } else {
              const range = document.createRange();
              range.selectNodeContents(pre);
              const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);
              document.execCommand('copy');
              sel.removeAllRanges();
            }
            copyNote.textContent = 'コピーしました';
            setTimeout(() => { copyNote.textContent = ''; }, 2000);
          } catch (e) {
            copyNote.textContent = 'コピー失敗';
            setTimeout(() => { copyNote.textContent = ''; }, 2000);
          }
        };
        copyBtnInside.addEventListener('click', doCopy);
        copyBtnVisible.addEventListener('click', doCopy);
      } else {
        badge.style.background = '#aa5500'; badge.textContent = 'エラー';
        short.textContent = 'エラー: ' + (j.msg || JSON.stringify(j));
        detailsEl.textContent = '';
      }
    } catch (e) {
      badge.style.background = '#aa5500'; badge.textContent = '実行エラー';
      short.textContent = e.message;
      detailsEl.textContent = '';
    }
  });

  // initial load of rules
  loadRules();
  
  // Wire test fire button
  document.getElementById('test-fire-btn')?.addEventListener('click', testFire);
  
  // Wire clear fire history button
  document.getElementById('clear-fire-history-btn')?.addEventListener('click', async () => {
    try {
      const res = await fetch('/api/clear_notifications', { method: 'POST' });
      const data = await res.json();
      if (data.status === 'success') {
        // Clear local display
        const listEl = document.getElementById('fire-history-list');
        if (listEl) {
          listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
        }
        console.log('Notifications cleared');
      } else {
        console.log('Clear failed:', data);
        alert('クリアに失敗しました: ' + (data.msg || JSON.stringify(data)));
      }
    } catch (e) {
      console.log('Clear error:', e);
      alert('クリアエラー: ' + e.message);
    }
  });
});

// --- Notifications and Voice Alerts ---
let lastNotificationTimestamp = null;
let notificationCheckInterval = null;
let notificationPollingStarted = false; // Global flag to prevent multiple instances

async function checkNotifications() {
  const timestamp = new Date().toISOString();
  const stackTrace = new Error().stack;
  console.log('[NOTIFICATIONS] checkNotifications called at ' + timestamp);
  console.log('[NOTIFICATIONS] Call stack:', stackTrace);
  
  try {
    const res = await fetch('/api/notifications');
    if (!res.ok) return;
    const data = await res.json();
    if (data.status !== 'success') return;
    
    const notifications = data.notifications || [];
    if (notifications.length === 0) return;
    
    // Update fire history display
    updateFireHistory(notifications);
    
    // Get the latest notification
    const latest = notifications[0];
    const latestTimestamp = latest.timestamp;
    
    // If this is a new notification (different timestamp)
    if (lastNotificationTimestamp !== latestTimestamp) {
      lastNotificationTimestamp = latestTimestamp;
      
      // Play voice alert
      playVoiceAlert(latest.message, null, latest.symbol);
      
      console.log('[NOTIFICATION]', latest);
    }
  } catch (e) {
    console.log('checkNotifications error', e);
  }
}

function updateFireHistory(notifications) {
  if (notifications.length === 0) {
    // すべての通貨の履歴をクリア
    document.querySelectorAll('.fire-history-list').forEach(listEl => {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
    });
    return;
  }
  
  // 通貨ごとに通知を分類
  const notificationsBySymbol = {};
  notifications.forEach(notif => {
    const symbol = notif.symbol || 'UNKNOWN';
    if (!notificationsBySymbol[symbol]) {
      notificationsBySymbol[symbol] = [];
    }
    notificationsBySymbol[symbol].push(notif);
  });
  
  // 各通貨の発火履歴を更新
  document.querySelectorAll('.currency-fire-history-list').forEach(listEl => {
    const symbol = listEl.dataset.symbol;
    const symbolNotifications = notificationsBySymbol[symbol] || [];
    const displayNotifications = symbolNotifications.slice(0, 20);
    
    if (displayNotifications.length === 0) {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
      return;
    }
    
    let html = '';
    displayNotifications.forEach(notif => {
      // Format timestamp: YY/MM/DD HH:mm
      const dt = new Date(notif.timestamp);
      const year = String(dt.getFullYear()).slice(-2);
      const month = String(dt.getMonth() + 1).padStart(2, '0');
      const day = String(dt.getDate()).padStart(2, '0');
      const hour = String(dt.getHours()).padStart(2, '0');
      const minute = String(dt.getMinutes()).padStart(2, '0');
      const timeStr = year + '/' + month + '/' + day + ' ' + hour + ':' + minute;
      
      html += '<div class="fire-item">';
      html += '<span class="fire-time">' + timeStr + '</span>';
      html += '<span class="fire-name">' + (notif.rule_name || '不明') + '</span>';
      html += '</div>';
    });
    
    listEl.innerHTML = html;
  });
  
  // Apply current font size to newly created elements
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  applyFontSize(savedSize);
  
  // Sync fire history heights after content update
  syncAllFireHistoryHeights();
}

// 全通貨の発火履歴ウィンドウの高さを同期する
function syncAllFireHistoryHeights() {
  document.querySelectorAll('.currency-section').forEach(section => {
    const dashboard = section.querySelector('.currency-dashboard');
    const fireHistory = section.querySelector('.currency-fire-history');
    
    if (!dashboard || !fireHistory) return;
    
    // Get the table from dashboard
    const tableWrap = dashboard.querySelector('.table-wrap');
    if (!tableWrap) return;
    
    const table = tableWrap.querySelector('table');
    if (!table) return;
    
    // Use requestAnimationFrame to ensure layout is complete
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        const tableHeight = table.offsetHeight;
        
        // Set fire history height to match table
        fireHistory.style.height = tableHeight + 'px';
        
        // Adjust the list max-height to account for header
        const headerHeight = fireHistory.querySelector('.currency-fire-history-header')?.offsetHeight || 50;
        const padding = 24; // 12px top + 12px bottom
        const availableHeight = tableHeight - padding - headerHeight;
        
        const listEl = fireHistory.querySelector('.currency-fire-history-list');
        if (listEl) {
          listEl.style.maxHeight = Math.max(0, availableHeight) + 'px';
        }
        
        console.log('[SYNC] Table height:', tableHeight, 'Fire history height:', tableHeight);
      });
    });
  });
}

// Keep fire history height synced on viewport changes
window.addEventListener('resize', () => {
  requestAnimationFrame(() => syncAllFireHistoryHeights());
});

// Test fire button handler
async function testFire(symbol = 'USDJPY') {
  try {
    const res = await fetch('/api/test_fire', { 
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ symbol: symbol })
    });
    const data = await res.json();
    
    if (data.status === 'success') {
      console.log('Test fire sent:', data);
      // Refresh notifications immediately
      setTimeout(checkNotifications, 500);
    } else {
      console.log('Test fire failed:', data);
      alert('テスト発火に失敗しました: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (e) {
    console.log('Test fire error:', e);
    alert('テスト発火エラー: ' + e.message);
  }
}

// Clear fire history for a specific currency
async function clearFireHistory(symbol) {
  try {
    // まず即座にUIをクリア
    const listEl = document.querySelector(`.currency-fire-history-list[data-symbol="${symbol}"]`);
    if (listEl) {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
    }
    
    // 次にサーバーにクリアリクエストを送信
    const res = await fetch('/api/clear_notifications', { method: 'POST' });
    const data = await res.json();
    if (data.status === 'success') {
      console.log('Notifications cleared');
    } else {
      console.log('Clear failed:', data);
      alert('クリアに失敗しました: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (e) {
    console.log('Clear error:', e);
    alert('クリアエラー: ' + e.message);
  }
}

function playVoiceAlert(message, voiceSettings = null, symbol = null) {
  try {
    // Check if speech synthesis is supported
    if (!('speechSynthesis' in window)) {
      console.log('Speech synthesis not supported');
      return;
    }
    
    // Play chime first if specified
    if (voiceSettings && voiceSettings.chime_file) {
      const chimeAudio = new Audio('/Alarm/' + voiceSettings.chime_file);
      chimeAudio.volume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
      chimeAudio.addEventListener('ended', () => {
        playVoiceMessage(message, voiceSettings, symbol);
      });
      chimeAudio.play().catch(e => {
        console.log('Chime play error', e);
        playVoiceMessage(message, voiceSettings, symbol);
      });
    } else {
      playVoiceMessage(message, voiceSettings, symbol);
    }
  } catch (e) {
    console.log('playVoiceAlert error', e);
  }
}

function playVoiceMessage(message, voiceSettings = null, symbol = null) {
  // Create utterance
  const utterance = new SpeechSynthesisUtterance(message);
  
  // Get global settings
  const globalVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
  const globalRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
  
  // Apply voice settings (rule-specific or global)
  utterance.lang = 'ja-JP';
  utterance.volume = globalVolume;
  utterance.rate = globalRate;
  
  // Set voice if specified
  if (voiceSettings && voiceSettings.voice_name) {
    const voices = speechSynthesis.getVoices();
    const selectedVoice = voices.find(v => v.name === voiceSettings.voice_name);
    if (selectedVoice) {
      utterance.voice = selectedVoice;
    }
  } else {
    // Use default Japanese voice
    const voices = speechSynthesis.getVoices();
    const japaneseVoice = voices.find(voice => voice.lang.startsWith('ja'));
    if (japaneseVoice) {
      utterance.voice = japaneseVoice;
    }
  }
  
  // 通貨名挿入の場合、一拍の間を入れるために分割発声
  if (voiceSettings && voiceSettings.insert_symbol && symbol) {
    const japaneseName = currencyNames[symbol] || symbol;
    const position = voiceSettings.symbol_insert_position || 'prefix';
    
    let parts = [];
    if (position === 'prefix') {
      parts = [japaneseName, message.replace(japaneseName + ' ', '')];
    } else if (position === 'suffix') {
      parts = [message.replace(' ' + japaneseName, ''), japaneseName];
    } else if (position === 'both') {
      const middleMessage = message.replace(japaneseName + ' ', '').replace(' ' + japaneseName, '');
      parts = [japaneseName, middleMessage, japaneseName];
    }
    
    if (parts.length > 1) {
      // 分割発声
      let currentIndex = 0;
      
      function speakNext() {
        if (currentIndex < parts.length) {
          const partUtterance = new SpeechSynthesisUtterance(parts[currentIndex]);
          partUtterance.lang = utterance.lang;
          partUtterance.volume = utterance.volume;
          partUtterance.rate = utterance.rate;
          partUtterance.voice = utterance.voice;
          
          partUtterance.onend = () => {
            currentIndex++;
            // 一拍の間を入れるために少し遅延
            setTimeout(speakNext, 200); // 200msの間
          };
          
          speechSynthesis.speak(partUtterance);
        }
      }
      
      speakNext();
      return;
    }
  }
  
  // Speak
  speechSynthesis.speak(utterance);
  
  console.log('Playing voice message:', message, 'volume:', utterance.volume, 'rate:', utterance.rate);
}

// Start notification checking
document.addEventListener('DOMContentLoaded', () => {
  // Version check - prevent old code from running
  const REQUIRED_VERSION = '2025-11-10-v2';
  const currentVersion = localStorage.getItem('app_version');
  if (currentVersion !== REQUIRED_VERSION) {
    console.log('[NOTIFICATIONS] Version mismatch, waiting for reload');
    return;
  }
  
  // Check if already initialized
  if (notificationPollingStarted) {
    console.log('[NOTIFICATIONS] Already initialized, skipping');
    return;
  }
  notificationPollingStarted = true;
  
  const instanceId = Math.random().toString(36).substr(2, 9);
  console.log('[NOTIFICATIONS] Instance ID: ' + instanceId + ' - Page loaded - Version: ' + REQUIRED_VERSION);
  
  // Function to get current polling interval (in milliseconds)
  // Base interval: 5 minutes (300 seconds) + update delay offset
  const getPollingInterval = () => {
    const delaySecs = parseInt(localStorage.getItem('tv_update_delay') || '10');
    const baseInterval = 300; // 5 minutes in seconds
    const totalSeconds = baseInterval + delaySecs;
    return totalSeconds * 1000; // Convert to milliseconds
  };
  
  // Function to start polling
  const startNotificationPolling = () => {
    if (notificationCheckInterval) {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Clearing existing polling interval ' + notificationCheckInterval);
      clearInterval(notificationCheckInterval);
      notificationCheckInterval = null;
    }

    const intervalMs = getPollingInterval();
    const intervalSecs = intervalMs / 1000;
    const mins = Math.floor(intervalSecs / 60);
    const secs = Math.floor(intervalSecs % 60);
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Starting polling with interval: ' + intervalMs + 'ms (' + mins + 'm ' + secs + 's)');
    checkNotifications(); // Initial check
    notificationCheckInterval = setInterval(checkNotifications, intervalMs);
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Timer ID: ' + notificationCheckInterval);
  };
  
  // Function to stop polling
  const stopNotificationPolling = () => {
    if (notificationCheckInterval) {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Stopping polling');
      clearInterval(notificationCheckInterval);
      notificationCheckInterval = null;
    }
  };
  
  // Function to restart polling with new interval
  const restartNotificationPolling = () => {
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Restarting polling');
    stopNotificationPolling();
    startNotificationPolling();
  };
  
  // Start polling when page is visible
  startNotificationPolling();
  
  // Stop/resume polling when page visibility changes
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page hidden, stopping');
      stopNotificationPolling();
      // Also clear update timer when page is hidden
      if (updateTimer) {
        console.log('[TIMER] Page hidden, clearing timer');
        clearTimeout(updateTimer);
        updateTimer = null;
      }
    } else {
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page visible, resuming');
      startNotificationPolling();
      // Reschedule update timer when page becomes visible
      console.log('[TIMER] Page visible, rescheduling update');
      scheduleNextUpdate();
    }
  });
  
  // Restart polling when update delay setting changes
  document.getElementById('updateDelayInput')?.addEventListener('change', () => {
    const newDelay = parseInt(document.getElementById('updateDelayInput').value);
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Update delay changed to ' + newDelay + 's, restarting polling');
    restartNotificationPolling();
  });
  
  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page unloading, cleanup');
    stopNotificationPolling();
    notificationPollingStarted = false;
  });
});
</script>
</body>
</html>
