<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>ダウ雲表 v2</title>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<style>
body { font-family: 'Yu Gothic', 'Meiryo', sans-serif; background: #1e3c72; color: #fff; padding: 0 !important; margin: 0 !important; }
.container { max-width: none; margin: 0 !important; padding: 0; }
.header-row { display:flex; align-items:center; justify-content:space-between; padding: 10px 10px 12px 6px; margin: 0 8px 14px 6px; border-bottom: 1px solid rgba(255,255,255,0.45); }
h1 { text-align: left; margin: 0; font-size: 1.55em; letter-spacing: 0.4px; text-shadow: none; }
.datetime-section { display: flex; align-items: center; gap: 15px; flex: 1; justify-content: center; }
.datetime-small { font-size: 0.8em; color: #bbb; font-weight: 500; font-family: 'Helvetica', 'Arial', sans-serif; }
.datetime-large { font-size: 1.8em; font-weight: bold; color: #4ade80; font-family: 'Helvetica', 'Arial', sans-serif; }
.right-section { display: flex; align-items: center; gap: 15px; }
#dashboard { margin: 0; padding: 0 8px 0 6px; }
/* 設定パネルスタイル */
.settings { display: flex; gap: 12px; justify-content: flex-end; align-items: center; margin-bottom: 12px; }
.settings label { color: #fff; font-size: 0.95em; }
.settings select, .settings input[type="radio"] { margin-left: 6px; }

/* 設定モーダル */
.settings-button { background:transparent;color:#f5f7ff;border:1px solid rgba(255,255,255,0.8);padding:7px 16px;border-radius:999px;cursor:pointer;display:flex;align-items:center;gap:6px;transition:background 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
.settings-button::before { content:'\2699'; font-size:1.05em; }
.settings-button:hover { background:rgba(255,255,255,0.15); color:#ffffff; }
.modal-overlay { position:fixed; left:0;top:0;right:0;bottom:0; background: rgba(0,0,0,0.4); display:none; align-items:center; justify-content:center; z-index:9999 }
  .modal { background:rgba(255,255,255,0.18); color:#f5f7ff; padding:20px 22px; border-radius:14px; min-width:280px; position:relative; cursor:move; user-select:none; backdrop-filter:blur(14px); -webkit-backdrop-filter:blur(14px); border:1px solid rgba(255,255,255,0.35); box-shadow:0 18px 40px rgba(0,0,0,0.35); max-height:80vh; overflow:auto; }
.modal h3 { margin-top:0; cursor:move; font-weight:600; letter-spacing:0.5px; }
.modal .row { margin-bottom:12px }
.modal label { color:#f5f7ff; }
.modal select, .modal input[type="checkbox"], .modal input[type="radio"] { accent-color:#7ea6ff; }
.modal select { min-width:140px; background:rgba(15,27,65,0.7); color:#f5f7ff; border:1px solid rgba(255,255,255,0.35); border-radius:8px; padding:6px 10px; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.15); }
.modal button { background:rgba(10,20,55,0.6) !important; color:#f5f7ff !important; border:1px solid rgba(255,255,255,0.35) !important; padding:6px 12px !important; border-radius:8px !important; box-shadow:0 8px 18px rgba(0,0,0,0.35); transition:background 0.2s ease, transform 0.2s ease; }
.modal button:hover { background:rgba(30,60,140,0.7) !important; transform:translateY(-1px); }
  .modal .section-header { background:#000; color:#fff; padding:6px 10px; margin:8px 0 10px 0; border-radius:6px; font-weight:600; font-size:0.95em; letter-spacing:0.3px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; }
  .modal .section-header::after { content: '+'; font-size:1.2em; margin-left:auto; transition:transform 0.3s ease; }
  .modal .section-header.active::after { content: '-'; }
  .section-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.5em; line-height:1; padding:0; margin:0; transition:transform 0.2s ease; }
  .section-toggle:hover { transform:scale(1.15); }
  .subsection-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer; padding-right:30px; }
  .subsection-header::after { content: '+'; font-size:1.2em; position:absolute; right:8px; transition:transform 0.3s ease; }
  .subsection-header.active::after { content: '-'; }
  .subsection-body {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.6s ease-in-out;
  }
  .subsection-body.active {
    max-height: 2000px; /* 十分な高さに設定 */
  }
  .subsection-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.2em; line-height:1; padding:2px 6px; margin:0; transition:transform 0.2s ease; }
  .subsection-toggle:hover { opacity:0.7; }

  .modal .section-body {
    font-size: 0.9em;
    font-weight: 400; /* reduced weight for subitems */
    color: inherit;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.6s ease-in-out;
  }
  .modal .section-body.active {
    max-height: 2000px; /* 十分な高さに設定 */
  }
  .modal .section-body label,
  .modal .section-body select,
  .modal .section-body button,
  .modal .section-body input,
  .modal .section-body .col-toggle + label,
  .modal .section-body .row-toggle + label {
    font-size: 0.9em;
    font-weight: 400; /* reduced weight for subitems */
    color: inherit;
  }

/* ノート項目スタイル */
.note-section {
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 12px;
  background: rgba(0,0,0,0.1);
  transition: opacity 0.2s, border-top 0.2s;
}

.note-section[draggable="true"] {
  cursor: grab;
}

.note-section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  gap: 8px;
}

.note-section-title {
  flex: 1;
  min-width: 100px;
  padding: 4px 8px;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 4px;
  background: rgba(15,27,65,0.7);
  color: inherit;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
}

.note-section-content {
  width: 100%;
  min-height: 80px;
  padding: 8px;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 6px;
  background: rgba(15,27,65,0.7);
  color: inherit;
  font-family: inherit;
  font-size: 14px;
  resize: vertical;
  box-sizing: border-box;
}

/* ノートモーダル用の特別なスタイル */
#noteModal .modal {
  display: flex !important;
  flex-direction: column !important;
  max-height: none !important;
  overflow: hidden !important;
  position: relative;
}

.note-section-delete {
  background: #dc3545;
  color: #fff;
  border: none;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  margin-left: 8px;
}

.note-section-delete:hover {
  background: #c82333;
}

.add-note-section-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  margin-top: 8px;
  transition: background 0.2s ease;
}

.add-note-section-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
.light-mode { background: #f5f5f5 !important; color: #111 !important; }
.light-mode .header-row { border-bottom: 1px solid rgba(0,0,0,0.5); }
.light-mode h1 { color: #111 !important; }
.light-mode .settings-button { color:#111; border-color: rgba(0,0,0,0.7); }
.light-mode .settings-button:hover { background: rgba(0,0,0,0.08); color:#000; }
.light-mode .modal-overlay { background: rgba(255,255,255,0.7); }
.light-mode .modal { background:rgba(255,255,255,0.95); color:#111; border:1px solid rgba(0,0,0,0.3); box-shadow:0 18px 40px rgba(0,0,0,0.15); }
.light-mode .modal h3 { color:#111; }
.light-mode .modal label { color:#111; }
.light-mode .modal select { background:#2157ec; color:#fff; border:1px solid #2157ec; }
.light-mode select { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; }
.light-mode .modal input[type="checkbox"], .light-mode .modal input[type="radio"] { accent-color:#2157ec; }
.light-mode .modal button { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; box-shadow:0 8px 18px rgba(0,0,0,0.1); }
.light-mode .modal button:hover { background:#1540b8 !important; border-color:#1540b8 !important; }
.light-mode .modal .section-header { background:#e8e8e8; color:#111; border:1px solid rgba(0,0,0,0.1); }
.light-mode .cond-tf, .light-mode .cond-field, .light-mode .cond-op { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; }
.light-mode .rule-btn { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; }
/* Make the small datetime legible in light mode */
.light-mode .datetime-small {
  color: #000 !important;
}
.light-mode .rule-btn:hover { background:#1540b8 !important; border-color:#1540b8 !important; }
.light-mode input[type="text"], .light-mode input[type="number"], .light-mode textarea { border:1px solid #ccc !important; background:#fff !important; color:#111 !important; }
.light-mode #ruleName, .light-mode #voiceMessage, .light-mode #voiceMessageUp, .light-mode #voiceMessageDown, .light-mode .cond-value { border:1px solid #2157ec !important; }
.light-mode #alignMissingTooltip { color:#000 !important; }
.dark-mode #alignMissingTooltip { color:#fff !important; }
.dark-mode { background: #1e3c72 !important; color: #fff !important; }

table { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; width: auto; border-collapse: collapse; background: #fff; color: #333; table-layout: auto; margin: 0; }
/* テーブルを角丸にするためのラッパー */
.table-wrap { border-radius: 8px; overflow: hidden; display: inline-block; }
th, td { padding: 4px; border: 1px solid #ddd; text-align: center; white-space: nowrap; width: auto; }
th { font-family: Arial; background: #667eea; color: white; }
.tf-label { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; color: #667eea; }
.up { color: #2962ff; font-weight: bold; }
.down { color: #ef4444; font-weight: bold; }
.loading { text-align: left; padding: 50px; }

/* 新規スタイル */
.header-black { background: #000 !important; color: #fff !important; }
.cell-black { background: #000 !important; color: #fff !important; }
.col-cloud-label { color: #000 !important; }
.price-row td:first-child { background: #fff !important; color: #000 !important; font-weight: bold; }
/* ヘッダーは現状のまま維持し、データ部(td)のみフォントを一段階細くする */
table th { font-weight: bold; font-size: 1.1em; }
table td { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; }
/* ダウ時間(9列目) と 交差時間(10列目) を右揃えにする */
table th:nth-child(9), table td:nth-child(9),
table th:nth-child(10), table td:nth-child(10),
table th:nth-child(11), table td:nth-child(11) {
  text-align: right;
}
/* ヘッダーのダウ時間と交差時間をセンター揃え */
table th:nth-child(9), table th:nth-child(10), table th:nth-child(11) {
  text-align: center;
}

/* 発火履歴ウィンドウ */
.main-content { display: flex; flex-direction: column; gap: 1px; align-items: flex-start; padding-left: 6px; }
#dashboard { flex: 0 0 auto; }
#fire-history { 
  flex: 0 0 300px; 
  background: rgba(255,255,255,0.1); 
  border: 1px solid rgba(255,255,255,0.25); 
  border-radius: 8px; 
  padding: 12px; 
  overflow: hidden;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  max-height: calc(100vh - 200px);
}

/* 通貨ごとのコンテナ */
.currency-section {
  display: flex;
  gap: 15px;
  align-items: flex-start;
  padding-bottom: 15px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 15px;
}
.currency-section.hidden {
  display: none;
}
.currency-dashboard {
  flex: 0 0 auto;
}
.currency-fire-history {
  flex: 1 1 auto;
  min-width: 300px;
  max-width: calc(100vw - 400px);
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 8px;
  padding: 12px;
  overflow: hidden;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}
.currency-fire-history-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
.currency-fire-history h3 {
  margin: 0;
  font-size: 1em;
  color: #f5f7ff;
  font-weight: 600;
}
.currency-fire-history button {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
.currency-fire-history button:hover {
  background: rgba(102, 126, 234, 0.4);
}
.currency-fire-history button:first-child {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
.currency-fire-history button:first-child:hover {
  background: rgba(102, 126, 234, 0.4);
}
.rule-count-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
  margin-left: 8px;
}
.rule-count-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
.currency-fire-history-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  max-height: 100%;
}
.fire-item {
  padding: 8px;
  margin-bottom: 6px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  font-size: 0.9em;
  border-left: 3px solid #667eea;
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.fire-item:hover {
  background: rgba(0, 0, 0, 0.3);
}
.fire-time {
  color: #a0c4ff;
  font-weight: 600;
  white-space: nowrap;
}
.fire-name {
  color: #ffd700;
  font-weight: 600;
}
.fire-direction {
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.85em;
}
.direction-up {
  background: #2962ff;
  color: #ffffff;
  border: 1px solid #2962ff;
}
.direction-down {
  background: #f23645;
  color: #ffffff;
  border: 1px solid #f23645;
}
.light-mode .currency-fire-history {
  background: rgba(0, 0, 0, 0.05);
  border-color: rgba(0, 0, 0, 0.2);
}
.light-mode .currency-fire-history-header {
  border-bottom-color: rgba(0, 0, 0, 0.2);
}
/* Light mode: make titles and buttons dark for readability */
.light-mode .currency-fire-history h3,
.light-mode #fire-history h3,
.light-mode .currency-fire-history .currency-fire-history-header h3 {
  color: #111 !important;
}
.light-mode .currency-fire-history button,
.light-mode #test-fire-btn,
.light-mode #clear-fire-history-btn {
  background: rgba(0,0,0,0.05);
  color: #111;
  border-color: rgba(0,0,0,0.6);
}
.light-mode .currency-fire-history button:hover,
.light-mode #test-fire-btn:hover,
.light-mode #clear-fire-history-btn:hover {
  background: rgba(0,0,0,0.08);
}
.light-mode .currency-fire-history button:first-child {
  background: rgba(0,0,0,0.05);
  color: #111;
  border-color: rgba(0,0,0,0.6);
}
.light-mode .currency-fire-history button:first-child:hover {
  background: rgba(0,0,0,0.08);
}
.light-mode .rule-count-btn {
  background: rgba(0,0,0,0.05);
  color: #111;
  border-color: rgba(0,0,0,0.6);
}
.light-mode .rule-count-btn:hover {
  background: rgba(0,0,0,0.08);
}
.light-mode .fire-item {
  background: rgba(0, 0, 0, 0.08);
  border-left-color: #667eea;
}
.light-mode .fire-time {
  color: #2962ff;
}
.light-mode .fire-name {
  color: #d97706;
}

/* 経済指標カレンダーセクションのライトモード対応 */
.light-mode #economic-calendar-section {
  background: rgba(0,0,0,0.05);
  border-color: rgba(0,0,0,0.2);
}
.light-mode #economic-calendar-section h3 {
  color: #111;
}
.light-mode .fire-direction {
  border-width: 1px;
}
.light-mode .direction-up {
  background: #2962ff;
  color: #ffffff;
  border-color: #2962ff;
}
.light-mode .direction-down {
  background: #f23645;
  color: #ffffff;
  border-color: #f23645;
}

#fire-history-header { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
#fire-history h3 { 
  margin: 0; 
  font-size: 1em;
  color: #f5f7ff; 
  font-weight: 600;
}
#test-fire-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
#test-fire-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
#clear-fire-history-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
#clear-fire-history-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
#fire-history-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  max-height: 100%;
}
.fire-item { 
  padding: 8px; 
  margin-bottom: 6px; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  font-size: 0.9em; 
  border-left: 3px solid #667eea;
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.fire-item:hover { background: rgba(0,0,0,0.3); }
.fire-time { color: #a0c4ff; font-weight: 600; white-space: nowrap; }
.fire-name { color: #ffd700; font-weight: 600; }
.light-mode #fire-history { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.2); }
.light-mode #fire-history-header { border-bottom-color: rgba(0,0,0,0.2); }
.light-mode #test-fire-btn { background: rgba(0,0,0,0.05); color: #111; border-color: rgba(0,0,0,0.6); }
.light-mode #test-fire-btn:hover { background: rgba(0,0,0,0.08); }
.light-mode #clear-fire-history-btn { background: rgba(0,0,0,0.05); color: #111; border-color: rgba(0,0,0,0.6); }
.light-mode #clear-fire-history-btn:hover { background: rgba(0,0,0,0.08); }
.light-mode .fire-item { background: rgba(0,0,0,0.08); border-left-color: #667eea; }
.light-mode .fire-time { color: #2962ff; }
.light-mode .fire-name { color: #d97706; }

/* Dark mode: make fire-history buttons high-contrast (white text + white-ish border) */
.dark-mode .currency-fire-history button,
.dark-mode #test-fire-btn,
.dark-mode #clear-fire-history-btn {
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.9);
}
.dark-mode .currency-fire-history button:hover,
.dark-mode #test-fire-btn:hover,
.dark-mode #clear-fire-history-btn:hover {
  background: rgba(255,255,255,0.06);
}
.dark-mode .currency-fire-history button:first-child {
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.9);
}
.dark-mode .currency-fire-history button:first-child:hover {
  background: rgba(255,255,255,0.06);
}
.dark-mode .rule-count-btn {
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.9);
}
.dark-mode .rule-count-btn:hover {
  background: rgba(255,255,255,0.06);
}

/* Light mode adjustments */
.light-mode .modal {
  color: #111 !important;
  background: rgba(255,255,255,0.05) !important;
}
.light-mode .modal select {
  color: #f5f7ff !important;
}
#economic-calendar-section {
  display: flex;
  flex-direction: column;
  transition: min-height 0.3s ease;
}
#economic-calendar-section.hidden {
  min-height: auto !important;
  height: auto !important;
  resize: none !important;
}
#economic-calendar-section.hidden .section-body {
  display: none !important;
}
#economic-calendar-section .section-header {
  background:#000; color:#fff; padding:6px 10px; margin: 0 0 0 0; border-radius:6px; font-weight:600; font-size:0.95em; letter-spacing:0.3px; display:flex; justify-content:space-between; align-items:center; flex-shrink: 0;
}
#economic-calendar-visibility {
  display: flex;
  gap: 8px;
  align-items: center;
}
#economic-calendar-visibility label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 0.9em;
  cursor: pointer;
  margin: 0;
}
#economic-calendar-visibility input[type="radio"] {
  cursor: pointer;
  margin: 0;
}
#economic-calendar-section .section-body {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 0;
}
</style>
</head>
<body>
<div class="container">
<!-- タイトルと設定ボタンを横並び -->
<div class="header-row">
  <h1>ダウ雲表</h1>
  <div class="datetime-section">
    <span class="datetime-small">2025[R07]11/17 月</span>
    <span class="datetime-large">14:32:45</span>
  </div>
  <div class="right-section">
    <div id="marketStatus" style="display:flex; align-items:center; gap:8px; padding:6px 12px; border-radius:6px; font-size:0.9em; background:rgba(255,255,255,0.08);">
      <span style="width:8px; height:8px; border-radius:50%; background:#90EE90; display:inline-block;" id="marketStatusLight"></span>
      <span id="marketStatusText">市場チェック中...</span>
    </div>
    <button id="openNote" class="settings-button">Note</button>
    <button id="openSettings" class="settings-button">設定</button>
  </div>
</div>

<!-- 設定モーダル（初期は非表示） -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <h3 id="settingsTitle" style="margin:0">各項目設定</h3>
    <button id="closeSettings" style="background:#333;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer">閉じる</button>
  </div>
    
    <!-- 表示調整セクション -->
  <div class="section-header" data-section="displayAdjust">表示調整</div>
  <div class="section-body" data-section-body="displayAdjust">
  <div class="row">
      <label>モード</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="dark" id="modeDark"> ダーク</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="light" id="modeLight"> ライト</label>
    </div>
    <div class="row">
      <label for="fontSizeSelect">文字サイズ</label>
      <select id="fontSizeSelect" aria-label="表の文字サイズ">
        <option value="10">10px</option>
        <option value="11">11px</option>
        <option value="12">12px</option>
        <option value="13">13px</option>
        <option value="14">14px</option>
        <option value="15">15px</option>
        <option value="16">16px</option>
        <option value="17">17px</option>
        <option value="18">18px</option>
      </select>
    </div>
    <div class="row">
      <label for="timeFormatSelect">経過時間の表示</label>
      <select id="timeFormatSelect" aria-label="経過時間の表示形式">
        <option value="datetime">測定開始日時</option>
        <option value="dhm">日/時/分</option>
        <option value="hm">時/分</option>
        <option value="m">分のみ</option>
      </select>
    </div>
    <div class="row">
      <label><input type="checkbox" id="enable5mUpdateToggle" checked style="margin-right:8px;"> 5分毎更新有効</label>
    </div>
    
    <!-- 列の表示セクション -->
  </div>
  <div class="section-header" data-section="columns">列の表示</div>
  <div class="section-body" data-section-body="columns">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="1" checked> ダウ転</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="2" checked> 突破数</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="3" checked> 雲交差</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="4" checked> 各雲間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="5" checked> 価格間</label>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="6" checked> 雲角度</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="7" checked> 雲厚み</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="8" checked> ダウ時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="9" checked> 交差時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="10" checked> 時間差</label>
      </div>
    </div>
    
    <!-- 行の表示セクション -->
  </div>
  <div class="section-header" data-section="rows">行の表示</div>
  <div class="section-body" data-section-body="rows">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="5m" checked> 5m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="15m" checked> 15m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="1H" checked> 1H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="4H" checked> 4H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="price" checked> 価格</label>
      </div>
    </div>
    
    <!-- 通貨フィルターセクション -->
  </div>
  <div class="section-header" data-section="currencies">通貨フィルター</div>
  <div class="section-body" data-section-body="currencies">
  <div class="row">
      <div id="currencyFilterContainer" style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <!-- 通貨チェックボックスは動的に生成されます -->
      </div>
  </div>
  </div>

    <!-- 音声設定セクション（グローバル設定のみ） -->
    <div class="section-header" data-section="voice">音声設定</div>
    <div class="section-body" data-section-body="voice">
    <div class="row">
      <label for="voiceVolume">音量</label>
      <input type="range" id="voiceVolume" min="0" max="1" step="0.01" value="0.8" aria-label="音量" style="min-width:150px;">
      <span id="voiceVolumeValue" style="margin-left:8px">80%</span>
    </div>
    <div class="row">
      <label for="voiceRate">音速</label>
      <input type="range" id="voiceRate" min="0.5" max="2.0" step="0.1" value="1.0" aria-label="音速" style="min-width:150px;">
      <span id="voiceRateValue" style="margin-left:8px">1.0x</span>
    </div>
    </div>

    <!-- 発火条件セクション -->
    <div class="section-header" data-section="rules">発火条件（ルール）</div>
    <div class="section-body" data-section-body="rules">
    <div class="row" style="display:flex;flex-direction:column;gap:10px">
      <button id="newRuleBtn" class="rule-btn" style="align-self:flex-start;padding:6px 12px">新規ルール作成</button>
      <div style="width:100%; max-height:220px; overflow:auto; border:1px solid rgba(255,255,255,0.08); padding:8px; border-radius:8px; background:rgba(0,0,0,0.12); position:relative;">
        <div class="subsection-header" data-subsection="savedRules">
          <strong>保存済みルール</strong>
        </div>
        <div class="subsection-body" data-subsection-body="savedRules">
          <ul id="rulesList" style="list-style:none;padding:0;margin:0;display:block"></ul>
        </div>
      </div>

      <div style="width:100%; max-height:360px; overflow:auto; border:1px solid rgba(255,255,255,0.08); padding:8px; border-radius:8px; background:rgba(0,0,0,0.06); position:relative;">
        <div class="subsection-header" data-subsection="ruleEditor">
          <strong>ルール編集</strong>
        </div>
        <div class="subsection-body" data-subsection-body="ruleEditor">
          <div style="display:flex;flex-direction:column;gap:8px;width:100%">
            <div style="display:flex;align-items:center;gap:8px">
              <label style="font-size:0.9em;min-width:72px">ルール名：</label>
              <input id="ruleName" placeholder="ルール名" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit">
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <label style="font-size:0.9em;min-width:72px">通貨選択：</label>
              <select id="ruleScope" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:160px">
                <option value="">全選択</option>
              </select>
            </div>
          </div>
          
          <!-- 音声設定（ルール個別設定） -->
          <div style="margin-top:12px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.04);">
            <div style="font-weight:600;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center">
              <span>音声設定</span>
              <button id="testVoiceBtn" class="rule-btn" style="padding:6px 12px;">音声テスト</button>
            </div>
            <div style="display:flex;flex-direction:column;gap:6px">
              <label style="font-size:0.9em">
                音声メッセージ:
                <input id="voiceMessage" placeholder="例: ルールが発火しました" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:300px">
              </label>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <input type="checkbox" id="insertSymbol" style="cursor:pointer;flex-shrink:0"> 
                  <span onclick="document.getElementById('insertSymbol').click()" style="cursor:pointer;user-select:none">通貨名挿入</span>
                </div>
                <select id="symbolInsertPosition" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:104px">
                  <option value="prefix">先頭</option>
                  <option value="suffix">最後</option>
                  <option value="both">先頭と最後</option>
                </select>
              </div>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <input type="checkbox" id="voiceDirectionBased" style="cursor:pointer;flex-shrink:0">
                  <span onclick="document.getElementById('voiceDirectionBased').click()" style="cursor:pointer;user-select:none">方向別挿入</span>
                </div>
                <select id="voiceMessagePosition" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:104px">
                  <option value="prefix">先頭</option>
                  <option value="suffix">最後</option>
                  <option value="both">先頭と最後</option>
                </select>
              </div>
              <div id="directionMessages" style="display:none;flex-direction:row;gap:12px;margin-left:8px;align-items:center">
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  上昇：
                  <input id="voiceMessageUp" placeholder="例: 上昇トレンドが検出されました" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  下降：
                  <input id="voiceMessageDown" placeholder="例: 下降トレンドが検出されました" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
              </div>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <input type="checkbox" id="playChimeFirst" style="cursor:pointer;flex-shrink:0">
                  <span onclick="document.getElementById('playChimeFirst').click()" style="cursor:pointer;user-select:none">電子音挿入</span>
                </div>
                <select id="chimeSelect" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:104px">
                  <option value="">なし</option>
                </select>
              </div>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <span>声優選択項目</span>
                </div>
                <select id="voiceSelect" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:200px">
                  <option value="">グローバル設定を使用</option>
                  <!-- 音声リストは動的に追加 -->
                </select>
              </div>
            </div>
          </div>
          
          <!-- 雲整列条件 UI（ユーザー指定レイアウト） -->
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:6px;padding:6px;border-radius:6px;background:rgba(0,0,0,0.02);">
            <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">
              <strong style="margin-right:6px">雲整列条件</strong>
              <label style="font-size:0.9em"><input type="checkbox" id="alignAllTf"> 全時間</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="5m"> 5m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="15m"> 15m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="1H"> 1H</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="4H"> 4H</label>
            </div>
            <div style="display:flex;align-items:center;gap:12px">
              <div style="display:flex;align-items:center;gap:8px">
                <label style="font-size:0.9em">欠損</label>
                <select id="alignMissing" style="padding:6px;border-radius:6px;background:rgba(15,27,65,0.7);color:inherit;border:1px solid rgba(255,255,255,0.12)">
                  <option value="ignore">無視</option>
                  <option value="fail">不一致</option>
                </select>
                <span id="alignMissingTooltip" style="cursor:pointer;font-size:1.2em;">ⓘ</span>
              </div>
            </div>
            <div id="alignError" style="color:#ffb4b4;font-weight:600;margin-top:6px;display:none;width:100%"></div>
          </div>
          <div id="conditionsContainer" style="display:flex;flex-direction:column;gap:6px">
            <!-- 単純な1条件行のテンプレート -->
            <div class="cond-row" style="display:flex;gap:6px;align-items:center">
              <select class="cond-tf" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="5m">5m</option>
                <option value="15m">15m</option>
                <option value="1H">1H</option>
                <option value="4H">4H</option>
              </select>
              <select class="cond-field" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="dauten">ダウ転</option>
                <option value="bos_count">突破数</option>
                <option value="gc">雲交差</option>
                <option value="distance_from_prev">各雲間</option>
                <option value="distance_from_price">価格間</option>
                <option value="angle">雲角度</option>
                <option value="thickness">雲厚み</option>
                <option value="transfer_time_diff">転換時間差</option>
              </select>
              <input class="cond-value" placeholder="値" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit;width:60px">
              <button class="removeCond" style="padding:6px 12px">削除</button>
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button id="addCondBtn" class="rule-btn" style="padding:6px 12px">条件を追加</button>
            <button id="testRuleBtn" class="rule-btn" style="padding:6px 12px">ルールをテスト</button>
            <button id="saveRuleBtn" class="rule-btn" style="margin-left:auto;padding:6px 12px">ルールを保存</button>
          </div>
          <div style="margin-top:8px">
            <div style="font-weight:600;margin-bottom:4px">テスト結果</div>
            <div id="ruleTestResult" style="background:rgba(0,0,0,0.06);color:inherit;padding:8px;border-radius:6px;max-height:260px;overflow:auto">
              <div class="test-summary" style="display:flex;align-items:center;gap:10px">
                <div id="testBadge" style="font-weight:700;padding:6px 10px;border-radius:6px;background:#444;color:#fff">未実行</div>
                <div id="testShort" style="opacity:0.9">ルールを実行して結果を確認してください</div>
              </div>
              <div id="testDetails" style="margin-top:8px;font-size:0.9em;color:inherit">結果の詳細はここに表示されます。</div>
            </div>
          </div>
        </div>
        </div>
      </div>
    </div>
    </div>
  </div>
</div>

<!-- ノートモーダル（初期は非表示） -->
<div class="modal-overlay" id="noteModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="noteTitle" style="display:flex;flex-direction:column;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <h3 id="noteTitle" style="margin:0">ノート</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <select id="noteFontSizeSelect" style="padding:6px 12px;margin-top:0;border-radius:4px;border:1px solid rgba(255,255,255,0.3);background:rgba(0,0,0,0.2);color:#ffffff;font-size:14px;width:60px;">
          <option value="11">11px</option>
          <option value="12">12px</option>
          <option value="13">13px</option>
          <option value="14">14px</option>
          <option value="15" selected>15px</option>
          <option value="16">16px</option>
          <option value="17">17px</option>
          <option value="18">18px</option>
        </select>
        <button id="addNoteSection" class="add-note-section-btn" style="padding:6px 12px;margin-top:0">項目追加</button>
        <button id="saveNote" class="add-note-section-btn" style="background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;padding:6px 12px;margin-top:0">保存</button>
        <button id="exportNote" class="add-note-section-btn" style="background:rgba(34,197,94,0.2);color:#22c55e;border:1px solid #22c55e;padding:6px 12px;margin-top:0">出力</button>
        <button id="importNote" class="add-note-section-btn" style="background:rgba(168,85,247,0.2);color:#a855f7;border:1px solid #a855f7;padding:6px 12px;margin-top:0">読込</button>
        <button id="closeNote" class="add-note-section-btn" style="background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;padding:6px 12px;margin-top:0">閉じる</button>
      </div>
    </div>    <div id="noteSectionsContainer" style="margin-bottom:12px;flex:1;overflow-y:auto;min-height:200px;">
      <!-- ノート項目はJavaScriptで動的に生成されます -->
    </div>
    
    <!-- ページナビゲーション -->
    <div id="notePageNavigation" style="display:flex;justify-content:space-between;align-items:center;padding:8px;border-top:1px solid rgba(255,255,255,0.1);margin-top:8px">
      <div style="display:flex;gap:4px;align-items:center">
        <button id="prevPage" class="page-nav-btn" style="padding:4px 8px;background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;border-radius:4px;cursor:pointer">◀</button>
        <span id="pageIndicator" style="font-size:0.9em;color:rgba(255,255,255,0.8)">1/1</span>
        <button id="nextPage" class="page-nav-btn" style="padding:4px 8px;background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;border-radius:4px;cursor:pointer">▶</button>
        <input type="text" id="pageTitleInput" style="font-size:14px;padding:6px 12px;border-radius:4px;border:1px solid #667eea;background:rgba(102,126,234,0.2);color:#667eea;width:auto;text-align:center;margin-left:8px" placeholder="ページタイトル">
      </div>
      <div style="display:flex;gap:4px;align-items:center">
        <button id="addPage" class="page-nav-btn" style="padding:4px 8px;background:rgba(34,197,94,0.2);color:#22c55e;border:1px solid #22c55e;border-radius:4px;cursor:pointer;font-size:0.8em">+ページ</button>
        <button id="deletePage" class="page-nav-btn" style="padding:4px 8px;background:rgba(239,68,68,0.2);color:#ef4444;border:1px solid #ef4444;border-radius:4px;cursor:pointer;font-size:0.8em">削除</button>
      </div>
    </div>
    
    <!-- リサイズハンドル -->
    <div id="noteResizeHandle" style="position:absolute;bottom:0;right:0;width:20px;height:20px;cursor:nwse-resize;background:linear-gradient(-45deg, transparent 0%, transparent 40%, rgba(255,255,255,0.3) 40%, rgba(255,255,255,0.3) 60%, transparent 60%, transparent 100%);z-index:1000;"></div>
  </div>
</div>

<div class="main-content">
  <div id="dashboards-container">
    <!-- 通貨ごとの表と発火履歴が動的に生成されます -->
  </div>
  <div id="economic-calendar-section" style="margin-top: 15px; border: 1px solid rgba(255,255,255,0.25); border-radius: 8px; padding: 0; background: rgba(255,255,255,0.1); resize: both; overflow: hidden; min-width: 400px; min-height: 300px;">
    <div class="section-header" style="display: flex; justify-content: space-between; align-items: center; margin: 0; background:#000; color:#fff; padding:6px 10px; border-radius:0; font-weight:600; font-size:0.95em; letter-spacing:0.3px;">
      <h3 style="margin: 0; font-size: 1.2em; color: #f5f7ff;">経済指標カレンダー</h3>
      <div style="display: flex; gap: 12px; align-items: center;">
        <select id="calendar-lang-select" style="background: rgba(128,128,128,0.5); color: #f5f7ff; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; padding: 4px 8px; font-size: 11px;">
          <option value="ja">日本語</option>
          <option value="en">English</option>
        </select>
        <div id="economic-calendar-visibility" style="display: flex; gap: 8px; align-items: center;">
          <label style="display: flex; align-items: center; gap: 4px; font-size: 0.9em; cursor: pointer; margin: 0;">
            <input type="radio" name="calendar-visibility" value="show" checked>
            表示
          </label>
          <label style="display: flex; align-items: center; gap: 4px; font-size: 0.9em; cursor: pointer; margin: 0;">
            <input type="radio" name="calendar-visibility" value="hide">
            非表示
          </label>
        </div>
      </div>
    </div>
    <div class="section-body" data-section-body="economic-calendar" style="display: flex; flex-direction: column; flex: 1;">
      <!-- myfxbook.com Economic Calendar Widget - Start -->
      <iframe src="https://widget.myfxbook.com/widget/calendar.html?lang=ja&symbols=USD,JPY" style="border: 0; width:100%; flex: 1; min-height: 0;"></iframe>
      <div style="margin-top: 0; flex-shrink: 0;">
        <div style="width: fit-content; margin: auto;font-family: roboto,sans-serif!important; font-size: 13px; color: #666666;">
         <a href="https://www.myfxbook.com/forex-economic-calendar?utm_source=widget13&utm_medium=link&utm_campaign=copyright" title="Economic Calendar" class="myfxbookLink" target="_blank" rel="noopener"><b style="color:#666666">Economic Calendar</b></a>
         by Myfxbook.com
        </div>
      </div>
      <!-- myfxbook.com Economic Calendar Widget - End -->
    </div>
  </div>
</div>

</div>
<script>
// Version check and cache buster - 2025-11-11-v1
(function() {
  const REQUIRED_VERSION = '2025-11-11-v1';
  const currentVersion = localStorage.getItem('app_version');
  if (currentVersion !== REQUIRED_VERSION) {
    console.log('[VERSION] Updating from', currentVersion, 'to', REQUIRED_VERSION);
    localStorage.setItem('app_version', REQUIRED_VERSION);
    // Force hard reload to clear cache
    console.log('[VERSION] Hard reload required - clearing cache');
    window.location.reload(true);
    return;
  }
})();

// すべてのイベントリスナーを設定する関数
function setupAllEventListeners() {
  console.log('[INIT] Setting up all event listeners');

  // 設定モーダルの開閉
  const openBtn = document.getElementById('openSettings');
  const closeBtn = document.getElementById('closeSettings');
  const overlay = document.getElementById('settingsModal');
  const modal = document.querySelector('.modal');

  if (openBtn) openBtn.addEventListener('click', () => { if (overlay) overlay.style.display = 'flex'; });
  if (closeBtn) closeBtn.addEventListener('click', () => { if (overlay) overlay.style.display = 'none'; });
  if (overlay) overlay.addEventListener('click', (e) => { if (e.target === overlay) overlay.style.display = 'none'; });

// ノートモーダルの開閉
const openNoteBtn = document.getElementById('openNote');
const closeNoteBtn = document.getElementById('closeNote');
const noteOverlay = document.getElementById('noteModal');
const noteModal = noteOverlay ? noteOverlay.querySelector('.modal') : null;

// リサイズ中のフラグ（オーバーレイクリックを防ぐため）
let isResizingNote = false;
let isDraggingNote = false;
// ノートモーダルが開いているかどうか
let isNoteModalOpen = false;

// ノートページ管理
let currentNotePage = 0;
let notePages = [];

if (openNoteBtn) openNoteBtn.addEventListener('click', () => { 
  if (noteOverlay) {
    noteOverlay.style.display = 'flex';
    isNoteModalOpen = true;
    // 保存されたノートページを読み込む
    loadNotePages();
    // ページナビゲーションのイベントハンドラーを設定
    setupPageNavigationHandlers();
    
    // ノートフォントサイズを適用
    const currentNoteFontSize = localStorage.getItem('tv_note_font_size') || '15';
    applyNoteFontSize(currentNoteFontSize);
    
    // サイズ復元を遅らせることでdisplay:flex後のサイズ適用を確実にする
    setTimeout(() => {
      if (noteOverlay) {
        const modal = noteOverlay.querySelector('.modal');
        if (modal) {
          const savedWidth = parseInt(localStorage.getItem('tv_note_modal_width')) || 500;
          const savedHeight = parseInt(localStorage.getItem('tv_note_modal_height')) || 400;
          const savedLeft = localStorage.getItem('tv_note_modal_left') || '50%';
          const savedTop = localStorage.getItem('tv_note_modal_top') || '50%';
          
          console.log('[NOTE] Restoring size:', { savedWidth, savedHeight, savedLeft, savedTop });
          
          modal.style.width = savedWidth + 'px';
          modal.style.height = savedHeight + 'px';
          modal.style.left = savedLeft;
          modal.style.top = savedTop;
          modal.style.position = 'fixed';
          modal.style.margin = '0';
          modal.style.transform = (savedLeft === '50%' && savedTop === '50%') ? 'translate(-50%, -50%)' : 'none';
        }
      }
    }, 50); // 遅延を50msに増やす
  }
});

if (closeNoteBtn) closeNoteBtn.addEventListener('click', () => { 
  if (noteOverlay) {
    // クローズ前にサイズと位置を保存
    const modal = noteOverlay.querySelector('.modal');
    if (modal) {
      const rect = modal.getBoundingClientRect();
      const width = Math.round(rect.width);
      const height = Math.round(rect.height);
      console.log('[NOTE] Saving on close:', { width, height, left: modal.style.left, top: modal.style.top });
      localStorage.setItem('tv_note_modal_width', width.toString());
      localStorage.setItem('tv_note_modal_height', height.toString());
      localStorage.setItem('tv_note_modal_left', modal.style.left || '50%');
      localStorage.setItem('tv_note_modal_top', modal.style.top || '50%');
    }
    noteOverlay.style.display = 'none';
    isNoteModalOpen = false;
  }
});

if (noteOverlay) noteOverlay.addEventListener('click', (e) => { 
  // リサイズ中、ドラッグ中、またはリサイズハンドルのクリックは無視
  if (e.target === noteOverlay && !isResizingNote && !isDraggingNote) {
    // オーバーレイクリック時にもサイズと位置を保存
    if (noteModal) {
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        const rect = modal.getBoundingClientRect();
        const width = Math.round(rect.width);
        const height = Math.round(rect.height);
        console.log('[NOTE] Saving on overlay click:', { width, height, left: modal.style.left, top: modal.style.top });
        localStorage.setItem('tv_note_modal_width', width.toString());
        localStorage.setItem('tv_note_modal_height', height.toString());
        localStorage.setItem('tv_note_modal_left', modal.style.left || '50%');
        localStorage.setItem('tv_note_modal_top', modal.style.top || '50%');
      }
    }
    noteOverlay.style.display = 'none';
    isNoteModalOpen = false;
  }
});  // モーダルのドラッグ機能
  let isDragging = false, offsetX = 0, offsetY = 0;
  if (modal) {
    modal.addEventListener('mousedown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA') return;
      isDragging = true;
      const rect = modal.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      modal.style.position = 'fixed';
      modal.style.margin = '0';
    });
  }

  // ノートモーダルのドラッグ機能とリサイズ機能に必要な変数
  let noteOffsetX = 0, noteOffsetY = 0;
  let noteStartWidth = 0, noteStartHeight = 0, noteStartX = 0, noteStartY = 0;
  const noteResizeHandle = document.getElementById('noteResizeHandle');
  
  if (noteOverlay) {
    const noteModalContent = noteOverlay.querySelector('.modal');
    if (noteModalContent) {
      noteModalContent.addEventListener('mousedown', e => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA') return;
        if (e.target === noteResizeHandle || noteResizeHandle.contains(e.target)) return; // リサイズハンドルは除外
        isDraggingNote = true;
        const rect = noteModalContent.getBoundingClientRect();
        noteOffsetX = e.clientX - rect.left;
        noteOffsetY = e.clientY - rect.top;
        noteModalContent.style.position = 'fixed';
        noteModalContent.style.margin = '0';
        noteModalContent.style.transform = 'none'; // ドラッグ中にtransformを無効化
        console.log('[NOTE] Drag started');
      });
    }
  }
  
  // リサイズハンドルのイベント
  if (noteResizeHandle && noteOverlay) {
    noteResizeHandle.addEventListener('mousedown', e => {
      e.preventDefault();
      e.stopPropagation();
      isResizingNote = true;
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        const rect = modal.getBoundingClientRect();
        noteStartWidth = rect.width;
        noteStartHeight = rect.height;
        noteStartX = e.clientX;
        noteStartY = e.clientY;
        console.log('[NOTE] Resize started:', { width: noteStartWidth, height: noteStartHeight });
      }
    });
  }

  document.addEventListener('mousemove', e => {
    if (!isDragging && !isDraggingNote && !isResizingNote) return;
    
    if (isDragging && modal) {
      modal.style.left = (e.clientX - offsetX) + 'px';
      modal.style.top = (e.clientY - offsetY) + 'px';
    }
    
    if (isDraggingNote && noteOverlay) {
      const noteModalContent = noteOverlay.querySelector('.modal');
      if (noteModalContent) {
        noteModalContent.style.left = (e.clientX - noteOffsetX) + 'px';
        noteModalContent.style.top = (e.clientY - noteOffsetY) + 'px';
      }
    }
    
    if (isResizingNote && noteOverlay) {
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        // ウィンドウサイズを取得
        const maxWidth = window.innerWidth * 0.95; // 画面幅の95%まで
        const maxHeight = window.innerHeight * 0.95; // 画面高さの95%まで
        const minWidth = 300;
        const minHeight = 200;
        
        const newWidth = Math.max(minWidth, Math.min(maxWidth, noteStartWidth + (e.clientX - noteStartX)));
        const newHeight = Math.max(minHeight, Math.min(maxHeight, noteStartHeight + (e.clientY - noteStartY)));
        
        modal.style.width = newWidth + 'px';
        modal.style.height = newHeight + 'px';
      }
    }
  });

  document.addEventListener('mouseup', () => {
    if ((isDraggingNote || isResizingNote) && noteOverlay && isNoteModalOpen) {
      // ドラッグまたはリサイズ終了時にサイズと位置を保存
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        const rect = modal.getBoundingClientRect();
        const width = Math.round(rect.width);
        const height = Math.round(rect.height);
        console.log('[NOTE] Saving on mouse up:', { width, height, left: modal.style.left, top: modal.style.top });
        localStorage.setItem('tv_note_modal_width', width.toString());
        localStorage.setItem('tv_note_modal_height', height.toString());
        localStorage.setItem('tv_note_modal_left', modal.style.left || '50%');
        localStorage.setItem('tv_note_modal_top', modal.style.top || '50%');
      }
    }
    isDragging = false;
    isDraggingNote = false;
    isResizingNote = false;
  });

  // ルール関連のイベントリスナー
  const newRuleBtn = document.getElementById('newRuleBtn');
  if (newRuleBtn) {
    newRuleBtn.addEventListener('click', () => {
      console.log('[EVENT] New rule button clicked');
      document.getElementById('ruleName').value = '';
      document.getElementById('conditionsContainer').innerHTML = '';
      addConditionRow();
      document.getElementById('saveRuleBtn').dataset.editing = '';

      // clear voice settings
      document.getElementById('voiceMessage').value = '';
      document.getElementById('voiceMessageUp').value = '';
      document.getElementById('voiceMessageDown').value = '';
      document.getElementById('voiceDirectionBased').checked = false;
      document.getElementById('directionMessages').style.display = 'none';
      document.getElementById('voiceMessagePosition').value = 'suffix';
      document.getElementById('voiceSelect').value = '';
      document.getElementById('playChimeFirst').checked = false;
      document.getElementById('chimeSelect').value = '';
    });
  }

  const addCondBtn = document.getElementById('addCondBtn');
  if (addCondBtn) {
    addCondBtn.addEventListener('click', () => {
      console.log('[EVENT] Add condition button clicked');
      addConditionRow();
    });
  }

  const voiceDirectionBased = document.getElementById('voiceDirectionBased');
  if (voiceDirectionBased) {
    voiceDirectionBased.addEventListener('change', e => {
      console.log('[EVENT] Voice direction based changed:', e.target.checked);
      const directionDiv = document.getElementById('directionMessages');
      if (directionDiv) {
        directionDiv.style.display = e.target.checked ? 'flex' : 'none';
      }
    });
  }

  const alignMissingTooltip = document.getElementById('alignMissingTooltip');
  if (alignMissingTooltip) {
    alignMissingTooltip.addEventListener('click', () => {
      alert(`・無視\n欠損した TF を判定から除外し、残りの TF で整列条件を評価します。データが一部欠けていても、条件を満たせば整列成立とみなします。\n例1: 5m、15m、1H、4H全てチェック、15m欠損の場合、15mを除外して5m、1H、4Hの順序が雲の順番と一致すれば成立。\n例2: 5m、15m、1H、4H全てチェック、雲が5m、15m、4H、1H、4H欠損の場合、4Hを除外して5m、15m、1Hの順序が一致して発火。\n\n・不一致\n欠損した TF があれば、即座に整列条件を不成立と判定します。データが完全でないと条件を満たさない厳格な扱いになります。\n例: 5m、15m、1H、4H全てチェック、15m欠損の場合、欠損があるため不成立。`);
    });
  }

  const testVoiceBtn = document.getElementById('testVoiceBtn');
  if (testVoiceBtn) {
    testVoiceBtn.addEventListener('click', () => {
      console.log('[EVENT] Test voice button clicked');
      const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
      const voiceName = document.getElementById('voiceSelect').value;
      const messagePosition = document.getElementById('voiceMessagePosition').value;
      const playChime = document.getElementById('playChimeFirst').checked;
      const chimeFile = document.getElementById('chimeSelect').value;
      const insertSymbol = document.getElementById('insertSymbol').checked;
      const ruleScope = document.getElementById('ruleScope').value;

      let testMessage = '';
      if (isDirectionBased) {
        const messageUp = document.getElementById('voiceMessageUp').value.trim();
        const messageDown = document.getElementById('voiceMessageDown').value.trim();
        const directionMessage = messageUp || 'テストメッセージ（上昇）';
        const baseMessage = document.getElementById('voiceMessage').value.trim() || 'ルールが発火しました';

        if (messagePosition === 'prefix') {
          testMessage = directionMessage + ' ' + baseMessage;
        } else if (messagePosition === 'suffix') {
          testMessage = baseMessage + ' ' + directionMessage;
        } else if (messagePosition === 'both') {
          testMessage = directionMessage + ' ' + baseMessage + ' ' + directionMessage;
        }
      } else {
        testMessage = document.getElementById('voiceMessage').value.trim() || 'テストメッセージ';
      }

      // 通貨名挿入処理
      if (insertSymbol && ruleScope) {
        const japaneseName = currencyNames[ruleScope] || ruleScope;
        const symbolInsertPosition = document.getElementById('symbolInsertPosition').value;
        if (testMessage.includes('{symbol}')) {
          testMessage = testMessage.replace('{symbol}', japaneseName);
        } else {
          if (symbolInsertPosition === 'prefix') {
            testMessage = japaneseName + ' ' + testMessage;
          } else if (symbolInsertPosition === 'suffix') {
            testMessage = testMessage + ' ' + japaneseName;
          } else if (symbolInsertPosition === 'both') {
            testMessage = japaneseName + ' ' + testMessage + ' ' + japaneseName;
          }
        }
      }

      const voiceSettings = {};
      if (voiceName) voiceSettings.voice_name = voiceName;
      if (playChime && chimeFile) voiceSettings.chime_file = chimeFile;
      if (insertSymbol && ruleScope) {
        voiceSettings.insert_symbol = true;
        voiceSettings.symbol_insert_position = document.getElementById('symbolInsertPosition').value;
      }
      const rateSuffix = testMessage ? '' : '。音速は' + document.getElementById('voiceRate').value + '倍です。';
      playVoiceAlert(testMessage + rateSuffix, voiceSettings, ruleScope || 'USDJPY');
    });
  }

  const saveRuleBtn = document.getElementById('saveRuleBtn');
  if (saveRuleBtn) {
    saveRuleBtn.addEventListener('click', async () => {
      console.log('[EVENT] Save rule button clicked');
      // validate alignment first
      const alignValid = validateAlignmentForSave();
      if(!alignValid.ok){ return; }

      const name = document.getElementById('ruleName').value || ('rule-' + Date.now());
      const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
      const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
      const conditions = condRows.map(r => {
        const tf = r.querySelector('.cond-tf').value;
        const fld = r.querySelector('.cond-field').value;
        const valEl = r.querySelector('.cond-value');
        const valVal = valEl ? valEl.value : null;
        return { label: tf, field: fld, value: valVal };
      });
      const alignment = getAlignmentSettingsFromUI();
      const ruleObj = { conditions: conditions };
      // include alignment only if TFs selected
      if(alignment.tfs && alignment.tfs.length > 0){ ruleObj.alignment = alignment; }

      // include voice settings
      const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
      const voiceName = document.getElementById('voiceSelect').value;
      const messagePosition = document.getElementById('voiceMessagePosition').value;
      const commonMessage = document.getElementById('voiceMessage').value.trim();
      const messageUp = document.getElementById('voiceMessageUp').value.trim();
      const messageDown = document.getElementById('voiceMessageDown').value.trim();
      const playChime = document.getElementById('playChimeFirst').checked;
      const chimeFile = document.getElementById('chimeSelect').value;

      // Check if any voice setting exists
      if (commonMessage || messageUp || messageDown || voiceName || (playChime && chimeFile)) {
        ruleObj.voice = {};

        // Always save common message if present
        if (commonMessage) {
          ruleObj.voice.message = commonMessage;
        }

        // Save direction-based messages if direction-based mode is enabled
        if (isDirectionBased) {
          ruleObj.voice.message_up = messageUp;
          ruleObj.voice.message_down = messageDown;
          ruleObj.voice.message_position = messagePosition;
        }

        // Always save voice name if selected
        if (voiceName) {
          ruleObj.voice.voice_name = voiceName;
        }

        // Save chime settings
        if (playChime && chimeFile) {
          ruleObj.voice.chime_file = chimeFile;
        }

        // Save symbol insert setting
        if (document.getElementById('insertSymbol').checked) {
          ruleObj.voice.insert_symbol = true;
          ruleObj.voice.symbol_insert_position = document.getElementById('symbolInsertPosition').value;
        } else {
          delete ruleObj.voice.insert_symbol;
          delete ruleObj.voice.symbol_insert_position;
        }
      }

      const payload = { id: document.getElementById('saveRuleBtn').dataset.editing || name, name: name, enabled: true, scope: scope, rule: ruleObj };
      try {
        const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await res.json();
        if (j.status === 'success') {
          alert('ルールを保存しました');
          // ルール一覧を再度読み込んで、最新のデータを取得
          await loadRules();
          // 保存したルールを再度開いて、UIを最新の状態に更新
          try {
            const rulesRes = await fetch('/rules');
            const rulesData = await rulesRes.json();
            if (rulesData.status === 'success') {
              const savedRule = rulesData.rules.find(r => r.id === payload.id);
              if (savedRule) {
                openRuleEditor(savedRule);
              }
            }
          } catch (e) {
            console.log('Error reloading rule after save:', e);
          }
        }
        else { alert('保存失敗: ' + (j.msg || JSON.stringify(j))); }
      } catch (e) { console.log('save error', e); alert('保存時エラー: ' + e.message); }
    });
  }

  const testRuleBtn = document.getElementById('testRuleBtn');
  if (testRuleBtn) {
    testRuleBtn.addEventListener('click', async () => {
      console.log('[EVENT] Test rule button clicked');
      const panel = document.getElementById('ruleTestResult');
      const badge = document.getElementById('testBadge');
      const short = document.getElementById('testShort');
      const detailsEl = document.getElementById('testDetails');

      badge.style.background = '#777'; badge.textContent = '実行中...';
      short.textContent = '';
      detailsEl.innerHTML = '';

      // build payload
      const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
      const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
      const conditions = condRows.map(r => {
        const tf = r.querySelector('.cond-tf').value;
        const fld = r.querySelector('.cond-field').value;
        const valEl = r.querySelector('.cond-value');
        const valVal = valEl ? (valEl.value || null) : null;
        return { label: tf, field: fld, value: valVal };
      });
      const payload = { rule: { logic: 'AND', conditions: conditions }, scope: scope };
      const alignment = getAlignmentSettingsFromUI();
      if(alignment.tfs && alignment.tfs.length > 0){ payload.rule.alignment = alignment; }

      // alignment validation - we show a non-blocking warning
      const alignValid = validateAlignmentForSave();
      if(!alignValid.ok){ short.textContent = '注意: ' + alignValid.msg; }

      // テスト時に現在のダッシュボードデータを state_override として送信
      if (currentDashboardData && currentDashboardData.length > 0) {
        let selectedState = null;
        const ruleSymbol = scope.symbol;

        if (ruleSymbol) {
          // ルールが特定の通貨に限定されている場合、その通貨の5mデータを使用
          selectedState = currentDashboardData.find(s => s.symbol === ruleSymbol && (s.tf === '5' || s.tf === '5m'));

          // 5mが見つからなければ、その通貨の任意のデータを使用
          if (!selectedState) {
            selectedState = currentDashboardData.find(s => s.symbol === ruleSymbol);
          }
        } else {
          // 通貨指定なしの場合、最初の5mデータを使用
          selectedState = currentDashboardData.find(s => s.tf === '5' || s.tf === '5m');

          // 5mが見つからなければ最初のデータを使用
          if (!selectedState) {
            selectedState = currentDashboardData[0];
          }
        }

        if (selectedState) {
          payload.state_override = selectedState;
        }
      }

      try {
        const res = await fetch('/rules/test', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await res.json();
        if (j.status === 'success') {
          const matched = !!j.matched;
          if (matched) { badge.style.background = '#2d8a3d'; badge.textContent = 'OK'; }
          else { badge.style.background = '#b02a2a'; badge.textContent = 'NG'; }

          const condCount = Array.isArray(payload.rule.conditions) ? payload.rule.conditions.length : 0;
          const passCount = Array.isArray(j.details) ? j.details.filter(d => d.result).length : (matched ? condCount : 0);
          short.textContent = `判定: ${matched ? 'OK' : 'NG'} — 条件合致 ${passCount}/${condCount}${payload.rule.alignment ? ' / 雲整列を含む' : ''}`;

          // 生データ表示/コピー機能の追加
          const rawDataControls = document.createElement('div');
          rawDataControls.style.marginTop = '8px';
          rawDataControls.style.display = 'flex';
          rawDataControls.style.gap = '8px';
          rawDataControls.style.alignItems = 'center';

          const toggleRawBtn = document.createElement('button');
          toggleRawBtn.textContent = '▼生データを表示';
          toggleRawBtn.style.padding = '4px 8px';
          toggleRawBtn.style.border = '1px solid rgba(255,255,255,0.3)';
          toggleRawBtn.style.borderRadius = '4px';
          toggleRawBtn.style.background = 'rgba(255,255,255,0.1)';
          toggleRawBtn.style.color = 'inherit';
          toggleRawBtn.style.cursor = 'pointer';
          toggleRawBtn.style.fontSize = '0.85em';

          const copyRawBtn = document.createElement('button');
          copyRawBtn.textContent = '生データをコピー';
          copyRawBtn.style.padding = '4px 8px';
          copyRawBtn.style.border = '1px solid rgba(255,255,255,0.3)';
          copyRawBtn.style.borderRadius = '4px';
          copyRawBtn.style.background = 'rgba(255,255,255,0.1)';
          copyRawBtn.style.color = 'inherit';
          copyRawBtn.style.cursor = 'pointer';
          copyRawBtn.style.fontSize = '0.85em';

          const rawDataDisplay = document.createElement('pre');
          rawDataDisplay.style.display = 'none';
          rawDataDisplay.style.background = 'rgba(0,0,0,0.3)';
          rawDataDisplay.style.padding = '8px';
          rawDataDisplay.style.borderRadius = '4px';
          rawDataDisplay.style.marginTop = '8px';
          rawDataDisplay.style.fontSize = '0.8em';
          rawDataDisplay.style.maxHeight = '200px';
          rawDataDisplay.style.overflow = 'auto';
          rawDataDisplay.style.whiteSpace = 'pre-wrap';
          rawDataDisplay.textContent = JSON.stringify(j, null, 2);

          toggleRawBtn.addEventListener('click', () => {
            if (rawDataDisplay.style.display === 'none') {
              rawDataDisplay.style.display = 'block';
              toggleRawBtn.textContent = '▲生データを隠す';
            } else {
              rawDataDisplay.style.display = 'none';
              toggleRawBtn.textContent = '▼生データを表示';
            }
          });

          copyRawBtn.addEventListener('click', async () => {
            try {
              await navigator.clipboard.writeText(JSON.stringify(j, null, 2));
              const originalText = copyRawBtn.textContent;
              copyRawBtn.textContent = 'コピーしました！';
              copyRawBtn.style.background = '#2d8a3d';
              setTimeout(() => {
                copyRawBtn.textContent = originalText;
                copyRawBtn.style.background = 'rgba(255,255,255,0.1)';
              }, 2000);
            } catch (err) {
              console.error('コピー失敗:', err);
              alert('コピーに失敗しました');
            }
          });

          rawDataControls.appendChild(toggleRawBtn);
          rawDataControls.appendChild(copyRawBtn);
          detailsEl.appendChild(rawDataControls);
          detailsEl.appendChild(rawDataDisplay);

          if (Array.isArray(j.details) && j.details.length > 0) {
            const ul = document.createElement('ul');
            ul.style.margin = '6px 0 0 14px'; ul.style.padding = '0'; ul.style.listStyle = 'disc';
            j.details.forEach(d => {
              const li = document.createElement('li');
              try {
                const rawName = d.cond || (d.label ? `${d.label}.${d.field}` : JSON.stringify(d));
                const fieldMap = {
                  'alignment':'雲整列', '雲整列':'雲整列',
                  'dauten':'ダウ転換', 'gc':'雲交差', 'bos_count':'突破数', 'daytrade_bos':'突破数',
                  'distance_from_prev':'各雲間', 'distance_from_price':'価格間',
                  'angle':'雲角度', 'thickness':'雲厚み', 'transfer_time_diff':'転換時間差',
                  'presence_check':'存在確認', 'direction_consistency':'方向一貫性'
                };
                let name = rawName;
                const key = d.field || d.cond || rawName;
                if (typeof rawName === 'string' && rawName.includes('.')) {
                  const parts = rawName.split('.');
                  const tfPart = parts[0];
                  const fieldPart = parts[1];
                  const mappedField = fieldMap[fieldPart] || fieldPart;
                  name = `${tfPart}.${mappedField}`;
                } else if (fieldMap[key]) {
                  name = fieldMap[key];
                }
                const ok = d.result ? 'OK' : 'NG';
                li.textContent = `${name}：${ok}`.trim();
              } catch (e) { li.textContent = JSON.stringify(d); }
              ul.appendChild(li);
            });
            detailsEl.appendChild(ul);
          } else {
            detailsEl.textContent = '詳細情報はありません。';
          }
        } else {
          badge.style.background = '#aa5500'; badge.textContent = 'エラー';
          short.textContent = 'エラー: ' + (j.msg || JSON.stringify(j));
          detailsEl.textContent = '';
        }
      } catch (e) {
        badge.style.background = '#aa5500'; badge.textContent = '実行エラー';
        short.textContent = e.message;
        detailsEl.textContent = '';
      }
    });
  }

  const testFireBtn = document.getElementById('test-fire-btn');
  if (testFireBtn) {
    testFireBtn.addEventListener('click', () => {
      console.log('[EVENT] Test fire button clicked');
      testFire();
    });
  }

  const clearFireHistoryBtn = document.getElementById('clear-fire-history-btn');
  if (clearFireHistoryBtn) {
    clearFireHistoryBtn.addEventListener('click', async () => {
      console.log('[EVENT] Clear fire history button clicked');
      try {
        const res = await fetch('/api/clear_notifications', { method: 'POST' });
        const data = await res.json();
        if (data.status === 'success') {
          const listEl = document.getElementById('fire-history-list');
          if (listEl) {
            listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
          }
          console.log('Notifications cleared');
        } else {
          console.log('Clear failed:', data);
          alert('クリアに失敗しました: ' + (data.msg || JSON.stringify(data)));
        }
      } catch (e) {
        console.log('Clear error:', e);
        alert('クリアエラー: ' + e.message);
      }
    });
  }

  // Align checkbox event listeners
  document.querySelectorAll('.align-tf').forEach(cb => cb.addEventListener('change', () => {
    console.log('[EVENT] Align TF checkbox changed');
    // no-op for now; validation on save/test
  }));

  const alignAllTf = document.getElementById('alignAllTf');
  if (alignAllTf) {
    alignAllTf.addEventListener('change', (e) => {
      console.log('[EVENT] Align all TF checkbox changed:', e.target.checked);
      const checked = e.target.checked;
      document.querySelectorAll('.align-tf').forEach(cb => cb.checked = checked);
    });
  }

  // 言語選択イベントリスナー
  const calendarLangSelect = document.getElementById('calendar-lang-select');
  if (calendarLangSelect) {
    calendarLangSelect.addEventListener('change', (e) => {
      const selectedLang = e.target.value;
      if (confirm('言語を変更すると、経済指標カレンダーの現在の設定（フィルターなど）がリセットされます。よろしいですか？')) {
        localStorage.setItem('tv_calendar_lang', selectedLang);
        const iframe = document.querySelector('#economic-calendar-section iframe');
        if (iframe) {
          const currentSrc = iframe.src;
          const newSrc = currentSrc.replace(/lang=[^&]*/, 'lang=' + selectedLang);
          iframe.src = newSrc;
        }
      } else {
        // キャンセルされたら元の値に戻す
        e.target.value = localStorage.getItem('tv_calendar_lang') || 'ja';
      }
    });
  }

  // 経済指標カレンダーの表示/非表示ラジオボタンイベント
  const calendarVisibilityRadios = document.querySelectorAll('input[name="calendar-visibility"]');
  console.log('[CALENDAR] Found ' + calendarVisibilityRadios.length + ' visibility radios');
  calendarVisibilityRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
      console.log('[CALENDAR] Visibility changed to:', e.target.value);
      const calendarSection = document.getElementById('economic-calendar-section');
      if (e.target.value === 'hide') {
        calendarSection.classList.add('hidden');
        localStorage.setItem('tv_calendar_visible', 'false');
        console.log('[CALENDAR] Hidden class added');
      } else {
        calendarSection.classList.remove('hidden');
        localStorage.setItem('tv_calendar_visible', 'true');
        console.log('[CALENDAR] Hidden class removed');
      }
    });
  });

// ノート項目の作成関数
function createNoteSection(title = '', content = '', images = []) {
  const section = document.createElement('div');
  section.className = 'note-section';
  section.draggable = true;
  
  const header = document.createElement('div');
  header.className = 'note-section-header';
  
  const dragHandle = document.createElement('span');
  dragHandle.textContent = '≡';
  dragHandle.style.cursor = 'grab';
  dragHandle.style.marginRight = '8px';
  dragHandle.style.color = 'rgba(255,255,255,0.6)';
  dragHandle.style.fontSize = '18px';
  dragHandle.style.lineHeight = '1';
  
  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.className = 'note-section-title';
  titleInput.placeholder = '項目タイトル';
  titleInput.value = title;
  
  const buttonContainer = document.createElement('div');
  buttonContainer.style.display = 'flex';
  buttonContainer.style.gap = '4px';
  
  const upBtn = document.createElement('button');
  upBtn.textContent = '↑';
  upBtn.style.padding = '4px 8px';
  upBtn.style.background = 'rgba(102,126,234,0.2)';
  upBtn.style.color = '#667eea';
  upBtn.style.border = '1px solid #667eea';
  upBtn.style.borderRadius = '4px';
  upBtn.style.cursor = 'pointer';
  upBtn.style.fontSize = '14px';
  upBtn.addEventListener('click', () => {
    const prev = section.previousElementSibling;
    if (prev) {
      section.parentNode.insertBefore(section, prev);
      autoSaveNote();
    }
  });
  
  const downBtn = document.createElement('button');
  downBtn.textContent = '↓';
  downBtn.style.padding = '4px 8px';
  downBtn.style.background = 'rgba(102,126,234,0.2)';
  downBtn.style.color = '#667eea';
  downBtn.style.border = '1px solid #667eea';
  downBtn.style.borderRadius = '4px';
  downBtn.style.cursor = 'pointer';
  downBtn.style.fontSize = '14px';
  downBtn.addEventListener('click', () => {
    const next = section.nextElementSibling;
    if (next) {
      section.parentNode.insertBefore(next, section);
      autoSaveNote();
    }
  });
  
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'note-section-delete';
  deleteBtn.textContent = '×';
  deleteBtn.style.width = 'auto';
  deleteBtn.style.padding = '4px 8px';
  deleteBtn.addEventListener('click', () => {
    if (confirm('この項目を削除しますか？')) {
      section.remove();
      autoSaveNote();
    }
  });
  
  header.appendChild(dragHandle);
  header.appendChild(titleInput);
  buttonContainer.appendChild(upBtn);
  buttonContainer.appendChild(downBtn);
  buttonContainer.appendChild(deleteBtn);
  header.appendChild(buttonContainer);
  
  const contentTextarea = document.createElement('textarea');
  contentTextarea.className = 'note-section-content';
  contentTextarea.placeholder = '内容を入力してください...';
  contentTextarea.value = content;
  
  // 画像表示エリア
  const imageContainer = document.createElement('div');
  imageContainer.className = 'note-section-images';
  imageContainer.style.display = 'flex';
  imageContainer.style.flexWrap = 'wrap';
  imageContainer.style.gap = '8px';
  imageContainer.style.marginTop = '8px';
  imageContainer.style.padding = '8px';
  imageContainer.style.borderTop = '1px solid rgba(255,255,255,0.1)';
  
  // ドラッグ&ドロップエリア
  const dropZone = document.createElement('div');
  dropZone.style.border = '2px dashed rgba(255,255,255,0.2)';
  dropZone.style.borderRadius = '4px';
  dropZone.style.padding = '16px';
  dropZone.style.textAlign = 'center';
  dropZone.style.color = 'rgba(255,255,255,0.6)';
  dropZone.style.fontSize = '12px';
  dropZone.style.cursor = 'pointer';
  dropZone.style.transition = 'all 0.3s ease';
  dropZone.textContent = '画像をドラッグ&ドロップ';
  
  // 既存画像を表示
  images.forEach(imageData => {
    const imgThumb = document.createElement('div');
    imgThumb.className = 'note-image-thumb';
    imgThumb.style.width = '60px';
    imgThumb.style.height = '60px';
    imgThumb.style.borderRadius = '4px';
    imgThumb.style.overflow = 'hidden';
    imgThumb.style.cursor = 'pointer';
    imgThumb.style.border = '1px solid rgba(255,255,255,0.2)';
    imgThumb.style.position = 'relative';
    
    const img = document.createElement('img');
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'cover';
    
    // 旧フォーマット（文字列）との互換性
    let imageHash = null;
    let base64Data = null;
    
    if (typeof imageData === 'string') {
      // 旧フォーマット：Base64またはファイルパス
      if (imageData.startsWith('data:')) {
        base64Data = imageData;
        img.src = base64Data;
      } else {
        // ファイルパスの場合は表示できないため、スキップ
        return;
      }
    } else if (imageData.type === 'hash') {
      // 新フォーマット：ハッシュ値
      imageHash = imageData.value;
      img.dataset.imagehash = imageHash;
      img.src = `/api/note-image/${imageHash}`;
    } else if (imageData.type === 'base64') {
      // 新フォーマット：Base64
      base64Data = imageData.value;
      img.src = base64Data;
    }
    
    const deleteImgBtn = document.createElement('button');
    deleteImgBtn.textContent = '×';
    deleteImgBtn.style.position = 'absolute';
    deleteImgBtn.style.top = '0';
    deleteImgBtn.style.right = '0';
    deleteImgBtn.style.background = 'rgba(0,0,0,0.7)';
    deleteImgBtn.style.color = '#fff';
    deleteImgBtn.style.border = 'none';
    deleteImgBtn.style.width = '20px';
    deleteImgBtn.style.height = '20px';
    deleteImgBtn.style.cursor = 'pointer';
    deleteImgBtn.style.fontSize = '14px';
    deleteImgBtn.style.display = 'none';
    
    imgThumb.addEventListener('mouseenter', () => deleteImgBtn.style.display = 'block');
    imgThumb.addEventListener('mouseleave', () => deleteImgBtn.style.display = 'none');
    
    deleteImgBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      imgThumb.remove();
      autoSaveNote();
    });
    
    imgThumb.appendChild(img);
    imgThumb.appendChild(deleteImgBtn);
    
    imgThumb.addEventListener('click', () => {
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.background = 'rgba(0,0,0,0.8)';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '10000';
      
      const largeImg = document.createElement('img');
      largeImg.src = img.src;
      largeImg.style.maxWidth = '90%';
      largeImg.style.maxHeight = '90%';
      
      modal.appendChild(largeImg);
      modal.addEventListener('click', () => modal.remove());
      document.body.appendChild(modal);
    });
    
    imageContainer.appendChild(imgThumb);
  });
  
  imageContainer.appendChild(dropZone);
  
  // ドラッグ&ドロップイベント
  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.style.background = 'rgba(102,126,234,0.2)';
    dropZone.style.borderColor = '#667eea';
  });
  
  dropZone.addEventListener('dragleave', () => {
    dropZone.style.background = 'transparent';
    dropZone.style.borderColor = 'rgba(255,255,255,0.2)';
  });
  
  dropZone.addEventListener('drop', async (e) => {
    e.preventDefault();
    dropZone.style.background = 'transparent';
    dropZone.style.borderColor = 'rgba(255,255,255,0.2)';
    
    const files = e.dataTransfer.files;
    for (let file of files) {
      if (file.type.startsWith('image/')) {
        await uploadImage(file, imageContainer, dropZone);
      }
    }
  });
  
  section.appendChild(header);
  section.appendChild(contentTextarea);
  section.appendChild(imageContainer);
  
  // 現在のノートフォントサイズを適用
  const currentNoteFontSize = localStorage.getItem('tv_note_font_size') || '15';
  titleInput.style.fontSize = currentNoteFontSize + 'px';
  contentTextarea.style.fontSize = currentNoteFontSize + 'px';
  
  // 自動保存イベントリスナー
  titleInput.addEventListener('input', () => autoSaveNote());
  contentTextarea.addEventListener('input', () => autoSaveNote());
  
  // 項目間のドラッグ&ドロップ
  section.addEventListener('dragstart', (e) => {
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', section.innerHTML);
    section.style.opacity = '0.5';
  });
  
  section.addEventListener('dragend', () => {
    section.style.opacity = '1';
  });
  
  section.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    section.style.borderTop = '2px solid #667eea';
  });
  
  section.addEventListener('dragleave', () => {
    section.style.borderTop = '';
  });
  
  section.addEventListener('drop', (e) => {
    e.preventDefault();
    e.stopPropagation();
    section.style.borderTop = '';
    // ドロップされた項目の前に挿入
    const draggedSection = document.querySelector('[style*="opacity: 0.5"]');
    if (draggedSection && draggedSection !== section) {
      section.parentNode.insertBefore(draggedSection, section);
      autoSaveNote();
    }
  });
  
  return section;
}

// 画像アップロード関数
async function uploadImage(file, imageContainer, dropZone) {
  const reader = new FileReader();
  reader.onload = async (e) => {
    const base64Data = e.target.result;
    
    try {
      const response = await fetch('/api/upload-note-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ imageData: base64Data })
      });
      
      const result = await response.json();
      
      if (result.status === 'success') {
        // 既存のサムネイルと同じファイルがないかチェック
        const existingThumbs = imageContainer.querySelectorAll('.note-image-thumb');
        let isDuplicate = false;
        for (let thumb of existingThumbs) {
          const img = thumb.querySelector('img');
          if (img && img.dataset.imagehash === result.imageHash) {
            isDuplicate = true;
            break;
          }
        }
        
        if (isDuplicate) {
          console.log('[NOTE] Image already added in this section');
          return;
        }
        
        // 画像サムネイルを追加
        const imgThumb = document.createElement('div');
        imgThumb.className = 'note-image-thumb';
        imgThumb.style.width = '60px';
        imgThumb.style.height = '60px';
        imgThumb.style.borderRadius = '4px';
        imgThumb.style.overflow = 'hidden';
        imgThumb.style.cursor = 'pointer';
        imgThumb.style.border = '1px solid rgba(255,255,255,0.2)';
        imgThumb.style.position = 'relative';
        
        const img = document.createElement('img');
        img.src = base64Data;
        img.dataset.imagehash = result.imageHash;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        
        const deleteImgBtn = document.createElement('button');
        deleteImgBtn.textContent = '×';
        deleteImgBtn.style.position = 'absolute';
        deleteImgBtn.style.top = '0';
        deleteImgBtn.style.right = '0';
        deleteImgBtn.style.background = 'rgba(0,0,0,0.7)';
        deleteImgBtn.style.color = '#fff';
        deleteImgBtn.style.border = 'none';
        deleteImgBtn.style.width = '20px';
        deleteImgBtn.style.height = '20px';
        deleteImgBtn.style.cursor = 'pointer';
        deleteImgBtn.style.fontSize = '14px';
        deleteImgBtn.style.display = 'none';
        
        imgThumb.addEventListener('mouseenter', () => deleteImgBtn.style.display = 'block');
        imgThumb.addEventListener('mouseleave', () => deleteImgBtn.style.display = 'none');
        
        deleteImgBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          imgThumb.remove();
          autoSaveNote();
        });
        
        imgThumb.appendChild(img);
        imgThumb.appendChild(deleteImgBtn);
        
        imgThumb.addEventListener('click', () => {
          const modal = document.createElement('div');
          modal.style.position = 'fixed';
          modal.style.top = '0';
          modal.style.left = '0';
          modal.style.width = '100%';
          modal.style.height = '100%';
          modal.style.background = 'rgba(0,0,0,0.8)';
          modal.style.display = 'flex';
          modal.style.alignItems = 'center';
          modal.style.justifyContent = 'center';
          modal.style.zIndex = '10000';
          
          const largeImg = document.createElement('img');
          largeImg.src = base64Data;
          largeImg.style.maxWidth = '90%';
          largeImg.style.maxHeight = '90%';
          
          modal.appendChild(largeImg);
          modal.addEventListener('click', () => modal.remove());
          document.body.appendChild(modal);
        });
        
        imageContainer.insertBefore(imgThumb, dropZone);
        autoSaveNote();
        console.log('[NOTE] Image uploaded:', result.filename);
      } else {
        alert('画像アップロードエラー: ' + result.msg);
      }
    } catch (error) {
      console.error('[ERROR] Image upload failed:', error);
      alert('画像アップロードに失敗しました');
    }
  };
  reader.readAsDataURL(file);
}

// ノートページのデータを取得
function getNotePageData(pageIndex) {
  if (pageIndex < 0 || pageIndex >= notePages.length) return [];
  
  const sections = [];
  const sectionElements = document.querySelectorAll('.note-section');
  
  sectionElements.forEach(section => {
    const titleInput = section.querySelector('.note-section-title');
    const contentTextarea = section.querySelector('.note-section-content');
    const imageElements = section.querySelectorAll('.note-image-thumb img');
    
    if (titleInput && contentTextarea) {
      const images = [];
      imageElements.forEach(img => {
        // 画像データを最適化：ファイルパスを優先
        const imageHash = img.dataset.imagehash;
        const imgSrc = img.src;
        
        if (imageHash) {
          // サーバーに保存されている画像
          images.push({ type: 'hash', value: imageHash });
        } else if (imgSrc && imgSrc.startsWith('data:')) {
          // Base64データ（古い形式）- ファイルパスに変換を試みる
          images.push({ type: 'base64', value: imgSrc });
        } else if (imgSrc && imgSrc.startsWith('file://')) {
          // ローカルファイルパス
          const filePath = decodeURIComponent(imgSrc.replace('file:///', ''));
          images.push({ type: 'path', value: filePath });
        } else {
          // その他の場合
          images.push({ type: 'path', value: imgSrc });
        }
      });
      
      sections.push({
        title: titleInput.value.trim(),
        content: contentTextarea.value.trim(),
        images: images
      });
    }
  });
  
  return sections;
}

// ノートページを保存
function saveNotePages() {
  if (isNoteModalOpen && notePages.length > 0) {
    // 現在のページのデータを保存
    notePages[currentNotePage].sections = getNotePageData(currentNotePage);
    notePages[currentNotePage].lastModified = new Date().toISOString();
    
    // localStorageに保存
    localStorage.setItem('tv_note_pages', JSON.stringify(notePages));
    localStorage.setItem('tv_note_current_page', currentNotePage.toString());
    console.log('[NOTE] Pages saved:', notePages.length, 'pages, current:', currentNotePage);
  }
}

// ノートページを読み込み
function loadNotePages() {
  const savedPages = localStorage.getItem('tv_note_pages');
  const savedCurrentPage = parseInt(localStorage.getItem('tv_note_current_page')) || 0;
  
  if (savedPages) {
    try {
      notePages = JSON.parse(savedPages);
      currentNotePage = Math.min(savedCurrentPage, notePages.length - 1);
      console.log('[NOTE] Loaded pages:', notePages.length, 'current:', currentNotePage);
    } catch (e) {
      console.log('[NOTE] Failed to parse saved pages, creating default');
      createDefaultPages();
    }
  } else {
    // 既存のtv_note_sectionsがある場合は移行
    const savedSections = localStorage.getItem('tv_note_sections');
    if (savedSections) {
      try {
        const sections = JSON.parse(savedSections);
        notePages = [{
          id: 1,
          title: 'ノート',
          sections: sections,
          lastModified: new Date().toISOString()
        }];
        currentNotePage = 0;
        console.log('[NOTE] Migrated old sections to pages');
      } catch (e) {
        console.log('[NOTE] Failed to migrate old sections');
        createDefaultPages();
      }
    } else {
      createDefaultPages();
    }
  }
  
  updatePageNavigation();
  loadCurrentPage();
}

// デフォルトページを作成
function createDefaultPages() {
  notePages = [{
    id: 1,
    title: 'ノート',
    sections: [],
    lastModified: new Date().toISOString()
  }];
  currentNotePage = 0;
}

// 現在のページを読み込み
function loadCurrentPage() {
  if (notePages.length === 0) return;
  
  const page = notePages[currentNotePage];
  loadNoteSections(page.sections);
}

// ノート項目を読み込み
function loadNoteSections(sections) {
  const container = document.getElementById('noteSectionsContainer');
  container.innerHTML = ''; // 既存の項目をクリア
  
  if (!sections || sections.length === 0) {
    // デフォルトの空項目を追加
    container.appendChild(createNoteSection());
    return;
  }
  
  sections.forEach(sectionData => {
    const section = createNoteSection(
      sectionData.title || '',
      sectionData.content || '',
      sectionData.images || []
    );
    container.appendChild(section);
  });
}

// ページナビゲーションを更新
function updatePageNavigation() {
  const pageIndicator = document.getElementById('pageIndicator');
  const pageTitleInput = document.getElementById('pageTitleInput');
  const prevBtn = document.getElementById('prevPage');
  const nextBtn = document.getElementById('nextPage');
  
  if (pageIndicator) {
    pageIndicator.textContent = `${currentNotePage + 1}/${notePages.length}`;
  }
  
  if (pageTitleInput && notePages.length > 0) {
    const currentPage = notePages[currentNotePage];
    pageTitleInput.value = currentPage.title || `ページ ${currentNotePage + 1}`;
    // ページ切り替え時にwidthを自動調整
    pageTitleInput.style.width = 'auto';
    pageTitleInput.style.width = pageTitleInput.scrollWidth + 'px';
  }
  
  if (prevBtn) {
    prevBtn.disabled = currentNotePage === 0;
    prevBtn.style.opacity = currentNotePage === 0 ? '0.5' : '1';
  }
  
  if (nextBtn) {
    nextBtn.disabled = currentNotePage >= notePages.length - 1;
    nextBtn.style.opacity = currentNotePage >= notePages.length - 1 ? '0.5' : '1';
  }
}

// ページを切り替え
function switchToPage(pageIndex) {
  if (pageIndex < 0 || pageIndex >= notePages.length) return;
  
  // 現在のページを保存
  saveNotePages();
  
  // ページを切り替え
  currentNotePage = pageIndex;
  
  // UIを更新
  updatePageNavigation();
  loadCurrentPage();
  
  console.log('[NOTE] Switched to page:', currentNotePage + 1);
}

// ページナビゲーションイベントハンドラーを設定
function setupPageNavigationHandlers() {
  const prevBtn = document.getElementById('prevPage');
  const nextBtn = document.getElementById('nextPage');
  const addPageBtn = document.getElementById('addPage');
  const deletePageBtn = document.getElementById('deletePage');
  const pageTitleInput = document.getElementById('pageTitleInput');
  
  if (prevBtn) {
    prevBtn.addEventListener('click', () => {
      if (currentNotePage > 0) {
        switchToPage(currentNotePage - 1);
      }
    });
  }
  
  if (nextBtn) {
    nextBtn.addEventListener('click', () => {
      if (currentNotePage < notePages.length - 1) {
        switchToPage(currentNotePage + 1);
      }
    });
  }
  
  if (addPageBtn) {
    addPageBtn.addEventListener('click', () => {
      addNewPage();
    });
  }
  
  if (deletePageBtn) {
    deletePageBtn.addEventListener('click', () => {
      deleteCurrentPage();
    });
  }
  
  if (pageTitleInput) {
    pageTitleInput.addEventListener('input', () => {
      if (notePages.length > 0 && currentNotePage < notePages.length) {
        notePages[currentNotePage].title = pageTitleInput.value.trim() || `ページ ${currentNotePage + 1}`;
        notePages[currentNotePage].lastModified = new Date().toISOString();
        saveNotePages();
      }
      // 文字数に応じてwidthを自動調整
      pageTitleInput.style.width = 'auto';
      pageTitleInput.style.width = pageTitleInput.scrollWidth + 'px';
    });
    
    // Enterキーでフォーカスを外す
    pageTitleInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        pageTitleInput.blur();
      }
    });
  }
}

// 新しいページを追加
function addNewPage() {
  const pageTitle = prompt('新しいページのタイトルを入力してください:', `ページ ${notePages.length + 1}`);
  if (!pageTitle || pageTitle.trim() === '') return;
  
  // 現在のページを保存
  saveNotePages();
  
  const newPage = {
    id: Date.now(),
    title: pageTitle.trim(),
    sections: [],
    lastModified: new Date().toISOString()
  };
  
  notePages.push(newPage);
  currentNotePage = notePages.length - 1;
  
  updatePageNavigation();
  loadCurrentPage();
  
  // 新しいページのタイトル入力フィールドにフォーカスを当てる
  setTimeout(() => {
    const pageTitleInput = document.getElementById('pageTitleInput');
    if (pageTitleInput) {
      pageTitleInput.focus();
      pageTitleInput.select();
    }
  }, 100);
  
  console.log('[NOTE] Added new page:', pageTitle);
}

// 現在のページを削除
function deleteCurrentPage() {
  if (notePages.length <= 1) {
    alert('最後のページは削除できません。');
    return;
  }
  
  const pageTitle = notePages[currentNotePage].title;
  if (!confirm(`ページ "${pageTitle}" を削除しますか？\nこの操作は取り消せません。`)) {
    return;
  }
  
  notePages.splice(currentNotePage, 1);
  
  if (currentNotePage >= notePages.length) {
    currentNotePage = notePages.length - 1;
  }
  
  updatePageNavigation();
  loadCurrentPage();
  
  console.log('[NOTE] Deleted page:', pageTitle);
}

// ノートページを出力
function exportNotePages() {
  if (notePages.length === 0) {
    alert('出力するデータがありません。');
    return;
  }
  
  // 現在のページを保存
  saveNotePages();
  
  const exportData = {
    version: '1.0',
    exportedAt: new Date().toISOString(),
    pages: notePages
  };
  
  const dataStr = JSON.stringify(exportData, null, 2);
  const dataBlob = new Blob([dataStr], { type: 'application/json' });
  const url = URL.createObjectURL(dataBlob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `note_pages_export_${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  
  console.log('[NOTE] Exported pages:', notePages.length);
}

// ノートページを読込（オプション選択ダイアログ）
function showImportOptionsDialog(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const importData = JSON.parse(e.target.result);
      
      if (!importData.pages || !Array.isArray(importData.pages)) {
        throw new Error('無効なファイル形式です。');
      }
      
      // 読込オプション選択ダイアログを作成
      const dialog = document.createElement('div');
      dialog.style.position = 'fixed';
      dialog.style.top = '0';
      dialog.style.left = '0';
      dialog.style.width = '100%';
      dialog.style.height = '100%';
      dialog.style.background = 'rgba(0,0,0,0.5)';
      dialog.style.display = 'flex';
      dialog.style.alignItems = 'center';
      dialog.style.justifyContent = 'center';
      dialog.style.zIndex = '10000';
      
      const dialogContent = document.createElement('div');
      dialogContent.style.background = 'rgba(0,0,0,0.9)';
      dialogContent.style.border = '1px solid rgba(255,255,255,0.3)';
      dialogContent.style.borderRadius = '8px';
      dialogContent.style.padding = '20px';
      dialogContent.style.maxWidth = '400px';
      dialogContent.style.width = '90%';
      
      const title = document.createElement('h3');
      title.textContent = '読込オプションを選択';
      title.style.margin = '0 0 16px 0';
      title.style.color = '#fff';
      
      const form = document.createElement('form');
      
      const options = [
        { value: 'replace', label: '完全置き換え: 現在のデータを読込データで完全に上書きします' },
        { value: 'merge', label: 'マージ追加: 読込データを新しいページとして追加します' },
        { value: 'preview', label: 'プレビュー表示: 読込データを確認のみ表示します（現在のデータに影響なし）' }
      ];
      
      options.forEach(option => {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.margin = '8px 0';
        label.style.color = '#fff';
        label.style.cursor = 'pointer';
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'importOption';
        radio.value = option.value;
        radio.style.marginRight = '8px';
        
        label.appendChild(radio);
        label.appendChild(document.createTextNode(option.label));
        form.appendChild(label);
      });
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.marginTop = '20px';
      buttonContainer.style.justifyContent = 'flex-end';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'キャンセル';
      cancelBtn.type = 'button';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'rgba(128,128,128,0.2)';
      cancelBtn.style.color = '#fff';
      cancelBtn.style.border = '1px solid #666';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.addEventListener('click', () => dialog.remove());
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = '実行';
      confirmBtn.type = 'submit';
      confirmBtn.style.padding = '8px 16px';
      confirmBtn.style.background = 'rgba(102,126,234,0.2)';
      confirmBtn.style.color = '#667eea';
      confirmBtn.style.border = '1px solid #667eea';
      confirmBtn.style.borderRadius = '4px';
      confirmBtn.style.cursor = 'pointer';
      
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(confirmBtn);
      
      form.appendChild(buttonContainer);
      
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        const selectedOption = form.querySelector('input[name="importOption"]:checked');
        if (!selectedOption) {
          alert('オプションを選択してください。');
          return;
        }
        
        const option = selectedOption.value;
        dialog.remove();
        
        if (option === 'replace') {
          importNotePages(importData, 'replace');
        } else if (option === 'merge') {
          importNotePages(importData, 'merge');
        } else if (option === 'preview') {
          previewImportData(importData);
        }
      });
      
      dialogContent.appendChild(title);
      dialogContent.appendChild(form);
      dialog.appendChild(dialogContent);
      document.body.appendChild(dialog);
      
    } catch (error) {
      alert('ファイルの読み込みに失敗しました: ' + error.message);
      console.error('[NOTE] Import dialog failed:', error);
    }
  };
  reader.readAsText(file);
}

// ノートページを読込（モード指定）
function importNotePages(importData, mode) {
  try {
    if (!importData.pages || !Array.isArray(importData.pages)) {
      throw new Error('無効な読込データです。');
    }
    
    // 現在のページを保存
    saveNotePages();
    
    if (mode === 'replace') {
      // 完全置き換え
      notePages = importData.pages.map(page => ({
        ...page,
        id: page.id || Date.now() + Math.random(), // IDがなければ新規生成
        lastModified: new Date().toISOString()
      }));
      currentNotePage = 0;
      console.log('[NOTE] Replaced all pages with imported data:', notePages.length);
      
    } else if (mode === 'merge') {
      // マージ追加（新しいページとして追加）
      const newPages = importData.pages.map(page => ({
        ...page,
        id: Date.now() + Math.random(), // 新しいIDを生成
        title: page.title + ' (読込)', // タイトルにマークを付ける
        lastModified: new Date().toISOString()
      }));
      notePages = notePages.concat(newPages);
      currentNotePage = notePages.length - newPages.length; // 最初の追加ページに移動
      console.log('[NOTE] Merged imported pages:', newPages.length, 'total pages:', notePages.length);
    }
    
    // UI更新
    updatePageNavigation();
    loadCurrentPage();
    
    // 保存
    saveNotePages();
    
    alert(mode === 'replace' ? 'ノートを完全に置き換えました。' : 'ノートをマージ追加しました。');
    
  } catch (error) {
    alert('インポートに失敗しました: ' + error.message);
    console.error('[NOTE] Import failed:', error);
  }
}

// 読込データをプレビュー表示
function previewImportData(importData) {
  try {
    if (!importData.pages || !Array.isArray(importData.pages)) {
      throw new Error('無効なインポートデータです。');
    }
    
    // プレビューモーダルを作成
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.8)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.zIndex = '10001';
    
    const modalContent = document.createElement('div');
    modalContent.style.background = 'rgba(0,0,0,0.95)';
    modalContent.style.border = '1px solid rgba(255,255,255,0.3)';
    modalContent.style.borderRadius = '8px';
    modalContent.style.padding = '20px';
    modalContent.style.maxWidth = '800px';
    modalContent.style.width = '90%';
    modalContent.style.maxHeight = '80vh';
    modalContent.style.overflowY = 'auto';
    
    const title = document.createElement('h3');
    title.textContent = '読込データプレビュー';
    title.style.margin = '0 0 16px 0';
    title.style.color = '#fff';
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '閉じる';
    closeBtn.style.padding = '8px 16px';
    closeBtn.style.background = 'rgba(128,128,128,0.2)';
    closeBtn.style.color = '#fff';
    closeBtn.style.border = '1px solid #666';
    closeBtn.style.borderRadius = '4px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.float = 'right';
    closeBtn.addEventListener('click', () => modal.remove());
    
    title.appendChild(closeBtn);
    
    const content = document.createElement('div');
    content.style.marginTop = '20px';
    
    // インポートデータの概要を表示
    const summary = document.createElement('div');
    summary.style.marginBottom = '20px';
    summary.style.padding = '10px';
    summary.style.background = 'rgba(255,255,255,0.1)';
    summary.style.borderRadius = '4px';
    summary.innerHTML = `
      <strong>バージョン:</strong> ${importData.version || '不明'}<br>
      <strong>出力日時:</strong> ${importData.exportedAt ? new Date(importData.exportedAt).toLocaleString('ja-JP') : '不明'}<br>
      <strong>ページ数:</strong> ${importData.pages.length}
    `;
    content.appendChild(summary);
    
    // 各ページの情報を表示
    importData.pages.forEach((page, index) => {
      const pageDiv = document.createElement('div');
      pageDiv.style.marginBottom = '20px';
      pageDiv.style.padding = '15px';
      pageDiv.style.border = '1px solid rgba(255,255,255,0.2)';
      pageDiv.style.borderRadius = '6px';
      
      const pageTitle = document.createElement('h4');
      pageTitle.textContent = `ページ ${index + 1}: ${page.title || '無題'}`;
      pageTitle.style.margin = '0 0 10px 0';
      pageTitle.style.color = '#fff';
      pageTitle.style.fontWeight = 'bold';
      
      const pageInfo = document.createElement('div');
      pageInfo.style.marginBottom = '15px';
      pageInfo.style.fontSize = '0.9em';
      pageInfo.style.color = 'rgba(255,255,255,0.8)';
      pageInfo.innerHTML = `
        <div style="margin-bottom: 5px;"><strong>項目数:</strong> ${page.sections ? page.sections.length : 0}</div>
        <div><strong>最終更新:</strong> ${page.lastModified ? new Date(page.lastModified).toLocaleString('ja-JP') : '不明'}</div>
      `;
      
      pageDiv.appendChild(pageTitle);
      pageDiv.appendChild(pageInfo);
      
      // セクションの詳細表示
      if (page.sections && page.sections.length > 0) {
        const sectionsContainer = document.createElement('div');
        sectionsContainer.style.marginTop = '10px';
        
        page.sections.forEach((section, secIndex) => {
          const sectionDiv = document.createElement('div');
          sectionDiv.style.marginBottom = '12px';
          sectionDiv.style.padding = '10px';
          sectionDiv.style.background = 'rgba(255,255,255,0.05)';
          sectionDiv.style.borderRadius = '4px';
          sectionDiv.style.border = '1px solid rgba(255,255,255,0.1)';
          
          const sectionTitle = document.createElement('div');
          sectionTitle.textContent = `項目 ${secIndex + 1}: ${section.title || '無題'}`;
          sectionTitle.style.fontWeight = 'bold';
          sectionTitle.style.color = '#fff';
          sectionTitle.style.marginBottom = '5px';
          
          const sectionContent = document.createElement('div');
          sectionContent.style.fontSize = '0.85em';
          sectionContent.style.color = 'rgba(255,255,255,0.7)';
          sectionContent.style.lineHeight = '1.4';
          sectionContent.textContent = section.content ? 
            (section.content.length > 100 ? section.content.substring(0, 100) + '...' : section.content) : 
            '内容なし';
          
          sectionDiv.appendChild(sectionTitle);
          sectionDiv.appendChild(sectionContent);
          sectionsContainer.appendChild(sectionDiv);
        });
        
        pageDiv.appendChild(sectionsContainer);
      } else {
        const noSections = document.createElement('div');
        noSections.textContent = '項目なし';
        noSections.style.fontSize = '0.9em';
        noSections.style.color = 'rgba(255,255,255,0.5)';
        noSections.style.fontStyle = 'italic';
        pageDiv.appendChild(noSections);
      }
      
      content.appendChild(pageDiv);
    });
    
    modalContent.appendChild(title);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    
    // モーダルを閉じるためのクリックイベント
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
    
    document.body.appendChild(modal);
    
    console.log('[NOTE] Preview modal opened for imported data');
    
  } catch (error) {
    alert('プレビュー表示に失敗しました: ' + error.message);
    console.error('[NOTE] Preview failed:', error);
  }
}

// ノートモーダルの保存とクリア機能
const saveNoteBtn = document.getElementById('saveNote');
const exportNoteBtn = document.getElementById('exportNote');
const importNoteBtn = document.getElementById('importNote');
const addNoteSectionBtn = document.getElementById('addNoteSection');

// 自動保存タイマー
let autoSaveTimer = null;

// ノート内容を自動保存する関数
const autoSaveNote = () => {
  if (isNoteModalOpen) {
    saveNotePages();
  }
};

// テキストエリアの入力イベントで自動保存をスケジュール
document.addEventListener('input', (e) => {
  if (e.target.closest('.note-section') && isNoteModalOpen) {
    // 既存のタイマーをクリア
    if (autoSaveTimer) {
      clearTimeout(autoSaveTimer);
    }
    // 3秒後に自動保存
    autoSaveTimer = setTimeout(() => {
      autoSaveNote();
    }, 3000);
  }
});

if (saveNoteBtn) {
  saveNoteBtn.addEventListener('click', () => {
    saveNotePages();
    alert('ノートを保存しました');
    // タイマーをクリア
    if (autoSaveTimer) {
      clearTimeout(autoSaveTimer);
    }
  });
}

if (exportNoteBtn) {
  exportNoteBtn.addEventListener('click', () => {
    exportNotePages();
  });
}

if (importNoteBtn) {
  importNoteBtn.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        showImportOptionsDialog(file);
      }
    });
    input.click();
  });
}



if (addNoteSectionBtn) {
  addNoteSectionBtn.addEventListener('click', () => {
    const container = document.getElementById('noteSectionsContainer');
    container.appendChild(createNoteSection());
    // 新しいセクションをスクロールして表示
    setTimeout(() => {
      const newSection = container.lastElementChild;
      if (newSection) {
        newSection.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }
    }, 100);
  });
}

// ノートフォントサイズドロップダウンのイベントリスナー
const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
if (noteFontSizeSelect) {
  noteFontSizeSelect.addEventListener('change', (e) => {
    const selectedSize = e.target.value;
    localStorage.setItem('tv_note_font_size', selectedSize);
    applyNoteFontSize(selectedSize);
  });
}  // ノートモーダルを閉じるときにサイズと位置を保存
  const saveNoteModalState = () => {
    if (noteModal) {
      const rect = noteModal.getBoundingClientRect();
      localStorage.setItem('tv_note_modal_width', rect.width);
      localStorage.setItem('tv_note_modal_height', rect.height);
      localStorage.setItem('tv_note_modal_left', noteModal.style.left || '50%');
      localStorage.setItem('tv_note_modal_top', noteModal.style.top || '50%');
    }
    // クローズ時にノート内容も自動保存
    saveNotePages();
  };

  if (closeNoteBtn && noteModal) {
    closeNoteBtn.addEventListener('click', () => {
      saveNoteModalState();
      noteOverlay.style.display = 'none';
      isNoteModalOpen = false;
    });
  }

  // オーバーレイクリックでもサイズと位置を保存
  if (noteOverlay && noteModal) {
    noteOverlay.addEventListener('click', (e) => {
      if (e.target === noteOverlay && !isResizingNote && !isDraggingNote) {
        saveNoteModalState();
        noteOverlay.style.display = 'none';
        isNoteModalOpen = false;
      }
    });
  }

  console.log('[INIT] All event listeners setup complete');
}

// 通貨名マッピング（サーバー側と同じ）
const currencyNames = {
  'USDJPY': 'ドル円',
  'EURUSD': 'ユーロドル',
  'GBPUSD': 'ポンドドル',
  'GBPJPY': 'ポンド円',
  'AUDUSD': 'オージードル',
  'AUDJPY': 'オージー円',
  'NZDUSD': 'ニュージードル',
  'NZDJPY': 'ニュージー円',
  'CADJPY': 'カナダ円',
  'CHFJPY': 'スイス円',
  'EURJPY': 'ユーロ円',
  'GBPAUD': 'ポンドオージー',
  'EURGBP': 'ユーロポンド',
  'USDCAD': 'ドルカナダ',
  'USDCHF': 'ドルスイス'
};

// グローバル変数: Socket.IOコネクション
let socket = null;

// グローバル変数: 現在のダッシュボードデータ（テスト時に使用）
let currentDashboardData = null;

// グローバル変数: 最終WebSocket更新時刻を追跡
let lastWebSocketUpdate = Date.now();

// グローバル変数: 全ルールデータ（ルールカウントボタン用）
let allRules = [];

// 設定パネルの動作: モード切替（body にクラス付与）とフォントサイズの適用
function applyMode(mode) {
  document.body.classList.remove('light-mode','dark-mode');
  if (mode === 'light') {
    document.body.classList.add('light-mode');
    // テーブルを完全ホワイト背景にする
    const tables = document.querySelectorAll('table');
    tables.forEach(table => {
      table.style.background = '#ffffff';
    });
    
    // ページナビゲーションのスタイル適用（ライトモード）
    const pageIndicator = document.getElementById('pageIndicator');
    if (pageIndicator) {
      pageIndicator.style.color = '#000000'; // 黒文字
    }
    
    // ノートモーダルのボタンスタイルをライトモードに統一
    document.querySelectorAll('#addPage, #deletePage, #addNoteSection, #saveNote, #exportNote, #importNote, #closeNote').forEach(btn => {
      btn.style.background = '#ffffff';
      btn.style.color = '#000000';
      btn.style.borderColor = '#000000';
    });
    
    // ノートフォントサイズドロップダウンもライトモードに
    const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
    if (noteFontSizeSelect) {
      noteFontSizeSelect.style.background = '#ffffff';
      noteFontSizeSelect.style.color = '#000000';
      noteFontSizeSelect.style.borderColor = '#000000';
    }
    
    // ページタイトル入力ボックスもボタンと同じスタイルに
    const pageTitleInput = document.getElementById('pageTitleInput');
    if (pageTitleInput) {
      pageTitleInput.style.background = '#ffffff';
      pageTitleInput.style.color = '#000000';
      pageTitleInput.style.borderColor = '#000000';
      pageTitleInput.style.minWidth = '200px';
      pageTitleInput.style.width = 'auto';
      pageTitleInput.style.maxWidth = '500px';
    }
  } else {
    document.body.classList.add('dark-mode');
    // テーブル背景をリセット
    const tables = document.querySelectorAll('table');
    tables.forEach(table => {
      table.style.background = '';
    });
    
    // ページナビゲーションのスタイル適用（ダークモード）
    const pageIndicator = document.getElementById('pageIndicator');
    if (pageIndicator) {
      pageIndicator.style.color = 'rgba(255,255,255,0.8)'; // 白文字
    }
    
    // ノートモーダルのボタンスタイルをダークモードに統一
    document.querySelectorAll('#addPage, #deletePage, #addNoteSection, #saveNote, #exportNote, #importNote, #closeNote').forEach(btn => {
      btn.style.background = 'rgba(0,0,0,0.2)';
      btn.style.color = '#ffffff';
      btn.style.borderColor = '#ffffff';
    });
    
    // ノートフォントサイズドロップダウンもダークモードに
    const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
    if (noteFontSizeSelect) {
      noteFontSizeSelect.style.background = 'rgba(0,0,0,0.2)';
      noteFontSizeSelect.style.color = '#ffffff';
      noteFontSizeSelect.style.borderColor = '#ffffff';
    }
    
    // ページタイトル入力ボックスもボタンと同じスタイルに
    const pageTitleInput = document.getElementById('pageTitleInput');
    if (pageTitleInput) {
      pageTitleInput.style.background = 'rgba(0,0,0,0.2)';
      pageTitleInput.style.color = '#ffffff';
      pageTitleInput.style.borderColor = '#ffffff';
      pageTitleInput.style.minWidth = '200px';
      pageTitleInput.style.width = 'auto';
      pageTitleInput.style.maxWidth = '500px';
    }
  }
}

function applyFontSize(px) {
  // テーブルの th と td にのみフォントサイズを適用（セルの色は変更しない）
  const els = document.querySelectorAll('table th, table td');
  els.forEach(el => {
    el.style.fontSize = px + 'px';
  });
  
  // 発火履歴ウィンドウの全要素にフォントサイズを適用
  const fireHistoryEls = document.querySelectorAll('.currency-fire-history h3, .currency-fire-history button, .fire-item, .fire-time, .fire-name, .fire-direction, .currency-fire-history-list');
  fireHistoryEls.forEach(el => {
    el.style.fontSize = px + 'px';
  });
  
  // 発火履歴ウィンドウの横幅を文字サイズに合わせて調整
  // 基本: 300px (14px時) + 追加幅
  const baseFontSize = 14;
  const additionalWidth = Math.max(0, (px - baseFontSize) * 8); // 文字サイズが1px増えるごとに8px横幅を増やす
  const newWidth = 300 + additionalWidth;
  
  const fireHistories = document.querySelectorAll('.currency-fire-history');
  fireHistories.forEach(fh => {
    fh.style.minWidth = newWidth + 'px';
  });
}

function applyNoteFontSize(px) {
  // ノートセクションのタイトルとコンテンツにフォントサイズを適用
  const noteTitles = document.querySelectorAll('.note-section-title');
  const noteContents = document.querySelectorAll('.note-section-content');
  
  noteTitles.forEach(title => {
    title.style.fontSize = px + 'px';
  });
  
  noteContents.forEach(content => {
    content.style.fontSize = px + 'px';
  });
}

function applyColumnVisibility() {
  const cols = document.querySelectorAll('.col-toggle');
  cols.forEach(cb => {
    const colIndex = parseInt(cb.dataset.col);
    const visible = cb.checked;
    // colIndex は 1-indexed（雲整列は0列目、ダウ転は1列目...）
    const selector = `table th:nth-child(${colIndex + 1}), table td:nth-child(${colIndex + 1})`;
    document.querySelectorAll(selector).forEach(el => {
      el.style.display = visible ? '' : 'none';
    });
  });
}

function applyRowVisibility() {
  const rows = document.querySelectorAll('.row-toggle');
  rows.forEach(cb => {
    const rowLabel = cb.dataset.row;
    const visible = cb.checked;
    // 各行は tf-label セルの textContent で識別
    const allRows = document.querySelectorAll('table tr');
    allRows.forEach(tr => {
      const labelCell = tr.querySelector('.tf-label');
      if (labelCell) {
        const text = labelCell.textContent.trim();
        if ((rowLabel === 'price' && text === '価格') ||
            (rowLabel === '5m' && text === '5m') ||
            (rowLabel === '15m' && text === '15m') ||
            (rowLabel === '1H' && text === '1H') ||
            (rowLabel === '4H' && text === '4H')) {
          tr.style.display = visible ? '' : 'none';
        }
      }
    });
  });
}

function applyCurrencyFilter() {
  const currencies = document.querySelectorAll('.currency-toggle');
  const enabled = new Set();
  currencies.forEach(cb => {
    if (cb.checked) enabled.add(cb.dataset.currency);
  });
  
  // 通貨ごとのセクションを表示/非表示
  document.querySelectorAll('.currency-section').forEach(section => {
    const symbol = section.dataset.symbol;
    if (enabled.has(symbol)) {
      section.classList.remove('hidden');
    } else {
      section.classList.add('hidden');
    }
  });
}

function updateCurrencyFilter(availableCurrencies) {
  const container = document.getElementById('currencyFilterContainer');
  const savedCurrencies = JSON.parse(localStorage.getItem('tv_currencies') || '{}');
  
  // 既存のチェックボックスの通貨を記録
  const existingCurrencies = new Set();
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    existingCurrencies.add(cb.dataset.currency);
  });
  
  // 新しい通貨があれば追加
  availableCurrencies.forEach(currency => {
    if (!existingCurrencies.has(currency)) {
      const label = document.createElement('label');
      label.style.fontSize = '0.9em';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'currency-toggle';
      checkbox.dataset.currency = currency;
      checkbox.checked = (savedCurrencies[currency] !== false); // デフォルトtrue
      
      checkbox.addEventListener('change', async () => {
        const currencies = {};
        document.querySelectorAll('.currency-toggle').forEach(cb => {
          currencies[cb.dataset.currency] = cb.checked;
        });
        localStorage.setItem('tv_currencies', JSON.stringify(currencies));
        applyCurrencyFilter();
        await load(); // テーブル再描画
      });
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(' ' + currency));
      container.appendChild(label);
    }
  });
  
  // 保存された設定を適用
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    const currency = cb.dataset.currency;
    cb.checked = (savedCurrencies[currency] !== false);
  });
  
  applyCurrencyFilter();
}

function loadSettings() {
  const savedMode = localStorage.getItem('tv_mode') || 'dark';
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  const savedCols = JSON.parse(localStorage.getItem('tv_cols') || '{}');
  const savedRows = JSON.parse(localStorage.getItem('tv_rows') || '{}');
  const savedTimeFormat = localStorage.getItem('tv_time_format') || 'datetime';
  const savedEnable5mUpdate = localStorage.getItem('tv_enable_5m_update') !== 'false'; // デフォルトtrue
  const savedVoiceVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
  const savedVoiceRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
  
  // set UI
  document.getElementById('modeDark').checked = (savedMode === 'dark');
  document.getElementById('modeLight').checked = (savedMode === 'light');
  document.getElementById('fontSizeSelect').value = savedSize;
  document.getElementById('timeFormatSelect').value = savedTimeFormat;
  document.getElementById('enable5mUpdateToggle').checked = savedEnable5mUpdate;
  document.getElementById('voiceVolume').value = savedVoiceVolume;
  document.getElementById('voiceVolumeValue').textContent = Math.round(savedVoiceVolume * 100) + '%';
  document.getElementById('voiceRate').value = savedVoiceRate;
  document.getElementById('voiceRateValue').textContent = savedVoiceRate.toFixed(1) + 'x';
  
  // 列チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    const col = cb.dataset.col;
    cb.checked = (savedCols[col] !== false); // デフォルトtrue
  });
  
  // 行チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    const row = cb.dataset.row;
    cb.checked = (savedRows[row] !== false); // デフォルトtrue
  });
  
  applyMode(savedMode);
  applyFontSize(savedSize);
  applyColumnVisibility();
  applyRowVisibility();
  
  // ノートフォントサイズの設定を読み込み
  const savedNoteFontSize = localStorage.getItem('tv_note_font_size') || '15';
  const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
  if (noteFontSizeSelect) {
    noteFontSizeSelect.value = savedNoteFontSize;
  }
  applyNoteFontSize(savedNoteFontSize);
}

function wireSettings() {
  document.getElementById('modeDark').addEventListener('change', async e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','dark'); applyMode('dark'); await load(); }
  });
  document.getElementById('modeLight').addEventListener('change', async e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','light'); applyMode('light'); await load(); }
  });
  document.getElementById('fontSizeSelect').addEventListener('change', async e => {
    localStorage.setItem('tv_font_size', e.target.value);
    applyFontSize(e.target.value);
    await load(); // テーブル再描画
  });
  
  // 列表示チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    cb.addEventListener('change', async () => {
      const cols = {};
      document.querySelectorAll('.col-toggle').forEach(c => {
        cols[c.dataset.col] = c.checked;
      });
      localStorage.setItem('tv_cols', JSON.stringify(cols));
      applyColumnVisibility();
      await load(); // テーブル再描画
    });
  });
  
  // 行表示チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    cb.addEventListener('change', async () => {
      const rows = {};
      document.querySelectorAll('.row-toggle').forEach(r => {
        rows[r.dataset.row] = r.checked;
      });
      localStorage.setItem('tv_rows', JSON.stringify(rows));
      applyRowVisibility();
      await load(); // テーブル再描画
    });
  });
  
  // 経過時間形式プルダウン
  document.getElementById('timeFormatSelect').addEventListener('change', e => {
    localStorage.setItem('tv_time_format', e.target.value);
    load(); // 再読み込みして表示を更新
  });
  
  // 5分毎更新トグル
  document.getElementById('enable5mUpdateToggle').addEventListener('change', e => {
    localStorage.setItem('tv_enable_5m_update', e.target.checked.toString());
  });
  
  // 音声設定（グローバル）
  document.getElementById('voiceVolume').addEventListener('input', e => {
    const vol = parseFloat(e.target.value);
    document.getElementById('voiceVolumeValue').textContent = Math.round(vol * 100) + '%';
    localStorage.setItem('tv_voice_volume', vol.toString());
  });
  document.getElementById('voiceRate').addEventListener('input', e => {
    const rate = parseFloat(e.target.value);
    document.getElementById('voiceRateValue').textContent = rate.toFixed(1) + 'x';
    localStorage.setItem('tv_voice_rate', rate.toString());
  });
}

function wireSectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_sections') || '{}');
    document.querySelectorAll('.section-header').forEach(header => {
      const sec = header.dataset.section;
      const body = document.querySelector(`.section-body[data-section-body="${sec}"]`);
      if (!body) return;
      
      // 既存のリスナーを削除（複数登録を防ぐ）
      const newHeader = header.cloneNode(true);
      header.parentNode.replaceChild(newHeader, header);
      header = newHeader;
      
      const expanded = (saved[sec] !== undefined) ? !!saved[sec] : true;
      if (expanded) {
        header.classList.add('active');
        body.classList.add('active');
      } else {
        header.classList.remove('active');
        body.classList.remove('active');
      }
      
      // クリックイベントを処理（子要素がクリックされても反応）
      header.addEventListener('click', (e) => {
        // selectクリックは無視（言語選択に干渉しないため）
        if (e.target.tagName === 'SELECT') {
          e.stopPropagation();
          return;
        }
        
        const cur = header.classList.contains('active');
        const next = !cur;
        if (next) {
          header.classList.add('active');
          body.classList.add('active');
        } else {
          header.classList.remove('active');
          body.classList.remove('active');
        }
        const s = JSON.parse(localStorage.getItem('tv_sections') || '{}');
        s[sec] = next;
        localStorage.setItem('tv_sections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSectionToggles error', e);
  }
}

// Wire subsection toggles (for saved rules and rule editor)
function wireSubsectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
    // Handle both savedRules and ruleEditor subsections
    ['savedRules', 'ruleEditor'].forEach(subsec => {
      const header = document.querySelector(`.subsection-header[data-subsection="${subsec}"]`);
      if (!header) return;
      const body = document.querySelector(`.subsection-body[data-subsection-body="${subsec}"]`);
      if (!body) return;
      const expanded = (saved[subsec] !== undefined) ? !!saved[subsec] : true;
      if (expanded) {
        header.classList.add('active');
        body.classList.add('active');
      } else {
        header.classList.remove('active');
        body.classList.remove('active');
      }
      header.addEventListener('click', () => {
        const cur = header.classList.contains('active');
        const next = !cur;
        if (next) {
          header.classList.add('active');
          body.classList.add('active');
        } else {
          header.classList.remove('active');
          body.classList.remove('active');
        }
        const s = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
        s[subsec] = next;
        localStorage.setItem('tv_subsections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSubsectionToggles error', e);
  }
}

// Populate the rule scope select (通貨選択) with available currencies
function populateRuleScopeSelect(availableCurrencies) {
  try {
    const sel = document.getElementById('ruleScope');
    if (!sel) return;
    const cur = sel.value;
    // Always keep the default '全選択' option
    sel.innerHTML = '';
    const optAll = document.createElement('option'); optAll.value = ''; optAll.textContent = '全選択'; sel.appendChild(optAll);
    (availableCurrencies || []).forEach(sym => {
      const o = document.createElement('option'); o.value = sym; o.textContent = sym; sel.appendChild(o);
    });
    // restore previous selection if still present
    if (cur && [...sel.options].some(o => o.value === cur)) sel.value = cur;
  } catch (e) { console.log('populateRuleScopeSelect error', e); }
}

// Populate voice select with available voices
function populateVoiceSelect() {
  if (!('speechSynthesis' in window)) {
    console.log('[VOICE] speechSynthesis not supported');
    return;
  }
  
  const select = document.getElementById('voiceSelect');
  if (!select) {
    console.log('[VOICE] voiceSelect element not found');
    return;
  }
  const currentValue = select.value;
  
  // 選択肢をクリア
  select.innerHTML = '';
  
  const voices = speechSynthesis.getVoices();
  console.log('[VOICE] Total voices available:', voices.length);
  
  const allowedVoices = {
    'Microsoft 七海 Online (Natural) - Japanese (Japan)': '七海［女性］',
    'Microsoft 圭太 Online (Natural) - Japanese (Japan)': '圭太［男性］',
    'Microsoft 碧衣 Online (Natural) - Japanese (Japan)': '碧衣［女性］',
    'Microsoft 大智 Online (Natural) - Japanese (Japan)': '大智［男性］',
    'Microsoft 真夕 Online (Natural) - Japanese (Japan)': '真夕［女性］',
    'Microsoft 直紀 Online (Natural) - Japanese (Japan)': '直紀［男性］',
    'Microsoft 志織 Online (Natural) - Japanese (Japan)': '志織［女性］'
  };
  
  let addedCount = 0;
  voices.forEach(voice => {
    console.log('[VOICE] Checking voice:', voice.name, 'lang:', voice.lang);
    if (voice.lang.startsWith('ja') && allowedVoices[voice.name]) {
      const option = document.createElement('option');
      option.value = voice.name;
      option.textContent = allowedVoices[voice.name];
      select.appendChild(option);
      addedCount++;
      console.log('[VOICE] Added:', allowedVoices[voice.name]);
    }
  });
  
  console.log('[VOICE] Total voices added:', addedCount);
  
  // Restore previous selection if it still exists
  if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
    select.value = currentValue;
  }
}

// Populate chime select with available chime files
async function populateChimeSelect() {
  const select = document.getElementById('chimeSelect');
  if (!select) return;
  const currentValue = select.value;
  
  select.innerHTML = '<option value="">なし</option>';
  
  try {
    const response = await fetch('/api/chime_files');
    if (!response.ok) {
      throw new Error('HTTP ' + response.status);
    }
    const data = await response.json();
    if (data.status === 'success') {
      data.files.forEach(file => {
        const option = document.createElement('option');
        option.value = file;
        option.textContent = file.replace('.mp3', '');
        select.appendChild(option);
      });
    } else {
      throw new Error('Invalid response status');
    }
  } catch (e) {
    console.log('Error fetching chime files:', e);
    // Fallback to static list
    const chimeFiles = [
      'お寺の鐘.mp3',
      'きらきら輝く6.mp3',
      'ほら貝を吹き鳴らす.mp3',
      'ドンドンパフパフ.mp3',
      'ラッパのファンファーレ.mp3',
      'レベルアップ.mp3',
      '放送開始チャイム.mp3',
      '教会の鐘2.mp3',
      '歓声と拍手.mp3',
      '決定ボタンを押す4.mp3',
      '決定ボタンを押す5.mp3',
      '男衆「イエーイ！」.mp3',
      '男衆「イヤッホー！」.mp3',
      '突撃ラッパ.mp3',
      '警報が鳴る.mp3',
      '開演ブザー.mp3'
    ];
    chimeFiles.forEach(file => {
      const option = document.createElement('option');
      option.value = file;
      option.textContent = file.replace('.mp3', '');
      select.appendChild(option);
    });
  }
  
  // Restore previous selection if it still exists
  if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
    select.value = currentValue;
  }
}

// 初期化: 設定を読み込み、UI を配線
document.addEventListener('DOMContentLoaded', async () => {
  try { 
    // Socket.IO 初期化
    socket = io();
    
    // Socket.IO イベントハンドラー
    socket.on('connect', () => {
      console.log('[SOCKET] Connected:', socket.id);
    });
    
    socket.on('disconnect', () => {
      console.log('[SOCKET] Disconnected');
    });
    
    socket.on('reconnect', () => {
      console.log('[SOCKET] Reconnected');
    });
    
    // リアルタイムデータ更新イベント（複数のイベント名に対応）
    socket.on('update_table', async (data) => {
      console.log('[SOCKET] Received update_table:', data);
      lastWebSocketUpdate = Date.now(); // WebSocket更新時刻を記録
      // テーブル再描画
      await load();
    });
    
    socket.on('current_state_update', async (data) => {
      console.log('[SOCKET] Received current_state_update:', data);
      lastWebSocketUpdate = Date.now(); // WebSocket更新時刻を記録
      // テーブル再描画
      await load();
    });
    
    // 新しい通知をリアルタイムで受信
    socket.on('new_notification', async (notification) => {
      console.log('[SOCKET] Received new_notification:', notification);
      
      // Update timestamp to prevent duplicate processing
      lastNotificationTimestamp = notification.timestamp;
      
      // 通知を即座に再生
      await playNotification(notification);
      
      // 発火履歴に即座に追加(APIを待たずに)
      addNotificationToHistory(notification);
      
      // 通知リストの更新はポーリングに任せるため、setTimeoutを削除
    });
    
    // 市場ステータス更新
    async function updateMarketStatus() {
      try {
        const res = await fetch('/api/market_status');
        const data = await res.json();
        if (data.status === 'success') {
          const marketOpen = data.market_open;
          const statusLight = document.getElementById('marketStatusLight');
          const statusText = document.getElementById('marketStatusText');
          
          if (marketOpen) {
            statusLight.style.background = '#90EE90';  // 緑
            statusText.textContent = '営業中';
          } else {
            statusLight.style.background = '#FFB6C6';  // 赤ピンク
            statusText.textContent = '休場中';
          }
        }
      } catch (e) {
        console.log('[MARKET_STATUS] Error:', e);
      }
    }
    
    // 日本時間でリアルタイム時間更新関数
    function updateDateTimeDisplay() {
      const now = new Date();
      // 日本時間（JST）に変換
      const jstTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' }));
      
      // 令和年号を計算（2019年が令和元年）
      const wareki = jstTime.getFullYear() - 2018;
      const year = jstTime.getFullYear();
      const month = String(jstTime.getMonth() + 1).padStart(2, '0');
      const day = String(jstTime.getDate()).padStart(2, '0');
      
      // 曜日を取得
      const daysOfWeek = ['日', '月', '火', '水', '木', '金', '土'];
      const dayOfWeek = daysOfWeek[jstTime.getDay()];
      
      const hours = String(jstTime.getHours()).padStart(2, '0');
      const minutes = String(jstTime.getMinutes()).padStart(2, '0');
      const seconds = String(jstTime.getSeconds()).padStart(2, '0');
      
      // HTML要素を更新
      const dateSmall = document.querySelector('.datetime-small');
      const timeLarge = document.querySelector('.datetime-large');
      
      if (dateSmall) {
        dateSmall.textContent = year + ' R' + wareki + ' ' + month + '/' + day + ' ' + dayOfWeek;
      }
      if (timeLarge) {
        timeLarge.textContent = hours + ':' + minutes + ':' + seconds;
      }
    }
    
    // 初期表示
    updateDateTimeDisplay();
    // 毎秒更新
    setInterval(updateDateTimeDisplay, 1000);
    
    // 初期更新
    updateMarketStatus();
    // 定期更新（30秒ごと）
    setInterval(updateMarketStatus, 30000);
    
    loadSettings(); 
    wireSettings(); 
    wireSectionToggles(); 
    wireSubsectionToggles();
    
    // Initialize calendar language selector
    const savedCalendarLang = localStorage.getItem('tv_calendar_lang') || 'ja';
    const calendarLangSelect = document.getElementById('calendar-lang-select');
    if (calendarLangSelect) {
      calendarLangSelect.value = savedCalendarLang;
      // Update iframe src on initialization
      const iframe = document.querySelector('#economic-calendar-section iframe');
      if (iframe) {
        const currentSrc = iframe.src;
        const newSrc = currentSrc.replace(/lang=[^&]*/, 'lang=' + savedCalendarLang);
        iframe.src = newSrc;
      }
    }
    
    // Initialize calendar visibility
    const savedCalendarVisible = localStorage.getItem('tv_calendar_visible') !== 'false';
    const calendarSection = document.getElementById('economic-calendar-section');
    const calendarVisibilityRadios = document.querySelectorAll('input[name="calendar-visibility"]');
    if (savedCalendarVisible) {
      calendarSection.classList.remove('hidden');
      calendarVisibilityRadios.forEach(radio => {
        if (radio.value === 'show') radio.checked = true;
      });
    } else {
      calendarSection.classList.add('hidden');
      calendarVisibilityRadios.forEach(radio => {
        if (radio.value === 'hide') radio.checked = true;
      });
    }
    
    // Populate chime select
    await populateChimeSelect();
    
    // Populate voices when available (for browsers that load voices asynchronously)
    if ('speechSynthesis' in window) {
      // 初回実行
      populateVoiceSelect();
      
      // 音声リストが後から読み込まれる場合に備えて
      if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = () => {
          console.log('[VOICE] Voices changed event fired');
          populateVoiceSelect();
        };
      }
      
      // Chrome等では最初のgetVoices()呼び出しで空になることがあるため、
      // 少し待ってから再度実行
      setTimeout(() => {
        console.log('[VOICE] Delayed populate attempt');
        populateVoiceSelect();
      }, 100);
    }

    // 初期読み込みと定期的な更新
    await load();
    scheduleNextUpdate();

    // Rules UI 初期化
    await loadRules();
    
    // すべてのイベントリスナーを設定（ルールUI要素が追加された後に実行）
    setupAllEventListeners();

    // Notification polling initialization (moved from separate DOMContentLoaded listener)
    const REQUIRED_VERSION = '2025-11-11-v1';
    const currentVersion = localStorage.getItem('app_version');
    if (currentVersion === REQUIRED_VERSION && !notificationPollingStarted) {
      notificationPollingStarted = true;
      
      const instanceId = Math.random().toString(36).substr(2, 9);
      console.log('[NOTIFICATIONS] Instance ID: ' + instanceId + ' - Page loaded - Version: ' + REQUIRED_VERSION);
      
      // Function to get current polling interval (in milliseconds)
      // Base interval: 5 minutes (300 seconds) + update delay offset
      const getPollingInterval = () => {
        const delaySecs = parseInt(localStorage.getItem('tv_update_delay') || '10');
        const baseInterval = 300; // 5 minutes in seconds
        const totalSeconds = baseInterval + delaySecs;
        return totalSeconds * 1000; // Convert to milliseconds
      };
      
      // Function to start polling
      const startNotificationPolling = () => {
        if (notificationCheckInterval) {
          console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Clearing existing polling interval ' + notificationCheckInterval);
          clearInterval(notificationCheckInterval);
          notificationCheckInterval = null;
        }

        const intervalMs = getPollingInterval();
        const intervalSecs = intervalMs / 1000;
        const mins = Math.floor(intervalSecs / 60);
        const secs = Math.floor(intervalSecs % 60);
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Starting polling with interval: ' + intervalMs + 'ms (' + mins + 'm ' + secs + 's)');
        checkNotifications(); // Initial check
        notificationCheckInterval = setInterval(checkNotifications, intervalMs);
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Timer ID: ' + notificationCheckInterval);
      };
      
      // Function to stop polling
      const stopNotificationPolling = () => {
        if (notificationCheckInterval) {
          console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Stopping polling');
          clearInterval(notificationCheckInterval);
          notificationCheckInterval = null;
        }
      };
      
      // Function to restart polling with new interval
      const restartNotificationPolling = () => {
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Restarting polling');
        stopNotificationPolling();
        startNotificationPolling();
      };
      
      // Start polling when page is visible
      startNotificationPolling();
      
      // Stop/resume polling when page visibility changes
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page hidden, stopping');
          stopNotificationPolling();
          // Also clear update timer when page is hidden
          if (updateTimer) {
            console.log('[TIMER] Page hidden, clearing timer');
            clearTimeout(updateTimer);
            updateTimer = null;
          }
        } else {
          console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page visible, resuming');
          startNotificationPolling();
          // Reschedule update timer when page becomes visible
          console.log('[TIMER] Page visible, rescheduling update');
          scheduleNextUpdate();
        }
      });
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page unloading, cleanup');
        stopNotificationPolling();
        notificationPollingStarted = false;
      });
    } else if (currentVersion !== REQUIRED_VERSION) {
      console.log('[NOTIFICATIONS] Version mismatch, skipping notification polling');
    }

    // Setup calendar visibility toggle
    setTimeout(() => {
      const calendarVisibilityRadios = document.querySelectorAll('input[name="calendar-visibility"]');
      console.log('[CALENDAR] Setting up visibility toggle, found radios:', calendarVisibilityRadios.length);
      calendarVisibilityRadios.forEach(radio => {
        radio.addEventListener('change', (e) => {
          console.log('[CALENDAR] Visibility changed to:', e.target.value);
          const calendarSection = document.getElementById('economic-calendar-section');
          if (e.target.value === 'hide') {
            calendarSection.classList.add('hidden');
            localStorage.setItem('tv_calendar_visible', 'false');
            console.log('[CALENDAR] Hidden class added');
          } else {
            calendarSection.classList.remove('hidden');
            localStorage.setItem('tv_calendar_visible', 'true');
            console.log('[CALENDAR] Hidden class removed');
          }
        });
      });
    }, 100);

  } catch (err) { console.log('settings init error', err); }
});

// 経過時間変換関数
function formatElapsedTime(datetimeStr, format) {
  if (!datetimeStr || datetimeStr === '-' || datetimeStr === '') return '-';
  
  // format === 'datetime' の場合はそのまま返す
  if (format === 'datetime') return datetimeStr;
  
  console.log('formatElapsedTime called:', datetimeStr, 'format:', format);
  
  // datetimeStr をパースして経過時間（分）を計算
  // 想定形式: "YY/MM/DD/HH:MM" (例: "25/10/31/21:35")
  try {
    const now = new Date();
    const segments = datetimeStr.trim().split('/');
    
    if (segments.length < 4) {
      console.log('Invalid format, expected YY/MM/DD/HH:MM, got:', segments);
      return datetimeStr;
    }
    
    // YY/MM/DD/HH:MM 形式をパース
    const year = 2000 + parseInt(segments[0], 10); // YY を YYYY に変換
    const month = parseInt(segments[1], 10) - 1; // 0-indexed
    const day = parseInt(segments[2], 10);
    
    // 時間部分を処理 (HH:MM)
    const timePart = segments[3]; // "HH:MM"
    const timeSegments = timePart.split(':');
    
    if (timeSegments.length < 2) {
      console.log('Invalid time format:', timePart);
      return datetimeStr;
    }
    
    const hour = parseInt(timeSegments[0], 10);
    const minute = parseInt(timeSegments[1], 10);
    
    const startTime = new Date(year, month, day, hour, minute);
    const elapsedMs = now - startTime;
    const elapsedMinutes = Math.floor(elapsedMs / 60000);
    
    // 5分刻みに丸める
    const roundedElapsedMinutes = Math.floor(elapsedMinutes / 5) * 5;
    
    console.log('Parsed:', { year, month, day, hour, minute, elapsedMinutes, roundedElapsedMinutes });
    
    if (elapsedMinutes < 0) {
      console.log('Negative elapsed time');
      return datetimeStr; // 未来の日時は元の文字列
    }
    
    if (format === 'm') {
      // 分のみ: "7320m"
      return roundedElapsedMinutes + 'm';
    } else if (format === 'hm') {
      // 時/分: "122:00" または "05:00"
      const hours = Math.floor(roundedElapsedMinutes / 60);
      const mins = roundedElapsedMinutes % 60;
      return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    } else if (format === 'dhm') {
      // 日/時/分: "05/02:00"
      const days = Math.floor(roundedElapsedMinutes / 1440);
      const remainMins = roundedElapsedMinutes % 1440;
      const hours = Math.floor(remainMins / 60);
      const mins = remainMins % 60;
      return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    }
    
    return datetimeStr;
  } catch (e) {
    console.error('formatElapsedTime error:', e, 'input:', datetimeStr);
    return datetimeStr;
  }
}

function calculateTransferTimeDiff(cloud) {
  const dautenTimeStr = cloud.dauten_start_time_str;
  const crossTimeStr = cloud.elapsed_str;
  if (!dautenTimeStr || !crossTimeStr || dautenTimeStr === '-' || crossTimeStr === '-') return { diff: null, sameDirection: false };
  
  const dautenDir = cloud.dauten; // 'up' or 'down'
  const crossDir = cloud.gc; // true or false
  
  // 同方向チェック: dauten 'up' matches gc true (GC), dauten 'down' matches gc false (DC)
  const dautenUp = dautenDir === 'up';
  const crossUp = crossDir === true;
  const sameDirection = dautenUp === crossUp;
  
  if (!sameDirection) return { diff: null, sameDirection: false };
  
  // 時間差計算
  function parseTime(str) {
    if (!str || str === '-') return null;
    const segments = str.split('/');
    if (segments.length < 4) return null;
    const year = 2000 + parseInt(segments[0]);
    const month = parseInt(segments[1]) - 1;
    const day = parseInt(segments[2]);
    const timePart = segments[3];
    let hour = 0, minute = 0;
    if (timePart.includes(':')) {
      const tp = timePart.split(':');
      hour = parseInt(tp[0]);
      minute = parseInt(tp[1]);
    } else {
      hour = parseInt(timePart);
    }
    return new Date(year, month, day, hour, minute);
  }
  
  const dautenTime = parseTime(dautenTimeStr);
  const crossTime = parseTime(crossTimeStr);
  if (!dautenTime || !crossTime) return { diff: null, sameDirection: false };
  
  const diffMs = Math.abs(dautenTime - crossTime);
  const diffMin = Math.floor(diffMs / 60000);
  return { diff: diffMin, sameDirection: true };
}

function formatTimeDiff(diffMin, format) {
  if (format === 'datetime') return '-';
  if (diffMin === null) return '-';
  if (format === 'm') return diffMin + 'm';
  if (format === 'hm') {
    const hours = Math.floor(diffMin / 60);
    const mins = diffMin % 60;
    return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  if (format === 'dhm') {
    const days = Math.floor(diffMin / 1440);
    const remainMins = diffMin % 1440;
    const hours = Math.floor(remainMins / 60);
    const mins = remainMins % 60;
    return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  return diffMin + 'm';
}

async function load() {
  const update_at = new Date().toISOString();
  console.log('[CLIENT UPDATE START]', update_at);
  console.log('Loading data...');
  try {
    const r = await fetch('/current_states');
    console.log('Response status:', r.status);
    
    if (!r.ok) {
      throw new Error('HTTP ' + r.status);
    }
    
    const data = await r.json();
    console.log('Data received:', data);
    
    if (data.status === 'success' && data.states.length > 0) {
      // 現在のダッシュボードデータを保存（テスト時に使用）
      currentDashboardData = data.states;
      
      // 利用可能な通貨を抽出
      const availableCurrencies = [...new Set(data.states.map(s => s.symbol))];
  updateCurrencyFilter(availableCurrencies);
  // Populate rule editor scope select with current available currencies
  try { populateRuleScopeSelect(availableCurrencies); } catch (e) { console.log('populateRuleScopeSelect call error', e); }
      
      // 通貨ごとにコンテナを生成
      const container = document.getElementById('dashboards-container');
      
      // 既存の発火履歴を保存
      const existingHistories = {};
      document.querySelectorAll('.currency-fire-history-list').forEach(list => {
        const symbol = list.dataset.symbol;
        if (symbol) {
          existingHistories[symbol] = list.innerHTML;
        }
      });
      
      container.innerHTML = '';
      
      availableCurrencies.forEach(symbol => {
        // 各通貨のセクションを作成
        const section = document.createElement('div');
        section.className = 'currency-section';
        section.dataset.symbol = symbol;
        
        const isVisible = JSON.parse(localStorage.getItem('tv_currencies') || '{}')[symbol] !== false;
        if (!isVisible) {
          section.classList.add('hidden');
        }
        
        // 通貨ごとのテーブルを作成
        const dashboardDiv = document.createElement('div');
        dashboardDiv.className = 'currency-dashboard';
        section.appendChild(dashboardDiv);
        
        // 通貨ごとの発火履歴ウィンドウを作成
        const fireHistoryDiv = document.createElement('div');
        fireHistoryDiv.className = 'currency-fire-history';
        fireHistoryDiv.dataset.symbol = symbol;
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'currency-fire-history-header';
        
        const titleH3 = document.createElement('h3');
        titleH3.textContent = symbol + '発火履歴';
        
        const buttonsDiv = document.createElement('div');
        buttonsDiv.style.display = 'flex';
        buttonsDiv.style.gap = '8px';
        
        // ソート切り替えボタン（降順/昇順）
        const sortBtn = document.createElement('button');
        sortBtn.textContent = '▼▲';
        sortBtn.dataset.symbol = symbol;
        sortBtn.title = '履歴の並べ替え（降順/昇順）';
        sortBtn.addEventListener('click', () => toggleSortOrder(symbol));
        
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'クリア';
        clearBtn.dataset.symbol = symbol;
        clearBtn.addEventListener('click', () => clearFireHistory(symbol));
        
        // ルールカウントボタンを追加
        const ruleCountBtn = document.createElement('button');
        ruleCountBtn.id = 'rule-count-btn-' + symbol;
        ruleCountBtn.className = 'rule-count-btn';
        ruleCountBtn.textContent = '0';
        ruleCountBtn.title = 'アクティブなルール数';
        ruleCountBtn.addEventListener('click', () => showRuleDropdown(ruleCountBtn, symbol));
        
        buttonsDiv.appendChild(sortBtn);
        buttonsDiv.appendChild(clearBtn);
        buttonsDiv.appendChild(ruleCountBtn);
        
        headerDiv.appendChild(titleH3);
        headerDiv.appendChild(buttonsDiv);
        fireHistoryDiv.appendChild(headerDiv);
        
        const listDiv = document.createElement('div');
        listDiv.className = 'currency-fire-history-list';
        listDiv.dataset.symbol = symbol;
        
        // 既存の履歴があれば復元、なければデフォルトメッセージ
        if (existingHistories[symbol]) {
          listDiv.innerHTML = existingHistories[symbol];
        } else {
          listDiv.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
        }
        
        fireHistoryDiv.appendChild(listDiv);
        section.appendChild(fireHistoryDiv);
        
        container.appendChild(section);
        
        // テーブルを生成
        renderCurrencyTable(symbol, data.states, dashboardDiv);
      });
      
      // テーブル再描画後に設定を再適用
      try {
        const sz = localStorage.getItem('tv_font_size') || document.getElementById('fontSizeSelect')?.value || '14';
        applyFontSize(sz);
        applyColumnVisibility();
        applyRowVisibility();
      } catch (e) { /* ignore */ }
      
      // 高さ同期を実行
      setTimeout(syncAllFireHistoryHeights, 100);
      
      // ルールカウントボタンを更新（load()でDOMが再生成されるため）
      setTimeout(updateRuleCountButtons, 150);
    } else {
      document.getElementById('dashboards-container').innerHTML = '<div class="loading">データなし</div>';
    }
  } catch (e) {
    document.getElementById('dashboards-container').innerHTML = '<div class="loading">エラー: ' + e.message + '</div>';
  }
}

// 通貨ごとのテーブルを生成する関数
function renderCurrencyTable(symbol, allStates, container) {
  const state5m = allStates.find(x => x.symbol === symbol && x.tf === '5');
  const state15m = allStates.find(x => x.symbol === symbol && x.tf === '15');
  const state1h = allStates.find(x => x.symbol === symbol && x.tf === '60');
  const state4h = allStates.find(x => x.symbol === symbol && x.tf === '240');
  
  if (!state5m) {
    container.innerHTML = '<div class="loading">5mデータがありません</div>';
    return;
  }
  
  // 更新時刻を計算（JST）
  const updateTime = state5m.timestamp ? new Date(state5m.timestamp).toLocaleString('ja-JP', {timeZone: 'Asia/Tokyo', hour12: false}).split(' ')[1] : 'N/A';
  
  // 5m のクラウド配列をベースに統合
  const mergedClouds = (state5m.clouds || []).map(cloud => {
    const merged = {...cloud};
    
    if (cloud.label === '15m' && state15m) {
      merged.dauten = state15m.clouds?.[0]?.dauten || cloud.dauten;
      merged.bos_count = state15m.daytrade?.bos || cloud.bos_count;
      merged.dauten_start_time_str = state15m.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
      merged.elapsed_str = state15m.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
    } else if (cloud.label === '1H' && state1h) {
      merged.dauten = state1h.clouds?.[0]?.dauten || cloud.dauten;
      merged.bos_count = state1h.daytrade?.bos || cloud.bos_count;
      merged.dauten_start_time_str = state1h.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
      merged.elapsed_str = state1h.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
    } else if (cloud.label === '4H' && state4h) {
      merged.dauten = state4h.clouds?.[0]?.dauten || cloud.dauten;
      merged.bos_count = state4h.daytrade?.bos || cloud.bos_count;
      merged.dauten_start_time_str = state4h.clouds?.[0]?.dauten_start_time_str || cloud.dauten_start_time_str;
      merged.elapsed_str = state4h.clouds?.[0]?.elapsed_str || cloud.elapsed_str;
    } else if (cloud.label === '5m') {
      merged.bos_count = state5m.daytrade?.bos || cloud.bos_count;
    } else if (cloud.label !== '5m') {
      merged.dauten = '';
      merged.bos_count = null;
      merged.dauten_start_time_str = '';
      merged.elapsed_str = '';
    }
    
    return merged;
  });
  
  // row_order に従って行を並べ替え
  const rowOrder = state5m.row_order || ['5m', '15m', 'price', '1H', '4H'];
  const orderedRows = [];
  
  rowOrder.forEach(label => {
    if (label === 'price') {
      orderedRows.push({ type: 'price', price: state5m.price });
    } else {
      const cloud = mergedClouds.find(c => c.label === label);
      if (cloud) {
        orderedRows.push({ type: 'cloud', ...cloud });
      }
    }
  });
  
  let html = '<div class="table-wrap"><table><tr><th colspan="11" style="text-align: center;">' + state5m.symbol + ' - ' + state5m.price + '<span style="float: right;">更新 ' + updateTime + '</span></th></tr>';
  html += '<tr><th class="header-black">雲整列</th><th class="header-black">ダウ転</th><th class="header-black">突破数</th><th class="header-black">雲交差</th><th class="header-black">各雲間</th><th class="header-black">価格間</th><th class="header-black">雲角度</th><th class="header-black">雲厚み</th><th class="header-black">ダウ時間</th><th class="header-black">交差時間</th><th class="header-black">時間差</th></tr>';

  orderedRows.forEach(row => {
    if (row.type === 'price') {
      html += '<tr class="price-row"><td class="tf-label">価格</td>';
      html += '<td colspan="10"></td></tr>';
    } else {
      const c = row;
      html += '<tr>';
      
      let tfBgColor = '';
      if (c.label === '5m') tfBgColor = '#a9e88c';
      else if (c.label === '15m') tfBgColor = '#fbd0b2';
      else if (c.label === '1H') tfBgColor = '#8dc7fc';
      else if (c.label === '4H') tfBgColor = '#fa8dfe';
      
      if (tfBgColor) {
        html += '<td class="tf-label" style="background:' + tfBgColor + '; color:#000">' + c.label + '</td>';
      } else {
        html += '<td class="tf-label col-cloud-label">' + c.label + '</td>';
      }

      let dautenColor = '';
      if (c.dauten === 'up') dautenColor = '#2962ff';
      else if (c.dauten === 'down') dautenColor = '#f23645';

      let gcColor = '';
      if (c.gc === true) gcColor = '#2962ff';
      else if (c.gc === false) gcColor = '#f23645';

      let bosVal = c.bos_count;

      const toNum = v => (v === null || v === undefined || v === '' ? null : Number(v));
      const prev = toNum(c.distance_from_prev);
      const prevColor = (prev !== null ? (prev > 0 ? '#2962ff' : (prev < 0 ? '#f23645' : '')) : '');
      const dp = toNum(c.distance_from_price);
      const dpColor = (dp !== null ? (dp > 0 ? '#2962ff' : (dp < 0 ? '#f23645' : '')) : '');
      const ang = toNum(c.angle);
      const angColor = (ang !== null ? (ang > 0 ? '#2962ff' : (ang < 0 ? '#f23645' : '')) : '');
      const th = toNum(c.thickness);
      const thColor = (th !== null ? (th > 0 ? '#2962ff' : (th < 0 ? '#f23645' : '')) : '');

      if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';
      else html += '<td>' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';

      const displayBos = (bosVal === null || bosVal === undefined || bosVal === '' ? '-' : bosVal);
      if (dautenColor) {
        html += '<td style="background:' + dautenColor + '; color:#fff">' + displayBos + '</td>';
      } else {
        html += '<td>' + displayBos + '</td>';
      }

      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (c.gc ? '▲GC' : '▼DC') + '</td>';
      else html += '<td>' + (c.gc ? '▲GC' : '▼DC') + '</td>';

      if (prevColor) html += '<td style="background:' + prevColor + '; color:#fff">' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';

      if (dpColor) html += '<td style="background:' + dpColor + '; color:#fff">' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';

      if (angColor) html += '<td style="background:' + angColor + '; color:#fff">' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';
      else html += '<td>' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';

      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (th !== null ? th.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (th !== null ? th.toFixed(1) : '-') + '</td>';

      const timeFormat = localStorage.getItem('tv_time_format') || 'datetime';
      
      const dautenTimeFormatted = formatElapsedTime(c.dauten_start_time_str || '-', timeFormat);
      if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + dautenTimeFormatted + '</td>';
      else html += '<td>' + dautenTimeFormatted + '</td>';

      const elapsedTimeFormatted = formatElapsedTime(c.elapsed_str || '-', timeFormat);
      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + elapsedTimeFormatted + '</td>';
      else html += '<td>' + elapsedTimeFormatted + '</td>';

      const timeDiffResult = calculateTransferTimeDiff(c);
      const timeDiffFormatted = formatTimeDiff(timeDiffResult.diff, timeFormat);
      let timeDiffBg = '';
      let timeDiffColor = '#fff';
      if (timeDiffResult.sameDirection) {
        timeDiffBg = dautenColor || '';
      } else {
        timeDiffBg = 'rgba(128,128,128,0.5)';
      }
      if (timeDiffBg) {
        html += '<td style="background:' + timeDiffBg + '; color:' + timeDiffColor + '">' + timeDiffFormatted + '</td></tr>';
      } else {
        html += '<td style="color:' + timeDiffColor + '">' + timeDiffFormatted + '</td></tr>';
      }
    }
  });

  html += '</table></div>';
  container.innerHTML = html;
}

// 初期読み込みと定期的な更新
let updateTimer = null;

function computeNextUpdateTimeout(delaySeconds) {
  const now = new Date();
  const next = new Date(now);

  // Reset seconds and milliseconds first
  next.setSeconds(0, 0);

  // Align minutes to the next 5-minute boundary
  const minute = next.getMinutes();
  const remainder = minute % 5;
  if (remainder !== 0) {
    next.setMinutes(minute + (5 - remainder));
  } else {
    // If already on a 5-minute boundary, move to the next one
    next.setMinutes(minute + 5);
  }

  // Add delay seconds to the 5-minute boundary
  next.setSeconds(delaySeconds);

  // If the calculated time is in the past, move to the next 5-minute boundary
  if (next <= now) {
    next.setMinutes(next.getMinutes() + 5);
  }

  return { timeout: next.getTime() - now.getTime(), target: next };
}

async function executeScheduledUpdate() {
  console.log(`[TIMER] Executing scheduled update at ${new Date().toLocaleString('ja-JP', { hour12: false })}`);
  try {
    await load();
    console.log(`[TIMER] Update completed successfully`);
  } catch (error) {
    console.error(`[TIMER] Update failed:`, error);
  }
}

function scheduleNextUpdate() {
  if (updateTimer) {
    clearTimeout(updateTimer);
    updateTimer = null;
  }

  // 5分毎更新が無効の場合、タイマーを設定しない
  const enable5mUpdate = localStorage.getItem('tv_enable_5m_update') !== 'false';
  if (!enable5mUpdate) {
    console.log('[TIMER] 5分毎更新が無効のため、定期更新をスキップします');
    return;
  }

  // WebSocket最終更新から5分30秒以上経過していない場合、定期更新をスキップ
  const now = Date.now();
  const timeSinceLastUpdate = now - lastWebSocketUpdate;
  const fiveMinutesThirtySeconds = (5 * 60 + 30) * 1000; // 5分30秒 = 330秒 = 330000ミリ秒

  if (timeSinceLastUpdate < fiveMinutesThirtySeconds) {
    const remainingSeconds = Math.ceil((fiveMinutesThirtySeconds - timeSinceLastUpdate) / 1000);
    const remainingMinutes = Math.floor(remainingSeconds / 60);
    const remainingSecs = remainingSeconds % 60;
    console.log(`[TIMER] WebSocket更新から${remainingMinutes}分${remainingSecs}秒以内のため、定期更新をスキップします`);
    // 次回のチェックは5分30秒後にスケジュール
    updateTimer = setTimeout(() => {
      scheduleNextUpdate();
    }, fiveMinutesThirtySeconds - timeSinceLastUpdate);
    return;
  }

  const delay = parseInt(localStorage.getItem('tv_update_delay') || '10', 10);
  const { timeout, target } = computeNextUpdateTimeout(delay);

  const secondsUntil = Math.round(timeout / 1000);
  const targetStr = target.toLocaleString('ja-JP', { hour12: false });
  console.log(`[TIMER] WebSocket更新から5分以上経過したため、定期更新を実行します。次回: ${targetStr} (あと${secondsUntil}s)`);

  updateTimer = setTimeout(async () => {
    await executeScheduledUpdate();
    scheduleNextUpdate(); // Reschedule after execution
  }, timeout);
}

// 初期読み込みと定期的な更新をメインリスナーに統合
// loadRules()と他の初期化は最初のDOMContentLoadedリスナーで実行される

// --- Rules UI / API ---
async function loadRules() {
  try {
    const r = await fetch('/rules');
    if (!r.ok) return;
    const data = await r.json();
    if (data.status !== 'success') return;
    allRules = data.rules || []; // グローバル変数に保存
    renderRulesList(allRules);
    updateRuleCountButtons(); // ルールカウントボタンを更新
    // populate scope select with available symbols (currencies)
    const scopeSelect = document.getElementById('ruleScope');
    const avail = [...new Set((allRules).map(x => x.scope && x.scope.symbol).filter(Boolean))];
    // keep existing options but add any new
    avail.forEach(s => {
      if (![...scopeSelect.options].some(o => o.value === s)) {
        const opt = document.createElement('option'); opt.value = s; opt.textContent = s; scopeSelect.appendChild(opt);
      }
    });
  } catch (e) { console.log('loadRules error', e); }
}

// ルールカウントボタンを更新する関数
function updateRuleCountButtons() {
  console.log('updateRuleCountButtons called, allRules:', allRules.length);
  // 各通貨の発火履歴ヘッダーのボタンを更新
  document.querySelectorAll('.currency-fire-history').forEach(historyDiv => {
    const symbol = historyDiv.dataset.symbol;
    const ruleCountBtn = document.getElementById('rule-count-btn-' + symbol);
    if (!ruleCountBtn) {
      console.log('ruleCountBtn not found for symbol:', symbol);
      return;
    }

    // この通貨に適用される有効なルールをカウント
    const activeRules = allRules.filter(r => {
      const isEnabled = r.enabled !== false;
      const scope = r.scope || {};
      const ruleSymbol = scope.symbol;
      // scope.symbolが空またはundefinedの場合は全通貨対象、それ以外は一致する場合のみ
      const matches = isEnabled && (!ruleSymbol || ruleSymbol === '' || ruleSymbol === symbol);
      console.log('Rule:', r.name, 'enabled:', isEnabled, 'scope:', scope, 'ruleSymbol:', ruleSymbol, 'symbol:', symbol, 'matches:', matches);
      return matches;
    });

    console.log('Active rules for', symbol, ':', activeRules.length);
    ruleCountBtn.textContent = activeRules.length.toString();
  });
}

// ルールドロップダウンを表示する関数
function showRuleDropdown(button, symbol) {
  // 既存のドロップダウンを削除
  document.querySelectorAll('.rule-dropdown').forEach(d => d.remove());
  
  // この通貨のアクティブなルールを取得
  const activeRules = allRules.filter(r => {
    const isEnabled = r.enabled !== false;
    const scope = r.scope || {};
    const ruleSymbol = scope.symbol;
    // scope.symbolが空またはundefinedの場合は全通貨対象、それ以外は一致する場合のみ
    return isEnabled && (!ruleSymbol || ruleSymbol === '' || ruleSymbol === symbol);
  });
  
  // ドロップダウンを作成
  const dropdown = document.createElement('div');
  dropdown.className = 'rule-dropdown';
  dropdown.style.position = 'absolute';
  dropdown.style.background = 'rgba(0, 0, 0, 0.9)';
  dropdown.style.border = '1px solid rgba(255, 255, 255, 0.3)';
  dropdown.style.borderRadius = '6px';
  dropdown.style.padding = '8px';
  dropdown.style.zIndex = '1000';
  dropdown.style.maxHeight = '200px';
  dropdown.style.overflowY = 'auto';
  dropdown.style.minWidth = '150px';
  
  if (activeRules.length === 0) {
    const item = document.createElement('div');
    item.textContent = 'アクティブなルールなし';
    item.style.color = 'rgba(255, 255, 255, 0.7)';
    item.style.padding = '4px 0';
    dropdown.appendChild(item);
  } else {
    activeRules.forEach(rule => {
      const item = document.createElement('div');
      item.textContent = rule.name || rule.id;
      item.style.color = '#fff';
      item.style.padding = '4px 0';
      item.style.cursor = 'pointer';
      item.addEventListener('mouseenter', () => item.style.background = 'rgba(255, 255, 255, 0.1)');
      item.addEventListener('mouseleave', () => item.style.background = 'transparent');
      dropdown.appendChild(item);
    });
  }
  
  // ボタンの位置を取得
  const rect = button.getBoundingClientRect();
  dropdown.style.left = rect.left + 'px';
  dropdown.style.top = (rect.bottom + 2) + 'px';
  
  // ドロップダウンを追加
  document.body.appendChild(dropdown);
  
  // クリックで閉じる
  const closeDropdown = (e) => {
    if (!dropdown.contains(e.target) && e.target !== button) {
      dropdown.remove();
      document.removeEventListener('click', closeDropdown);
    }
  };
  setTimeout(() => document.addEventListener('click', closeDropdown), 0);
}

function renderRulesList(rules) {
  // Sort rules: enabled first (by updated_at desc), then disabled (by updated_at desc)
  const sortedRules = rules.sort((a, b) => {
    const aEnabled = a.enabled !== false;
    const bEnabled = b.enabled !== false;
    if (aEnabled !== bEnabled) {
      return bEnabled - aEnabled; // enabled (true=1) comes before disabled (false=0)
    }
    // Same enabled status: sort by updated_at descending (most recent first)
    const aTime = a.updated_at || a.created_at || '';
    const bTime = b.updated_at || b.created_at || '';
    return bTime.localeCompare(aTime);
  });
  
  const ul = document.getElementById('rulesList'); ul.innerHTML = '';
  sortedRules.forEach(rule => {
    const li = document.createElement('li'); li.style.padding = '6px 4px'; li.style.borderBottom = '1px solid rgba(255,255,255,0.04)';
    li.style.display = 'flex'; li.style.alignItems = 'center'; li.style.justifyContent = 'space-between';
    
    const left = document.createElement('div'); left.style.display = 'flex'; left.style.alignItems = 'center'; left.style.gap = '8px';
    const btns = document.createElement('div'); btns.style.display = 'flex'; btns.style.gap = '6px';
    
    // 有効/無効トグルボタン
    const toggle = document.createElement('button');
    const isEnabled = rule.enabled !== false; // デフォルトは有効
    toggle.textContent = isEnabled ? '有効' : '無効';
    toggle.style.padding = '4px 8px';
    toggle.style.fontWeight = '600';
    toggle.style.background = isEnabled ? 'rgba(46, 160, 67, 0.2)' : 'rgba(176, 42, 42, 0.2)';
    toggle.style.color = isEnabled ? '#4ade80' : '#f87171';
    toggle.style.border = isEnabled ? '1px solid #4ade80' : '1px solid #f87171';
    toggle.style.borderRadius = '4px';
    toggle.style.cursor = 'pointer';
    toggle.addEventListener('click', async () => {
      try {
        const newEnabled = !isEnabled;
        const updatedRule = { ...rule, enabled: newEnabled };
        const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(updatedRule) });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('更新に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('toggle error', e); alert('トグルエラー: ' + e.message); }
    });
    
    const edit = document.createElement('button'); edit.textContent = '編集'; edit.style.padding = '4px 8px'; edit.className = 'rule-btn';
    const del = document.createElement('button'); del.textContent = '削除'; del.style.padding = '4px 8px'; del.className = 'rule-btn';
    edit.addEventListener('click', () => openRuleEditor(rule));
    del.addEventListener('click', async () => {
      if (!confirm('ルールを削除しますか?')) return;
      try {
        const res = await fetch('/rules/' + encodeURIComponent(rule.id), { method: 'DELETE' });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('削除に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('delete error', e); alert('削除エラー: ' + e.message); }
    });
    
    btns.appendChild(toggle); btns.appendChild(edit); btns.appendChild(del);
    // According to request, place buttons first then rule name to the right
    const title = document.createElement('div'); 
    title.textContent = rule.name || rule.id; 
    title.style.fontWeight = '600'; 
    title.style.marginLeft = '12px';
    title.style.opacity = isEnabled ? '1' : '0.5'; // 無効な場合は薄く表示
    btns.style.opacity = isEnabled ? '1' : '0.5'; // ボタンも薄く表示
    left.appendChild(btns); left.appendChild(title);
    li.appendChild(left);
    ul.appendChild(li);
  });
  
  // ルールリスト更新後にボタンを更新
  updateRuleCountButtons();
}

function openRuleEditor(rule) {
  // populate editor fields
  console.log('[DEBUG] Editing rule:', JSON.stringify(rule, null, 2));
  document.getElementById('ruleName').value = rule.name || '';
  const scopeSel = document.getElementById('ruleScope');
  if (rule.scope && rule.scope.symbol) { scopeSel.value = rule.scope.symbol; }
  else { scopeSel.value = ''; }
  // clear conditions
  const condCont = document.getElementById('conditionsContainer'); condCont.innerHTML = '';
  const conds = (rule.rule && rule.rule.conditions) || [];
  if (conds.length === 0) addConditionRow();
  conds.forEach(c => {
    const row = createConditionRow(c);
    condCont.appendChild(row);
  });
    // populate alignment UI if present
  try {
    const align = rule.rule && rule.rule.alignment;
    if (align) {
      // clear all
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      (align.tfs || []).forEach(tf => {
        const el = document.querySelector('.align-tf[data-tf="' + tf + '"]');
        if(el) el.checked = true;
      });
      if (align.missing) document.getElementById('alignMissing').value = align.missing;
    } else {
      // reset to defaults
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      document.getElementById('alignMissing').value = 'ignore';
    }
  } catch(e) { /* ignore */ }
  
  // populate voice settings
  const voice = rule.rule && rule.rule.voice;
  const isDirectionBased = voice && (voice.message_up !== undefined || voice.message_down !== undefined);
  document.getElementById('voiceDirectionBased').checked = isDirectionBased;
  document.getElementById('directionMessages').style.display = isDirectionBased ? 'flex' : 'none';
  document.getElementById('voiceMessagePosition').value = (voice && voice.message_position) || 'suffix';
  
  // Always populate common message if present
  document.getElementById('voiceMessage').value = (voice && voice.message) || '';
  
  // Populate direction-based messages if present
  if (isDirectionBased) {
    document.getElementById('voiceMessageUp').value = (voice && voice.message_up) || '';
    document.getElementById('voiceMessageDown').value = (voice && voice.message_down) || '';
  } else {
    document.getElementById('voiceMessageUp').value = '';
    document.getElementById('voiceMessageDown').value = '';
  }
  
  document.getElementById('voiceSelect').value = (voice && voice.voice_name) || '';
  
  // Populate chime settings
  document.getElementById('playChimeFirst').checked = !!(voice && voice.chime_file);
  document.getElementById('chimeSelect').value = (voice && voice.chime_file) || '';
  
  // Populate symbol insert setting
  document.getElementById('insertSymbol').checked = !!(voice && voice.insert_symbol);
  document.getElementById('symbolInsertPosition').value = (voice && voice.symbol_insert_position) || 'prefix';
  
  // store editing id on save button
  document.getElementById('saveRuleBtn').dataset.editing = rule.id;
}

// --- 雲整列: helper ---
function getAlignmentSettingsFromUI(){
  const tfs = Array.from(document.querySelectorAll('.align-tf')).filter(cb=>cb.checked).map(cb=>cb.dataset.tf);
  const missing = document.getElementById('alignMissing').value; // 'ignore' or 'fail'
  return { tfs, missing };
}

function validateAlignmentForSave(){
  const s = getAlignmentSettingsFromUI();
  const errEl = document.getElementById('alignError'); errEl.style.display = 'none'; errEl.textContent = '';
  if(s.tfs.length === 0){
    // No TFs selected, that's fine - alignment is optional
    return {ok:true, msg:'no_alignment_selected'};
  }
  if(s.tfs.length === 1){
    errEl.style.display='block'; errEl.textContent='エラー: 判定対象の時間は 2 個以上選択してください';
    return {ok:false, msg:'need_2_tfs'};
  }
  return {ok:true, msg:'ok'};
}

// wire align checkbox changes to keep UI consistent
// これらのイベントリスナーは最初のDOMContentLoadedリスナーで設定される
// (後で統合する必要があります)

function createConditionRow(c) {
  const div = document.createElement('div'); div.className = 'cond-row'; div.style.display='flex'; div.style.gap='6px'; div.style.alignItems='center';
  const tf = document.createElement('select'); tf.className='cond-tf'; tf.style.padding='6px'; tf.style.borderRadius='6px'; tf.style.background='rgba(15,27,65,0.7)'; tf.style.color='inherit'; tf.style.border='1px solid rgba(255,255,255,0.12)'; tf.innerHTML = '<option value="5m">5m</option><option value="15m">15m</option><option value="1H">1H</option><option value="4H">4H</option>';
  const field = document.createElement('select'); field.className='cond-field'; field.style.padding='6px'; field.style.borderRadius='6px'; field.style.background='rgba(15,27,65,0.7)'; field.style.color='inherit'; field.style.border='1px solid rgba(255,255,255,0.12)'; field.innerHTML = '<option value="dauten">ダウ転</option><option value="bos_count">突破数</option><option value="gc">雲交差</option><option value="distance_from_prev">各雲間</option><option value="distance_from_price">価格間</option><option value="angle">雲角度</option><option value="thickness">雲厚み</option><option value="transfer_time_diff">転換時間差</option>';
  const val = document.createElement('input'); val.className='cond-value'; val.placeholder='値'; val.style.padding='6px'; val.style.borderRadius='6px'; val.style.border='1px solid rgba(255,255,255,0.08)'; val.style.background='transparent'; val.style.color='inherit'; val.style.width='60px';
  const rem = document.createElement('button'); rem.className='removeCond'; rem.textContent='削除'; rem.style.padding='6px 12px';
  rem.addEventListener('click', () => div.remove());
  div.append(tf, field, val, rem);

  // hide/remove val when field is one of the toggle-only types
  function updateCondVisibility() {
    try {
      const hideVal = ['dauten','bos_count','gc','dauten_start_time_str','cross_start_time'];
      
      if (hideVal.includes(field.value)) {
        // remove val from DOM
        if (val.parentNode === div) div.removeChild(val);
      } else {
        // show val for numeric input
        if (val.parentNode !== div) div.insertBefore(val, rem);
        val.style.display = '';
        val.placeholder = '値';
      }
    } catch (e) {
      console.warn('updateCondVisibility error:', e);
    }
  }

  field.addEventListener('change', updateCondVisibility);
  // Set values from loaded rule BEFORE calling initial visibility update
  if (c) {
    tf.value = c.label || tf.value;
    field.value = c.field || field.value;
    val.value = c.value || '';
  }
  // initial visibility (AFTER setting field value so it checks the correct field type)
  updateCondVisibility();
  return div;
}

function addConditionRow() {
  const cont = document.getElementById('conditionsContainer');
  const r = createConditionRow(); cont.appendChild(r);
}

// ルール UI イベントリスナーは DOMContentLoaded リスナーで初期化される

// --- Notifications and Voice Alerts ---
let lastNotificationTimestamp = null;
let notificationCheckInterval = null;
let notificationPollingStarted = false; // Global flag to prevent multiple instances

// 通知を再生する関数(Socket.IOとポーリングの両方で使用)
async function playNotification(notification) {
  if (!notification) return;
  
  console.log('[PLAY_NOTIFICATION]', notification);
  
  // 音声設定を抽出
  const voiceSettings = notification.voice_settings || null;
  const message = notification.message || '';
  const symbol = notification.symbol || '';
  
  // チャイム音と音声を再生
  playVoiceAlert(message, voiceSettings, symbol);
}

// 単一の通知を発火履歴に追加する関数
function addNotificationToHistory(notification) {
  if (!notification) return;
  
  console.log('[ADD_TO_HISTORY]', notification);
  
  const symbol = notification.symbol || 'UNKNOWN';
  const listEl = document.querySelector(`.currency-fire-history-list[data-symbol="${symbol}"]`);
  
  if (!listEl) {
    console.log('[ADD_TO_HISTORY] List element not found for symbol:', symbol);
    return;
  }
  
  // 既存の「履歴なし」メッセージを削除
  if (listEl.innerHTML.includes('履歴なし')) {
    listEl.innerHTML = '';
  }
  
  // Format timestamp: YY/MM/DD HH:mm
  const dt = new Date(notification.timestamp);
  const year = String(dt.getFullYear()).slice(-2);
  const month = String(dt.getMonth() + 1).padStart(2, '0');
  const day = String(dt.getDate()).padStart(2, '0');
  const hour = String(dt.getHours()).padStart(2, '0');
  const minute = String(dt.getMinutes()).padStart(2, '0');
  const timeStr = year + '/' + month + '/' + day + ' ' + hour + ':' + minute;
  
  // 新しい発火アイテムを作成
  const fireItem = document.createElement('div');
  fireItem.className = 'fire-item';
  fireItem.innerHTML = '<span class="fire-time">' + timeStr + '</span>';
  if (notification.direction) {
    const directionClass = notification.direction === '上昇' ? 'direction-up' : 'direction-down';
    fireItem.innerHTML += '<span class="fire-direction ' + directionClass + '">' + notification.direction + '</span>';
  }
  fireItem.innerHTML += '<span class="fire-name">' + (notification.rule_name || '不明') + '</span>';
  
  // 先頭に挿入(最新が上)
  listEl.insertBefore(fireItem, listEl.firstChild);
  
  // 最大20件に制限
  while (listEl.children.length > 20) {
    listEl.removeChild(listEl.lastChild);
  }
  
  // フォントサイズとレイアウトを適用
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  applyFontSize(savedSize);
  syncAllFireHistoryHeights();
  
  console.log('[ADD_TO_HISTORY] Added notification to history for', symbol);
}

async function checkNotifications() {
  const timestamp = new Date().toISOString();
  const stackTrace = new Error().stack;
  console.log('[NOTIFICATIONS] checkNotifications called at ' + timestamp);
  console.log('[NOTIFICATIONS] Call stack:', stackTrace);
  
  try {
    const res = await fetch('/api/notifications');
    if (!res.ok) return;
    const data = await res.json();
    if (data.status !== 'success') return;
    
    const notifications = data.notifications || [];
    if (notifications.length === 0) return;
    
    // Update fire history display
    updateFireHistory(notifications);
    
    // Get the latest notification
    const latest = notifications[0];
    const latestTimestamp = latest.timestamp;
    
    // If this is a new notification (different timestamp)
    if (lastNotificationTimestamp !== latestTimestamp) {
      lastNotificationTimestamp = latestTimestamp;
      
      // Play notification with voice settings
      await playNotification(latest);
      
      console.log('[NOTIFICATION]', latest);
    }
  } catch (e) {
    console.log('checkNotifications error', e);
  }
}

function updateFireHistory(notifications) {
  if (notifications.length === 0) {
    // すべての通貨の履歴をクリア
    document.querySelectorAll('.fire-history-list').forEach(listEl => {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
    });
    return;
  }
  
  // 通貨ごとに通知を分類
  const notificationsBySymbol = {};
  notifications.forEach(notif => {
    const symbol = notif.symbol || 'UNKNOWN';
    if (!notificationsBySymbol[symbol]) {
      notificationsBySymbol[symbol] = [];
    }
    notificationsBySymbol[symbol].push(notif);
  });
  
    // 各通貨の発火履歴を更新
  document.querySelectorAll('.currency-fire-history-list').forEach(listEl => {
    const symbol = listEl.dataset.symbol;
    const symbolNotifications = notificationsBySymbol[symbol] || [];
    const displayNotifications = symbolNotifications.slice(0, 20);
    
    if (displayNotifications.length === 0) {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
      return;
    }
    
    let html = '';
    displayNotifications.forEach(notif => {
      // Format timestamp: YY/MM/DD HH:mm
      const dt = new Date(notif.timestamp);
      const year = String(dt.getFullYear()).slice(-2);
      const month = String(dt.getMonth() + 1).padStart(2, '0');
      const day = String(dt.getDate()).padStart(2, '0');
      const hour = String(dt.getHours()).padStart(2, '0');
      const minute = String(dt.getMinutes()).padStart(2, '0');
      const timeStr = year + '/' + month + '/' + day + ' ' + hour + ':' + minute;
      
      html += '<div class="fire-item">';
      html += '<span class="fire-time">' + timeStr + '</span>';
      if (notif.direction) {
        const directionClass = notif.direction === '上昇' ? 'direction-up' : 'direction-down';
        html += '<span class="fire-direction ' + directionClass + '">' + notif.direction + '</span>';
      }
      html += '<span class="fire-name">' + (notif.rule_name || '不明') + '</span>';
      html += '</div>';
    });
    
    listEl.innerHTML = html;
    
    // ソート状態を適用（降順がデフォルト）
    const sortDesc = fireHistorySortStates[symbol] !== false;
    if (!sortDesc) {
      // 昇順の場合はソートを実行
      toggleSortOrder(symbol);
    }
  });  // Apply current font size to newly created elements
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  applyFontSize(savedSize);
  
  // Sync fire history heights after content update
  syncAllFireHistoryHeights();
}

// 全通貨の発火履歴ウィンドウの高さを同期する
function syncAllFireHistoryHeights() {
  document.querySelectorAll('.currency-section').forEach(section => {
    const dashboard = section.querySelector('.currency-dashboard');
    const fireHistory = section.querySelector('.currency-fire-history');
    
    if (!dashboard || !fireHistory) return;
    
    // Get the table from dashboard
    const tableWrap = dashboard.querySelector('.table-wrap');
    if (!tableWrap) return;
    
    const table = tableWrap.querySelector('table');
    if (!table) return;
    
    // Use requestAnimationFrame to ensure layout is complete
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        const tableHeight = table.offsetHeight;
        
        // Set fire history height to match table
        fireHistory.style.height = tableHeight + 'px';
        
        // Adjust the list max-height to account for header
        const headerHeight = fireHistory.querySelector('.currency-fire-history-header')?.offsetHeight || 50;
        const padding = 24; // 12px top + 12px bottom
        const availableHeight = tableHeight - padding - headerHeight;
        
        const listEl = fireHistory.querySelector('.currency-fire-history-list');
        if (listEl) {
          listEl.style.maxHeight = Math.max(0, availableHeight) + 'px';
        }
        
        console.log('[SYNC] Table height:', tableHeight, 'Fire history height:', tableHeight);
      });
    });
  });
}

// Keep fire history height synced on viewport changes
window.addEventListener('resize', () => {
  requestAnimationFrame(() => syncAllFireHistoryHeights());
});

// Test fire button handler
async function testFire(symbol = 'USDJPY') {
  try {
    const res = await fetch('/api/test_fire', { 
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ symbol: symbol })
    });
    const data = await res.json();
    
    if (data.status === 'success') {
      console.log('Test fire sent:', data);
      // Refresh notifications immediately
      setTimeout(checkNotifications, 500);
    } else {
      console.log('Test fire failed:', data);
      alert('テスト発火に失敗しました: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (e) {
    console.log('Test fire error:', e);
    alert('テスト発火エラー: ' + e.message);
  }
}

// Clear fire history for a specific currency
async function clearFireHistory(symbol) {
  try {
    // まず即座にUIをクリア
    const listEl = document.querySelector(`.currency-fire-history-list[data-symbol="${symbol}"]`);
    if (listEl) {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
    }
    
    // 次にサーバーにクリアリクエストを送信
    const res = await fetch('/api/clear_notifications', { method: 'POST' });
    const data = await res.json();
    if (data.status === 'success') {
      console.log('Notifications cleared');
    } else {
      console.log('Clear failed:', data);
      alert('クリアに失敗しました: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (e) {
    console.log('Clear error:', e);
    alert('クリアエラー: ' + e.message);
  }
}

// グローバル変数: 各通貨の発火履歴ソート状態（true: 降順, false: 昇順）
let fireHistorySortStates = {};

// 発火履歴のソート順を切り替える関数
function toggleSortOrder(symbol) {
  const listEl = document.querySelector(`.currency-fire-history-list[data-symbol="${symbol}"]`);
  if (!listEl) return;
  
  // 現在のソート状態を取得（デフォルトは降順）
  const currentSortDesc = fireHistorySortStates[symbol] !== false; // undefinedの場合はtrue（降順）
  const newSortDesc = !currentSortDesc;
  fireHistorySortStates[symbol] = newSortDesc;
  
  // 発火アイテムを取得
  const items = Array.from(listEl.querySelectorAll('.fire-item'));
  if (items.length === 0) return;
  
  // タイムスタンプでソート
  items.sort((a, b) => {
    const timeA = a.querySelector('.fire-time')?.textContent || '';
    const timeB = b.querySelector('.fire-time')?.textContent || '';
    
    // 日付文字列をDateオブジェクトに変換して比較
    const dateA = parseDateTimeString(timeA);
    const dateB = parseDateTimeString(timeB);
    
    if (newSortDesc) {
      return dateB - dateA; // 降順（新しいものが上）
    } else {
      return dateA - dateB; // 昇順（古いものが上）
    }
  });
  
  // ソートされたアイテムをリストに再配置
  items.forEach(item => listEl.appendChild(item));
  
  // ボタンのテキストを更新
  const sortBtn = document.querySelector(`button[title*="並べ替え"][data-symbol="${symbol}"]`);
  if (sortBtn) {
    sortBtn.textContent = newSortDesc ? '▼▲' : '▲▼';
    sortBtn.title = `履歴の並べ替え（${newSortDesc ? '降順' : '昇順'}）`;
  }
  
  console.log(`[SORT] ${symbol} fire history sorted: ${newSortDesc ? 'descending' : 'ascending'}`);
}

// 日付時刻文字列をDateオブジェクトに変換するヘルパー関数
function parseDateTimeString(dateTimeStr) {
  // 形式: YY/MM/DD HH:mm
  const match = dateTimeStr.match(/^(\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2})$/);
  if (!match) return new Date(0);
  
  const [, yy, mm, dd, hh, mi] = match;
  const year = 2000 + parseInt(yy); // 2000年代として扱う
  const month = parseInt(mm) - 1; // JavaScriptの月は0始まり
  const day = parseInt(dd);
  const hour = parseInt(hh);
  const minute = parseInt(mi);
  
  return new Date(year, month, day, hour, minute);
}

// 音声再生キューシステム
let voiceQueue = [];
let isPlayingVoice = false;

function playVoiceAlert(message, voiceSettings = null, symbol = null) {
  // キューに追加
  voiceQueue.push({ message, voiceSettings, symbol });
  console.log('[VOICE_QUEUE] Added to queue. Queue length:', voiceQueue.length);
  
  // 再生中でなければ次を再生
  if (!isPlayingVoice) {
    playNextInQueue();
  }
}

function playNextInQueue() {
  if (voiceQueue.length === 0) {
    isPlayingVoice = false;
    console.log('[VOICE_QUEUE] Queue empty');
    return;
  }
  
  isPlayingVoice = true;
  const item = voiceQueue.shift();
  console.log('[VOICE_QUEUE] Playing next. Remaining:', voiceQueue.length);
  
  try {
    // Check if speech synthesis is supported
    if (!('speechSynthesis' in window)) {
      console.log('Speech synthesis not supported');
      playNextInQueue();
      return;
    }
    
    // Play chime first if specified
    if (item.voiceSettings && item.voiceSettings.chime_file) {
      const chimeAudio = new Audio('/Alarm/' + item.voiceSettings.chime_file);
      chimeAudio.volume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
      chimeAudio.addEventListener('ended', () => {
        playVoiceMessage(item.message, item.voiceSettings, item.symbol, () => {
          // 音声再生完了後、次を再生
          playNextInQueue();
        });
      });
      chimeAudio.play().catch(e => {
        console.log('Chime play error', e);
        playVoiceMessage(item.message, item.voiceSettings, item.symbol, () => {
          playNextInQueue();
        });
      });
    } else {
      playVoiceMessage(item.message, item.voiceSettings, item.symbol, () => {
        playNextInQueue();
      });
    }
  } catch (e) {
    console.log('playNextInQueue error', e);
    playNextInQueue();
  }
}

function playVoiceMessage(message, voiceSettings = null, symbol = null, onComplete = null) {
  // Create utterance
  const utterance = new SpeechSynthesisUtterance(message);
  
  // Get global settings
  const globalVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
  const globalRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
  
  // Apply voice settings (rule-specific or global)
  utterance.lang = 'ja-JP';
  utterance.volume = globalVolume;
  utterance.rate = globalRate;
  
  // Set voice if specified
  if (voiceSettings && voiceSettings.voice_name) {
    const voices = speechSynthesis.getVoices();
    const selectedVoice = voices.find(v => v.name === voiceSettings.voice_name);
    if (selectedVoice) {
      utterance.voice = selectedVoice;
    }
  } else {
    // Use default Japanese voice
    const voices = speechSynthesis.getVoices();
    const japaneseVoice = voices.find(voice => voice.lang.startsWith('ja'));
    if (japaneseVoice) {
      utterance.voice = japaneseVoice;
    }
  }
  
  // 通貨名挿入の場合、一拍の間を入れるために分割発声
  if (voiceSettings && voiceSettings.insert_symbol && symbol) {
    const japaneseName = currencyNames[symbol] || symbol;
    const position = voiceSettings.symbol_insert_position || 'prefix';
    
    let parts = [];
    if (position === 'prefix') {
      parts = [japaneseName, message.replace(japaneseName + ' ', '')];
    } else if (position === 'suffix') {
      parts = [message.replace(' ' + japaneseName, ''), japaneseName];
    } else if (position === 'both') {
      const middleMessage = message.replace(japaneseName + ' ', '').replace(' ' + japaneseName, '');
      parts = [japaneseName, middleMessage, japaneseName];
    }
    
    if (parts.length > 1) {
      // 分割発声
      let currentIndex = 0;
      
      function speakNext() {
        if (currentIndex < parts.length) {
          const partUtterance = new SpeechSynthesisUtterance(parts[currentIndex]);
          partUtterance.lang = utterance.lang;
          partUtterance.volume = utterance.volume;
          partUtterance.rate = utterance.rate;
          partUtterance.voice = utterance.voice;
          
          partUtterance.onend = () => {
            currentIndex++;
            if (currentIndex >= parts.length) {
              // 全パート完了
              if (onComplete) onComplete();
            } else {
              // 一拍の間を入れるために少し遅延
              setTimeout(speakNext, 200); // 200msの間
            }
          };
          
          partUtterance.onerror = () => {
            console.log('Part utterance error');
            if (onComplete) onComplete();
          };
          
          speechSynthesis.speak(partUtterance);
        } else {
          if (onComplete) onComplete();
        }
      }
      
      speakNext();
      return;
    }
  }
  
  // 完了イベントハンドラーを設定
  utterance.onend = () => {
    console.log('Voice message completed');
    if (onComplete) onComplete();
  };
  
  utterance.onerror = (e) => {
    console.log('Voice message error:', e);
    if (onComplete) onComplete();
  };
  
  // Speak
  speechSynthesis.speak(utterance);
  
  console.log('Playing voice message:', message, 'volume:', utterance.volume, 'rate:', utterance.rate);
}
</script>
</body>
</html>
