<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<title>ダウ雲表 v2</title>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script src="https://unpkg.com/sortablejs@1.15.0/Sortable.min.js"></script>
<style>
body { font-family: 'Yu Gothic', 'Meiryo', sans-serif; background: #1e3c72; color: #fff; padding: 0 !important; margin: 0 !important; }
.container { max-width: none; margin: 0 !important; padding: 0; }
.header-row { display:flex; align-items:center; justify-content:space-between; padding: 10px 10px 12px 6px; margin: 0 8px 14px 6px; border-bottom: 1px solid rgba(255,255,255,0.45); }
h1 { text-align: left; margin: 0; font-size: 1.55em; letter-spacing: 0.4px; text-shadow: none; }
.datetime-section { display: flex; align-items: center; gap: 15px; flex: 1; justify-content: center; }
.datetime-small { font-size: 0.8em; color: #bbb; font-weight: 700; font-family: 'Helvetica', 'Arial', sans-serif; }
.datetime-large { font-size: 1.8em; font-weight: bold; color: #4ade80; font-family: 'Helvetica', 'Arial', sans-serif; }
.right-section { display: flex; align-items: center; gap: 15px; }
#dashboard { margin: 0; padding: 0 8px 0 6px; }
/* 設定パネルスタイル */
.settings { display: flex; gap: 12px; justify-content: flex-end; align-items: center; margin-bottom: 12px; }
.settings label { color: #fff; font-size: 0.95em; }
.settings select, .settings input[type="radio"] { margin-left: 6px; }

/* 設定モーダル */
.settings-button { background:transparent;color:#f5f7ff;border:1px solid rgba(255,255,255,0.8);padding:7px 16px;border-radius:999px;cursor:pointer;display:flex;align-items:center;gap:6px;transition:background 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
.settings-button::before { content:'\2699'; font-size:1.05em; }
.settings-button:hover { background:rgba(255,255,255,0.15); color:#ffffff; }

/* ツールボタン（サイドメニュー用） */
.tools-button { background:transparent;color:#f5f7ff;border:1px solid rgba(255,255,255,0.8);padding:7px 16px;border-radius:999px;cursor:pointer;display:flex;align-items:center;gap:6px;transition:background 0.2s ease, color 0.2s ease, border-color 0.2s ease; }
.tools-button::before { content:'\2630'; font-size:1.05em; }
.tools-button:hover { background:rgba(255,255,255,0.15); color:#ffffff; }

/* サイドメニュー用オーバーレイ */
.side-menu-overlay { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); display:none; z-index:9998; opacity:0; transition:opacity 0.3s; }
.side-menu-overlay.active { display:block; opacity:1; }

/* サイドメニュー */
.side-menu { position:fixed; top:0; right:-180px; width:180px; height:auto; background:rgba(30,60,114,0.98); backdrop-filter:blur(10px); box-shadow:-2px 0 15px rgba(0,0,0,0.4); z-index:9999; transition:right 0.3s ease-out; display:flex; flex-direction:column; border-left:1px solid rgba(255,255,255,0.15); border-radius:0 0 0 8px; }
.side-menu.active { right:0; }
.side-menu-header { padding:10px 12px; background:rgba(0,0,0,0.3); border-bottom:1px solid rgba(255,255,255,0.15); display:flex; justify-content:space-between; align-items:center; }
.side-menu-header h2 { font-size:1em; margin:0; color:#f5f7ff; font-weight:normal; }
.side-menu-close { background:none; border:none; color:#f5f7ff; font-size:1.1em; cursor:pointer; padding:0; width:20px; height:20px; display:flex; align-items:center; justify-content:center; transition:transform 0.2s, opacity 0.2s; opacity:0.8; }
.side-menu-close:hover { transform:scale(1.2); opacity:1; }
.side-menu-items { flex:1; overflow-y:auto; padding:5px 0; }
.side-menu-item { padding:8px 12px; border:none; background:none; cursor:pointer; width:100%; text-align:left; font-size:0.8em; color:#f5f7ff; border-bottom:1px solid rgba(255,255,255,0.08); transition:all 0.2s; display:flex; align-items:center; gap:8px; }
.side-menu-item:hover { background:rgba(255,255,255,0.1); padding-left:16px; }
.side-menu-item.window-open { background:rgba(74,222,128,0.15); border-left:3px solid #4ade80; }
.side-menu-item .menu-icon { font-size:1em; width:18px; text-align:center; }
.side-menu-item .menu-status { margin-left:auto; font-size:0.8em; opacity:0.6; }
.modal-overlay { position:fixed; left:0;top:0;right:0;bottom:0; background: rgba(0,0,0,0.4); display:none; align-items:center; justify-content:center; z-index:9999 }
  .modal { background:rgba(255,255,255,0.18); color:#f5f7ff; padding:20px 22px; border-radius:14px; min-width:280px; position:relative; cursor:move; user-select:none; backdrop-filter:blur(14px); -webkit-backdrop-filter:blur(14px); border:1px solid rgba(255,255,255,0.35); box-shadow:0 18px 40px rgba(0,0,0,0.35); max-height:90vh; overflow:auto; resize:both; min-height:200px; }
  .modal .resize-handle { position:absolute; right:0; bottom:0; width:20px; height:20px; cursor:nwse-resize; background:linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.3) 50%); border-radius:0 0 14px 0; }
  .modal .resize-handle:hover { background:linear-gradient(135deg, transparent 50%, rgba(255,255,255,0.5) 50%); }
.modal h3 { margin-top:0; cursor:move; font-weight:600; letter-spacing:0.5px; }
.modal .row { margin-bottom:12px }
.modal label { color:#f5f7ff; }
.modal select, .modal input[type="checkbox"], .modal input[type="radio"] { accent-color:#7ea6ff; }
.modal select { min-width:140px; background:rgba(15,27,65,0.7); color:#f5f7ff; border:1px solid rgba(255,255,255,0.35); border-radius:8px; padding:6px 10px; box-shadow:inset 0 0 0 1px rgba(255,255,255,0.15); }
.modal button { background:rgba(10,20,55,0.6) !important; color:#f5f7ff !important; border:1px solid rgba(255,255,255,0.35) !important; padding:6px 12px !important; border-radius:8px !important; box-shadow:0 8px 18px rgba(0,0,0,0.35); transition:background 0.2s ease, transform 0.2s ease; }
.modal button:hover { background:rgba(30,60,140,0.7) !important; transform:translateY(-1px); }
  .modal .section-header { background:#000; color:#fff; padding:6px 10px; margin:8px 0 10px 0; border-radius:6px; font-weight:600; font-size:0.95em; letter-spacing:0.3px; display:flex; justify-content:space-between; align-items:center; cursor:pointer; }
  .modal .section-header::after { content: '+'; font-size:1.2em; margin-left:auto; transition:transform 0.3s ease; }
  .modal .section-header.active::after { content: '-'; }
  .section-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.5em; line-height:1; padding:0; margin:0; transition:transform 0.2s ease; }
  .section-toggle:hover { transform:scale(1.15); }
  .subsection-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; cursor:pointer; padding-right:30px; }
  .subsection-header::after { content: '+'; font-size:1.2em; position:absolute; right:8px; transition:transform 0.3s ease; }
  .subsection-header.active::after { content: '-'; }
  .subsection-body {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.6s ease-in-out;
  }
  .subsection-body.active {
    max-height: 2000px; /* 十分な高さに設定 */
  }
  .subsection-toggle { background:transparent; border:none; color:inherit; cursor:pointer; font-size:1.2em; line-height:1; padding:2px 6px; margin:0; transition:transform 0.2s ease; }
  .subsection-toggle:hover { opacity:0.7; }

  .modal .section-body {
    font-size: 0.9em;
    font-weight: 400; /* reduced weight for subitems */
    color: inherit;
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.6s ease-in-out;
  }
  .modal .section-body.active {
    max-height: 2000px; /* 十分な高さに設定 */
  }
  .modal .section-body label,
  .modal .section-body select,
  .modal .section-body button,
  .modal .section-body input,
  .modal .section-body .col-toggle + label,
  .modal .section-body .row-toggle + label {
    font-size: 0.9em;
    font-weight: 400; /* reduced weight for subitems */
    color: inherit;
  }

/* ノート項目スタイル */
.note-section {
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 12px;
  background: rgba(0,0,0,0.1);
  transition: opacity 0.2s, border-top 0.2s;
}

.note-section[draggable="true"] {
  cursor: grab;
}

.note-section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  gap: 8px;
}

.note-section-title {
  flex: 1;
  min-width: 100px;
  padding: 4px 8px;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 4px;
  background: rgba(15,27,65,0.7);
  color: inherit;
  font-family: inherit;
  font-size: 14px;
  font-weight: 600;
}

.note-section-content {
  width: 100%;
  min-height: 80px;
  padding: 8px;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 6px;
  background: rgba(15,27,65,0.7);
  color: inherit;
  font-family: inherit;
  font-size: 14px;
  resize: vertical;
  box-sizing: border-box;
}

/* ノートモーダル用の特別なスタイル */
#noteModal .modal {
  display: flex !important;
  flex-direction: column !important;
  max-height: none !important;
  overflow: hidden !important;
  resize: none !important;
}

.note-section-delete {
  background: #dc3545;
  color: #fff;
  border: none;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  margin-left: 8px;
}

.note-section-delete:hover {
  background: #c82333;
}

.add-note-section-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  margin-top: 8px;
  transition: background 0.2s ease;
}

.add-note-section-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
.light-mode { background: #f5f5f5 !important; color: #111 !important; }
.light-mode .header-row { border-bottom: 1px solid rgba(0,0,0,0.5); }
.light-mode h1 { color: #111 !important; }
.light-mode .settings-button { color:#111; border-color: rgba(0,0,0,0.7); }
.light-mode .settings-button:hover { background: rgba(0,0,0,0.08); color:#000; }
.light-mode .tools-button { color:#111; border-color: rgba(0,0,0,0.7); }
.light-mode .tools-button:hover { background: rgba(0,0,0,0.08); color:#000; }
.light-mode .modal-overlay { background: rgba(255,255,255,0.7); }
.light-mode .modal { background:rgba(255,255,255,0.95); color:#111; border:1px solid rgba(0,0,0,0.3); box-shadow:0 18px 40px rgba(0,0,0,0.15); }
.light-mode .modal h3 { color:#111; }
.light-mode .modal label { color:#111; }
.light-mode .modal select { background:#2157ec; color:#fff; border:1px solid #2157ec; }
.light-mode select { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; }
.light-mode .modal input[type="checkbox"], .light-mode .modal input[type="radio"] { accent-color:#2157ec; }
.light-mode .modal button { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; box-shadow:0 8px 18px rgba(0,0,0,0.1); }
.light-mode .modal button:hover { background:#1540b8 !important; border-color:#1540b8 !important; }
.light-mode .modal .section-header { background:#e8e8e8; color:#111; border:1px solid rgba(0,0,0,0.1); }
.light-mode .cond-tf, .light-mode .cond-field, .light-mode .cond-op { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; }
.light-mode .rule-btn { background:#2157ec !important; color:#fff !important; border:1px solid #2157ec !important; }
/* Make the small datetime legible in light mode */
.light-mode .datetime-small {
  color: #000 !important;
}
.light-mode .rule-btn:hover { background:#1540b8 !important; border-color:#1540b8 !important; }
.light-mode input[type="text"], .light-mode input[type="number"], .light-mode textarea { border:1px solid #ccc !important; background:#fff !important; color:#111 !important; }
.light-mode #ruleName, .light-mode #voiceMessage, .light-mode #voiceMessageUp, .light-mode #voiceMessageDown, .light-mode .cond-value { border:1px solid #2157ec !important; }
.light-mode #alignMissingTooltip { color:#000 !important; }
.dark-mode #alignMissingTooltip { color:#fff !important; }
.dark-mode { background: #1e3c72 !important; color: #fff !important; }

table { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; width: auto; border-collapse: collapse; background: #fff; color: #333; table-layout: auto; margin: 0; }
/* テーブルを角丸にするためのラッパー */
.table-wrap { border-radius: 8px; overflow: hidden; display: inline-block; }
th, td { padding: 4px; border: 1px solid #ddd; text-align: center; white-space: nowrap; width: auto; }
th { font-family: Arial; background: #667eea; color: white; }
.tf-label { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; color: #667eea; }
.up { color: #2962ff; font-weight: bold; }
.down { color: #ef4444; font-weight: bold; }
.loading { text-align: left; padding: 50px; }

/* 新規スタイル */
.header-black { background: #000 !important; color: #fff !important; }
.cell-black { background: #000 !important; color: #fff !important; }
.col-cloud-label { color: #000 !important; }
.price-row td:first-child { background: #fff !important; color: #000 !important; font-weight: bold; }
/* ヘッダーは現状のまま維持し、データ部(td)のみフォントを一段階細くする */
table th { font-weight: bold; font-size: 1.1em; }
table td { font-family: 'Yu Gothic', 'Meiryo', sans-serif !important; font-weight: 600; font-size: 1.1em; }
/* ダウ時間(9列目) と 交差時間(10列目) を右揃えにする */
table th:nth-child(9), table td:nth-child(9),
table th:nth-child(10), table td:nth-child(10),
table th:nth-child(11), table td:nth-child(11) {
  text-align: right;
}
/* ヘッダーのダウ時間と交差時間をセンター揃え */
table th:nth-child(9), table th:nth-child(10), table th:nth-child(11) {
  text-align: center;
}

/* ドラッグ&ドロップ用のスタイル */
.currency-cell {
  display: flex;
  align-items: center;
  gap: 6px;
  user-select: none;
}

.drag-handle {
  cursor: grab;
  color: #999;
  font-weight: bold;
  flex-shrink: 0;
  width: 16px;
  text-align: center;
  font-size: 0.9em;
}

.drag-handle:active {
  cursor: grabbing;
}

.dragging-row {
  opacity: 0.5;
  background: #e3f2fd;
}

.sortable-ghost {
  opacity: 0.4;
}

/* 発火履歴ウィンドウ */
.main-content { display: flex; flex-direction: column; gap: 1px; align-items: flex-start; padding-left: 6px; }
#dashboard { flex: 0 0 auto; }
#fire-history { 
  flex: 0 0 300px; 
  background: rgba(255,255,255,0.1); 
  border: 1px solid rgba(255,255,255,0.25); 
  border-radius: 8px; 
  padding: 12px; 
  overflow: hidden;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
  max-height: calc(100vh - 200px);
}

/* 通貨ごとのコンテナ */
.currency-section {
  display: flex;
  gap: 15px;
  align-items: flex-start;
  padding-bottom: 15px;
  border-bottom: 1px solid rgba(255,255,255,0.1);
  margin-bottom: 15px;
}
.currency-section.hidden {
  display: none;
}
.currency-dashboard {
  flex: 0 0 auto;
}
.currency-fire-history {
  flex: 1 1 auto;
  min-width: 300px;
  max-width: calc(100vw - 400px);
  background: rgba(255,255,255,0.1);
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 8px;
  padding: 12px;
  overflow: hidden;
  backdrop-filter: blur(8px);
  display: flex;
  flex-direction: column;
  box-sizing: border-box;
}
.currency-fire-history-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
.currency-fire-history h3 {
  margin: 0;
  font-size: 1em;
  color: #f5f7ff;
  font-weight: 600;
}
.currency-fire-history button {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
.currency-fire-history button:hover {
  background: rgba(102, 126, 234, 0.4);
}
.currency-fire-history button:first-child {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
.currency-fire-history button:first-child:hover {
  background: rgba(102, 126, 234, 0.4);
}
.rule-count-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
  margin-left: 8px;
}
.rule-count-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
.currency-fire-history-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  max-height: 100%;
}
.fire-item {
  padding: 8px;
  margin-bottom: 6px;
  background: rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  font-size: 0.9em;
  border-left: 3px solid #667eea;
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.fire-item:hover {
  background: rgba(0, 0, 0, 0.3);
}
.fire-time {
  color: #a0c4ff;
  font-weight: 600;
  white-space: nowrap;
}
.fire-name {
  color: #ffd700;
  font-weight: 600;
}
.fire-direction {
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 0.85em;
}
.direction-up {
  background: #2962ff;
  color: #ffffff;
  border: 1px solid #2962ff;
}
.direction-down {
  background: #f23645;
  color: #ffffff;
  border: 1px solid #f23645;
}
.light-mode .currency-fire-history {
  background: rgba(0, 0, 0, 0.05);
  border-color: rgba(0, 0, 0, 0.2);
}
.light-mode .currency-fire-history-header {
  border-bottom-color: rgba(0, 0, 0, 0.2);
}
/* Light mode: make titles and buttons dark for readability */
.light-mode .currency-fire-history h3,
.light-mode #fire-history h3,
.light-mode .currency-fire-history .currency-fire-history-header h3 {
  color: #111 !important;
}
.light-mode .currency-fire-history button,
.light-mode #test-fire-btn,
.light-mode #clear-fire-history-btn {
  background: rgba(0,0,0,0.05);
  color: #111;
  border-color: rgba(0,0,0,0.6);
}
.light-mode .currency-fire-history button:hover,
.light-mode #test-fire-btn:hover,
.light-mode #clear-fire-history-btn:hover {
  background: rgba(0,0,0,0.08);
}
.light-mode .currency-fire-history button:first-child {
  background: rgba(0,0,0,0.05);
  color: #111;
  border-color: rgba(0,0,0,0.6);
}
.light-mode .currency-fire-history button:first-child:hover {
  background: rgba(0,0,0,0.08);
}
.light-mode .rule-count-btn {
  background: rgba(0,0,0,0.05);
  color: #111;
  border-color: rgba(0,0,0,0.6);
}
.light-mode .rule-count-btn:hover {
  background: rgba(0,0,0,0.08);
}
.light-mode .fire-item {
  background: rgba(0, 0, 0, 0.08);
  border-left-color: #667eea;
}
.light-mode .fire-time {
  color: #2962ff;
}
.light-mode .fire-name {
  color: #d97706;
}

/* 経済指標カレンダーセクションのライトモード対応 */
.light-mode #economic-calendar-section {
  background: rgba(0,0,0,0.05);
  border-color: rgba(0,0,0,0.2);
}
.light-mode #economic-calendar-section h3 {
  color: #111;
}
.light-mode .fire-direction {
  border-width: 1px;
}
.light-mode .direction-up {
  background: #2962ff;
  color: #ffffff;
  border-color: #2962ff;
}
.light-mode .direction-down {
  background: #f23645;
  color: #ffffff;
  border-color: #f23645;
}

#fire-history-header { 
  display: flex; 
  justify-content: space-between; 
  align-items: center; 
  margin-bottom: 10px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(255,255,255,0.2);
  flex-shrink: 0;
}
#fire-history h3 { 
  margin: 0; 
  font-size: 1em;
  color: #f5f7ff; 
  font-weight: 600;
}
#test-fire-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
#test-fire-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
#clear-fire-history-btn {
  background: rgba(102, 126, 234, 0.2);
  color: #667eea;
  border: 1px solid #667eea;
  padding: 4px 10px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  transition: background 0.2s ease;
  flex-shrink: 0;
}
#clear-fire-history-btn:hover {
  background: rgba(102, 126, 234, 0.4);
}
#fire-history-list {
  flex: 1;
  overflow-y: auto;
  min-height: 0;
  max-height: 100%;
}
.fire-item { 
  padding: 8px; 
  margin-bottom: 6px; 
  background: rgba(0,0,0,0.2); 
  border-radius: 6px; 
  font-size: 0.9em; 
  border-left: 3px solid #667eea;
  display: flex;
  gap: 8px;
  align-items: baseline;
}
.fire-item:hover { background: rgba(0,0,0,0.3); }
.fire-time { color: #a0c4ff; font-weight: 600; white-space: nowrap; }
.fire-name { color: #ffd700; font-weight: 600; }
.light-mode #fire-history { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.2); }
.light-mode #fire-history-header { border-bottom-color: rgba(0,0,0,0.2); }
.light-mode #test-fire-btn { background: rgba(0,0,0,0.05); color: #111; border-color: rgba(0,0,0,0.6); }
.light-mode #test-fire-btn:hover { background: rgba(0,0,0,0.08); }
.light-mode #clear-fire-history-btn { background: rgba(0,0,0,0.05); color: #111; border-color: rgba(0,0,0,0.6); }
.light-mode #clear-fire-history-btn:hover { background: rgba(0,0,0,0.08); }
.light-mode .fire-item { background: rgba(0,0,0,0.08); border-left-color: #667eea; }
.light-mode .fire-time { color: #2962ff; }
.light-mode .fire-name { color: #d97706; }

/* Dark mode: make fire-history buttons high-contrast (white text + white-ish border) */
.dark-mode .currency-fire-history button,
.dark-mode #test-fire-btn,
.dark-mode #clear-fire-history-btn {
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.9);
}
.dark-mode .currency-fire-history button:hover,
.dark-mode #test-fire-btn:hover,
.dark-mode #clear-fire-history-btn:hover {
  background: rgba(255,255,255,0.06);
}
.dark-mode .currency-fire-history button:first-child {
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.9);
}
.dark-mode .currency-fire-history button:first-child:hover {
  background: rgba(255,255,255,0.06);
}
.dark-mode .rule-count-btn {
  background: transparent;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.9);
}
.dark-mode .rule-count-btn:hover {
  background: rgba(255,255,255,0.06);
}

/* Light mode adjustments */
.light-mode .modal {
  color: #111 !important;
  background: rgba(255,255,255,0.05) !important;
}
.light-mode .modal select {
  color: #f5f7ff !important;
}
#economic-calendar-section {
  display: flex;
  flex-direction: column;
  transition: min-height 0.3s ease;
}
#economic-calendar-section.hidden {
  min-height: auto !important;
  height: auto !important;
  resize: none !important;
}
#economic-calendar-section.hidden .section-body {
  display: none !important;
}
#external-site-window.hidden {
  min-height: auto !important;
  height: auto !important;
  resize: none !important;
}
#external-site-window.hidden .window-body {
  display: none !important;
}
#economic-calendar-section .section-header {
  background:#000; color:#fff; padding:6px 10px; margin: 0 0 0 0; border-radius:6px; font-weight:600; font-size:0.95em; letter-spacing:0.3px; display:flex; justify-content:space-between; align-items:center; flex-shrink: 0;
}
#economic-calendar-visibility {
  display: flex;
  gap: 8px;
  align-items: center;
}
#economic-calendar-visibility label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 0.9em;
  cursor: pointer;
  margin: 0;
}
#economic-calendar-visibility input[type="radio"] {
  cursor: pointer;
  margin: 0;
}
#economic-calendar-section .section-body {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

/* ルール編集セクションの左右パネル */
.rules-side-panel {
  overflow-y: auto;
  padding-right: 8px;
  display: flex;
  flex-direction: column;
}
.rules-side-panel::-webkit-scrollbar {
  width: 6px;
}
.rules-side-panel::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.1);
  border-radius: 3px;
}
.rules-side-panel::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.3);
  border-radius: 3px;
}
.rules-side-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(255,255,255,0.5);
}
.light-mode .rules-side-panel::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.05);
}
.light-mode .rules-side-panel::-webkit-scrollbar-thumb {
  background: rgba(0,0,0,0.2);
}
.light-mode .rules-side-panel::-webkit-scrollbar-thumb:hover {
  background: rgba(0,0,0,0.4);
}

/* ルールリストのドラッグ&ドロップスタイル */
#rulesList li {
  transition: background-color 0.2s, transform 0.1s;
}
#rulesList li:hover {
  background: rgba(255,255,255,0.05);
}
#rulesList li.dragging {
  opacity: 0.5;
  background: rgba(100,149,237,0.3);
}
#rulesList li.drag-over {
  border-top: 2px solid #4ade80;
}
.light-mode #rulesList li:hover {
  background: rgba(0,0,0,0.05);
}
.light-mode #rulesList li.dragging {
  background: rgba(100,149,237,0.2);
}

/* スライドトグルスタイル */
.rule-toggle-slider {
  appearance: none;
  -webkit-appearance: none;
  width: 36px;
  height: 20px;
  border: none;
  border-radius: 10px;
  background: #555;
  cursor: pointer;
  transition: all 0.3s;
  flex-shrink: 0;
  position: relative;
}
.rule-toggle-slider:checked {
  background: #4a90d9;
}
.rule-toggle-slider::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 16px;
  height: 16px;
  background: white;
  border-radius: 50%;
  transition: left 0.3s;
}
.rule-toggle-slider:checked::after {
  left: 18px;
}
.rule-toggle-slider:hover {
  box-shadow: 0 0 8px rgba(74, 144, 217, 0.5);
}

/* 外部サイト表示ウィンドウ */
#external-site-window {
  margin-top: 15px;
  border: 1px solid rgba(255,255,255,0.25);
  border-radius: 8px;
  padding: 0;
  background: rgba(255,255,255,0.1);
  resize: both;
  overflow: hidden;
  min-width: 300px;
  min-height: 200px;
  width: 600px;
  height: 400px;
  display: flex;
  flex-direction: column;
}
#external-site-window .window-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #000;
  color: #fff;
  padding: 6px 10px;
  font-weight: 600;
  font-size: 0.95em;
  cursor: move;
  user-select: none;
}
#external-site-window .window-header h3 {
  margin: 0;
  font-size: 1.2em;
  color: #f5f7ff;
}
#external-site-window .window-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}
#external-site-window .window-controls select,
#external-site-window .window-controls input {
  background: rgba(128,128,128,0.5);
  color: #f5f7ff;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 11px;
}
#external-site-window .window-body {
  flex: 1;
  overflow: hidden;
  position: relative;
}
#external-site-window iframe {
  border: 0;
  width: 100%;
  height: 100%;
}
.light-mode #external-site-window {
  background: rgba(0,0,0,0.05);
  border-color: rgba(0,0,0,0.2);
}
.light-mode #external-site-window .window-header {
  background: #e8e8e8;
  color: #111;
}
.light-mode #external-site-window .window-header h3 {
  color: #111;
}
</style>
</head>
<body>
<div class="container">
<!-- タイトルと設定ボタンを横並び -->
<div class="header-row">
  <h1>■</h1>
  <div class="datetime-section">
    <span class="datetime-small">2025[R07]11/17 月</span>
    <span class="datetime-large">14:32:45</span>
  </div>
  <div class="right-section">
    <div id="marketStatus" style="display:flex; align-items:center; gap:8px; padding:6px 12px; border-radius:6px; font-size:0.9em; background:rgba(255,255,255,0.08);">
      <span style="width:8px; height:8px; border-radius:50%; background:#90EE90; display:inline-block;" id="marketStatusLight"></span>
      <span id="marketStatusText">市場チェック中...</span>
    </div>
    <button id="openToolsMenu" class="tools-button">Tool</button>
  </div>
</div>

<!-- サイドメニュー用オーバーレイ -->
<div class="side-menu-overlay" id="sideMenuOverlay"></div>

<!-- サイドメニュー -->
<div class="side-menu" id="sideMenu">
  <div class="side-menu-header">
    <h2>Tool</h2>
    <button class="side-menu-close" id="closeSideMenu">✕</button>
  </div>
  <div class="side-menu-items">
    <button class="side-menu-item" id="menuSettings">
      <span class="menu-icon">⚙️</span>
      <span>設定</span>
      <span class="menu-status" id="statusSettings"></span>
    </button>
    <button class="side-menu-item" id="menuNote">
      <span class="menu-icon">📝</span>
      <span>Note</span>
      <span class="menu-status" id="statusNote"></span>
    </button>
    <button class="side-menu-item" id="menuEconomicCalendar">
      <span class="menu-icon">📊</span>
      <span>経済指標</span>
      <span class="menu-status" id="statusEconomicCalendar"></span>
    </button>
    <button class="side-menu-item" id="menuShepherdColumn">
      <span class="menu-icon">🐑</span>
      <span>羊飼い</span>
      <span class="menu-status" id="statusShepherdColumn"></span>
    </button>
    <button class="side-menu-item" id="menuTimer">
      <span class="menu-icon">⏱️</span>
      <span>確定タイマー</span>
      <span class="menu-status" id="statusTimer"></span>
    </button>
  </div>
</div>

<!-- 設定モーダル（初期は非表示） -->
<div class="modal-overlay" id="settingsModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle" style="display:flex;flex-direction:column;">
  <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <h3 id="settingsTitle" style="margin:0">各項目設定</h3>
    <button id="closeSettings" style="background:#333;color:#fff;border:none;padding:6px 12px;border-radius:4px;cursor:pointer">閉じる</button>
  </div>
    
    <!-- 表示調整セクション -->
  <div class="section-header" data-section="displayAdjust">表示調整</div>
  <div class="section-body" data-section-body="displayAdjust">
  <div class="row">
      <label>モード</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="dark" id="modeDark"> ダーク</label>
      <label style="margin-left:8px"><input type="radio" name="mode" value="light" id="modeLight"> ライト</label>
    </div>
    <div class="row">
      <label for="fontSizeSelect">文字サイズ</label>
      <select id="fontSizeSelect" aria-label="表の文字サイズ">
        <option value="10">10px</option>
        <option value="11">11px</option>
        <option value="12">12px</option>
        <option value="13">13px</option>
        <option value="14">14px</option>
        <option value="15">15px</option>
        <option value="16">16px</option>
        <option value="17">17px</option>
        <option value="18">18px</option>
      </select>
    </div>
    <div class="row">
      <label for="timeFormatSelect">経過時間の表示</label>
      <select id="timeFormatSelect" aria-label="経過時間の表示形式">
        <option value="datetime">測定開始日時</option>
        <option value="dhm">日/時/分</option>
        <option value="hm">時/分</option>
        <option value="m">分のみ</option>
      </select>
    </div>
    <div class="row">
      <label><input type="checkbox" id="enable5mUpdateToggle" checked style="margin-right:8px;"> 5分毎更新有効</label>
    </div>
    
    <!-- 列の表示セクション -->
  </div>
  <div class="section-header" data-section="columns">列の表示</div>
  <div class="section-body" data-section-body="columns">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="1" checked> ダウ転</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="2" checked> 突破数</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="3" checked> 雲交差</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="4" checked> 各雲間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="5" checked> 価格間</label>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="6" checked> 雲角度</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="7" checked> 雲厚み</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="8" checked> ダウ時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="9" checked> 交差時間</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="10" checked> 時間差</label>
        <label style="font-size:0.9em"><input type="checkbox" class="col-toggle" data-col="11" checked> トレンド</label>
      </div>
    </div>
    
    <!-- 行の表示セクション -->
  </div>
  <div class="section-header" data-section="rows">行の表示</div>
  <div class="section-body" data-section-body="rows">
  <div class="row">
      <div style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="5m" checked> 5m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="15m" checked> 15m</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="1H" checked> 1H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="4H" checked> 4H</label>
        <label style="font-size:0.9em"><input type="checkbox" class="row-toggle" data-row="price" checked> 価格</label>
      </div>
    </div>
    
    <!-- 通貨フィルターセクション -->
  </div>
  <div class="section-header" data-section="currencies">通貨フィルター</div>
  <div class="section-body" data-section-body="currencies">
  <div class="row">
      <div id="currencyFilterContainer" style="display:flex;flex-wrap:wrap;gap:6px;margin-top:4px">
        <!-- 通貨チェックボックスは動的に生成されます -->
      </div>
  </div>
  </div>

    <!-- 音声設定セクション（グローバル設定のみ） -->
    <div class="section-header" data-section="voice">音声設定</div>
    <div class="section-body" data-section-body="voice">
    <div class="row">
      <label for="voiceVolume">音量</label>
      <input type="range" id="voiceVolume" min="0" max="1" step="0.01" value="0.8" aria-label="音量" style="min-width:150px;">
      <span id="voiceVolumeValue" style="margin-left:8px">80%</span>
    </div>
    <div class="row">
      <label for="voiceRate">音速</label>
      <input type="range" id="voiceRate" min="0.5" max="2.0" step="0.1" value="1.0" aria-label="音速" style="min-width:150px;">
      <span id="voiceRateValue" style="margin-left:8px">1.0x</span>
    </div>
    </div>

    <!-- 発火条件セクション -->
    <div class="section-header" data-section="rules">発火条件（ルール）</div>
    <div class="section-body" data-section-body="rules" style="flex:1;display:flex;flex-direction:column;min-height:0;">
    <div class="row" style="display:flex;flex-direction:column;gap:10px;flex:1;min-height:0;">
      <button id="newRuleBtn" class="rule-btn" style="align-self:flex-start;padding:6px 12px">新規ルール作成</button>
      
      <!-- 左右並びコンテナ -->
      <div style="display:flex;gap:12px;width:100%;flex:1;min-height:0;">
        <!-- 左側: 保存済みルール -->
        <div class="rules-side-panel" style="flex:0 0 auto;border:1px solid rgba(255,255,255,0.08);padding:8px;border-radius:8px;background:rgba(0,0,0,0.12);">
          <div style="font-weight:600;margin-bottom:8px;padding-bottom:6px;border-bottom:1px solid rgba(255,255,255,0.1);display:flex;justify-content:space-between;align-items:center;">
            <strong>保存済みルール</strong>
            <label style="display:flex;align-items:center;gap:6px;font-size:0.85em;font-weight:normal;cursor:pointer;">
              <input type="checkbox" id="showEnabledOnly" class="rule-toggle-slider">
              <span>有効のみ</span>
            </label>
          </div>
          <ul id="rulesList" style="list-style:none;padding:0;margin:0;display:block"></ul>
        </div>

        <!-- 右側: ルール編集 -->
        <div class="rules-side-panel" style="flex:1;border:1px solid rgba(255,255,255,0.08);padding:8px;border-radius:8px;background:rgba(0,0,0,0.06);">
          <div style="font-weight:600;margin-bottom:8px;padding-bottom:6px;border-bottom:1px solid rgba(255,255,255,0.1);">
            <strong>ルール編集</strong>
          </div>
          <div style="display:flex;flex-direction:column;gap:8px;width:100%">
            <div style="display:flex;align-items:center;gap:8px">
              <label style="font-size:0.9em;min-width:72px">ルール名：</label>
              <input id="ruleName" placeholder="ルール名" style="flex:1;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit">
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <label style="font-size:0.9em;min-width:72px">通貨選択：</label>
              <select id="ruleScope" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:160px">
                <option value="">全選択</option>
              </select>
            </div>
          </div>
          
          <!-- 音声設定（ルール個別設定） -->
          <div style="margin-top:12px;padding:8px;border-radius:6px;background:rgba(0,0,0,0.04);">
            <div style="font-weight:600;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center">
              <span>音声設定</span>
              <button id="testVoiceBtn" class="rule-btn" style="padding:6px 12px;">音声テスト</button>
            </div>
            <div style="display:flex;flex-direction:column;gap:6px">
              <label style="font-size:0.9em">
                音声メッセージ:
                <input id="voiceMessage" placeholder="例: ルールが発火しました" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:300px">
              </label>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <input type="checkbox" id="insertSymbol" style="cursor:pointer;flex-shrink:0"> 
                  <span onclick="document.getElementById('insertSymbol').click()" style="cursor:pointer;user-select:none">通貨名挿入</span>
                </div>
                <select id="symbolInsertPosition" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:104px">
                  <option value="prefix">先頭</option>
                  <option value="suffix">最後</option>
                  <option value="both">先頭と最後</option>
                </select>
              </div>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <input type="checkbox" id="voiceDirectionBased" style="cursor:pointer;flex-shrink:0">
                  <span onclick="document.getElementById('voiceDirectionBased').click()" style="cursor:pointer;user-select:none">方向別挿入</span>
                </div>
                <select id="voiceMessagePosition" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:104px">
                  <option value="prefix">先頭</option>
                  <option value="suffix">最後</option>
                  <option value="both">先頭と最後</option>
                </select>
              </div>
              <div id="directionMessages" style="display:none;flex-direction:row;gap:12px;margin-left:8px;align-items:center">
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  上昇：
                  <input id="voiceMessageUp" placeholder="例: 上昇トレンドが検出されました" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
                <label style="font-size:0.9em;display:flex;align-items:center;gap:4px">
                  下降：
                  <input id="voiceMessageDown" placeholder="例: 下降トレンドが検出されました" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:transparent;color:inherit;width:144px">
                </label>
              </div>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <input type="checkbox" id="playChimeFirst" style="cursor:pointer;flex-shrink:0">
                  <span onclick="document.getElementById('playChimeFirst').click()" style="cursor:pointer;user-select:none">電子音挿入</span>
                </div>
                <select id="chimeSelect" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:104px">
                  <option value="">なし</option>
                </select>
              </div>
              <div style="font-size:0.9em;display:flex;align-items:center">
                <div style="display:flex;align-items:center;gap:6px;flex:1">
                  <span>声優選択項目</span>
                </div>
                <select id="voiceSelect" style="margin-left:8px;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);background:rgba(15,27,65,0.7);color:inherit;min-width:200px">
                  <option value="">グローバル設定を使用</option>
                  <!-- 音声リストは動的に追加 -->
                </select>
              </div>
            </div>
          </div>
          
          <!-- 雲整列条件 UI（ユーザー指定レイアウト） -->
          <div style="display:flex;flex-direction:column;gap:8px;margin-top:6px;padding:6px;border-radius:6px;background:rgba(0,0,0,0.02);">
            <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">
              <strong style="margin-right:6px">雲整列条件</strong>
              <label style="font-size:0.9em"><input type="checkbox" id="alignAllTf"> 全時間</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="5m"> 5m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="15m"> 15m</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="1H"> 1H</label>
              <label style="font-size:0.9em"><input type="checkbox" class="align-tf" data-tf="4H"> 4H</label>
            </div>
            <div style="display:flex;align-items:center;gap:12px">
              <div style="display:flex;align-items:center;gap:8px">
                <label style="font-size:0.9em">欠損</label>
                <select id="alignMissing" style="padding:6px;border-radius:6px;background:rgba(15,27,65,0.7);color:inherit;border:1px solid rgba(255,255,255,0.12)">
                  <option value="ignore">無視</option>
                  <option value="fail">不一致</option>
                </select>
                <span id="alignMissingTooltip" style="cursor:pointer;font-size:1.2em;">ⓘ</span>
              </div>
            </div>
            <div id="alignError" style="color:#ffb4b4;font-weight:600;margin-top:6px;display:none;width:100%"></div>
          </div>
          <div id="conditionsContainer" style="display:flex;flex-direction:column;gap:6px">
            <!-- 単純な1条件行のテンプレート -->
            <div class="cond-row" style="display:flex;gap:6px;align-items:center">
              <select class="cond-tf" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="5m">5m</option>
                <option value="15m">15m</option>
                <option value="1H">1H</option>
                <option value="4H">4H</option>
              </select>
              <select class="cond-field" style="padding:6px;border-radius:6px;background:transparent;color:inherit">
                <option value="dauten">ダウ転</option>
                <option value="bos_count">突破数</option>
                <option value="gc">雲交差</option>
                <option value="distance_from_prev">各雲間</option>
                <option value="distance_from_price">価格間</option>
                <option value="angle">雲角度</option>
                <option value="thickness">雲厚み</option>
                <option value="transfer_time_diff">転換時間差</option>
              </select>
              <input class="cond-value" placeholder="値" style="padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.08);background:transparent;color:inherit;width:60px">
              <button class="removeCond" style="padding:6px 12px">削除</button>
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button id="addCondBtn" class="rule-btn" style="padding:6px 12px">条件追加</button>
            <button id="testRuleBtn" class="rule-btn" style="padding:6px 12px">ルールテスト</button>
            <button id="saveRuleBtn" class="rule-btn" style="margin-left:auto;padding:6px 12px">ルール保存</button>
          </div>
          <div style="margin-top:8px">
            <div style="font-weight:600;margin-bottom:4px">テスト結果</div>
            <div id="ruleTestResult" style="background:rgba(0,0,0,0.06);color:inherit;padding:8px;border-radius:6px;max-height:260px;overflow:auto">
              <div class="test-summary" style="display:flex;align-items:center;gap:10px">
                <div id="testBadge" style="font-weight:700;padding:6px 10px;border-radius:6px;background:#444;color:#fff">未実行</div>
                <div id="testShort" style="opacity:0.9">ルールを実行して結果を確認してください</div>
              </div>
              <div id="testDetails" style="margin-top:8px;font-size:0.9em;color:inherit">結果の詳細はここに表示されます。</div>
            </div>
          </div>
        </div>
        <!-- ルール編集ここまで -->
        </div>
        <!-- 左右コンテナここまで -->
      </div>
      <!-- 発火条件セクションここまで -->
    </div>
    <!-- モーダル本体ここまで -->
  </div>
  <!-- settingsModalここまで -->
</div>

<!-- ノートモーダル（初期は非表示） -->
<div class="modal-overlay" id="noteModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="noteTitle" style="display:flex;flex-direction:column;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <h3 id="noteTitle" style="margin:0">ノート</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <select id="noteFontSizeSelect" style="padding:6px 12px;margin-top:0;border-radius:4px;border:1px solid rgba(255,255,255,0.3);background:rgba(0,0,0,0.2);color:#ffffff;font-size:14px;width:60px;">
          <option value="11">11px</option>
          <option value="12">12px</option>
          <option value="13">13px</option>
          <option value="14">14px</option>
          <option value="15" selected>15px</option>
          <option value="16">16px</option>
          <option value="17">17px</option>
          <option value="18">18px</option>
        </select>
        <button id="addNoteSection" class="add-note-section-btn" style="padding:6px 12px;margin-top:0">項目追加</button>
        <button id="saveNote" class="add-note-section-btn" style="background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;padding:6px 12px;margin-top:0">保存</button>
        <button id="exportNote" class="add-note-section-btn" style="background:rgba(34,197,94,0.2);color:#22c55e;border:1px solid #22c55e;padding:6px 12px;margin-top:0">出力</button>
        <button id="importNote" class="add-note-section-btn" style="background:rgba(168,85,247,0.2);color:#a855f7;border:1px solid #a855f7;padding:6px 12px;margin-top:0">読込</button>
        <button id="closeNote" class="add-note-section-btn" style="background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;padding:6px 12px;margin-top:0">閉じる</button>
      </div>
    </div>    <div id="noteSectionsContainer" style="margin-bottom:12px;flex:1;overflow-y:auto;min-height:200px;">
      <!-- ノート項目はJavaScriptで動的に生成されます -->
    </div>
    
    <!-- ページナビゲーション -->
    <div id="notePageNavigation" style="display:flex;justify-content:space-between;align-items:center;padding:8px;border-top:1px solid rgba(255,255,255,0.1);margin-top:8px">
      <div style="display:flex;gap:4px;align-items:center">
        <button id="prevPage" class="page-nav-btn" style="padding:4px 8px;background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;border-radius:4px;cursor:pointer">◀</button>
        <span id="pageIndicator" style="font-size:0.9em;color:rgba(255,255,255,0.8)">1/1</span>
        <button id="nextPage" class="page-nav-btn" style="padding:4px 8px;background:rgba(102,126,234,0.2);color:#667eea;border:1px solid #667eea;border-radius:4px;cursor:pointer">▶</button>
        <input type="text" id="pageTitleInput" style="font-size:14px;padding:6px 12px;border-radius:4px;border:1px solid #667eea;background:rgba(102,126,234,0.2);color:#667eea;width:auto;text-align:center;margin-left:8px" placeholder="ページタイトル">
      </div>
      <div style="display:flex;gap:4px;align-items:center">
        <button id="addPage" class="page-nav-btn" style="padding:4px 8px;background:rgba(34,197,94,0.2);color:#22c55e;border:1px solid #22c55e;border-radius:4px;cursor:pointer;font-size:0.8em">+ページ</button>
        <button id="deletePage" class="page-nav-btn" style="padding:4px 8px;background:rgba(239,68,68,0.2);color:#ef4444;border:1px solid #ef4444;border-radius:4px;cursor:pointer;font-size:0.8em">削除</button>
      </div>
    </div>
    
    <!-- リサイズハンドル -->
    <div id="noteResizeHandle" style="position:absolute;bottom:0;right:0;width:20px;height:20px;cursor:nwse-resize;background:linear-gradient(-45deg, transparent 0%, transparent 40%, rgba(255,255,255,0.3) 40%, rgba(255,255,255,0.3) 60%, transparent 60%, transparent 100%);z-index:1000;"></div>
  </div>
</div>

<div class="main-content">
  <div id="dashboards-container">
    <!-- 通貨ごとの表と発火履歴が動的に生成されます -->
  </div>
  
</div>

</div>
<script>
// Version check and cache buster - 2025-12-05-v3
(function() {
  const REQUIRED_VERSION = '2025-12-05-v3';
  const currentVersion = localStorage.getItem('app_version');
  if (currentVersion !== REQUIRED_VERSION) {
    console.log('[VERSION] Updating from', currentVersion, 'to', REQUIRED_VERSION);
    localStorage.setItem('app_version', REQUIRED_VERSION);
    // Force hard reload to clear cache
    console.log('[VERSION] Hard reload required - clearing cache');
    window.location.reload(true);
    return;
  }
})();

// すべてのイベントリスナーを設定する関数
let isResizingSettings = false;  // 設定モーダルリサイズ中フラグ（グローバル）

// 子ウィンドウの参照を管理（グローバル）
let noteWindowRef = null;
let settingsWindowRef = null;
let economicCalendarWindowRef = null;
let shepherdColumnWindowRef = null;
let timerWindowRef = null;

// 利用可能な通貨リスト（子ウィンドウと共有用）
let availableCurrenciesGlobal = [];

async function setupAllEventListeners() {
  console.log('[INIT] Setting up all event listeners');

  // サイドメニューの開閉
  const toolsBtn = document.getElementById('openToolsMenu');
  const sideMenu = document.getElementById('sideMenu');
  const sideMenuOverlay = document.getElementById('sideMenuOverlay');
  const closeSideMenuBtn = document.getElementById('closeSideMenu');

  function openSideMenu() {
    sideMenu.classList.add('active');
    sideMenuOverlay.classList.add('active');
    updateMenuStatus();
  }

  function closeSideMenu() {
    sideMenu.classList.remove('active');
    sideMenuOverlay.classList.remove('active');
  }

  // メニューの状態を更新（開いているウィンドウをハイライト）
  function updateMenuStatus() {
    const menuItems = [
      { id: 'menuSettings', ref: settingsWindowRef, statusId: 'statusSettings' },
      { id: 'menuNote', ref: noteWindowRef, statusId: 'statusNote' },
      { id: 'menuEconomicCalendar', ref: economicCalendarWindowRef, statusId: 'statusEconomicCalendar' },
      { id: 'menuShepherdColumn', ref: shepherdColumnWindowRef, statusId: 'statusShepherdColumn' },
      { id: 'menuTimer', ref: timerWindowRef, statusId: 'statusTimer' }
    ];

    menuItems.forEach(item => {
      const menuItem = document.getElementById(item.id);
      const statusEl = document.getElementById(item.statusId);
      const isOpen = item.ref && !item.ref.closed;
      
      if (menuItem) {
        if (isOpen) {
          menuItem.classList.add('window-open');
        } else {
          menuItem.classList.remove('window-open');
        }
      }
      if (statusEl) {
        statusEl.textContent = isOpen ? '開' : '';
      }
    });
  }

  if (toolsBtn) toolsBtn.addEventListener('click', openSideMenu);
  if (closeSideMenuBtn) closeSideMenuBtn.addEventListener('click', closeSideMenu);
  if (sideMenuOverlay) sideMenuOverlay.addEventListener('click', closeSideMenu);

  // ウィンドウの表示状態を追跡（前面にあるかどうか）
  let settingsWindowVisible = false;
  let noteWindowVisible = false;
  let economicCalendarWindowVisible = false;
  let shepherdColumnWindowVisible = false;

  // 設定メニュー項目: 子ウィンドウを開く/前面に出す/背面に移動
  const menuSettings = document.getElementById('menuSettings');
  if (menuSettings) menuSettings.addEventListener('click', () => {
    if (settingsWindowRef && !settingsWindowRef.closed) {
      // ウィンドウが開いている場合は前面に出す
      settingsWindowRef.focus();
    } else {
      // 新しいウィンドウを開く
      settingsWindowRef = window.open('/settings_window', 'settings_window', 'width=500,height=700,left=100,top=100,resizable=yes,scrollbars=yes');
    }
    updateMenuStatus();
  });

  // Noteメニュー項目: 子ウィンドウを開く/前面に出す
  const menuNote = document.getElementById('menuNote');
  if (menuNote) menuNote.addEventListener('click', () => {
    if (noteWindowRef && !noteWindowRef.closed) {
      noteWindowRef.focus();
    } else {
      noteWindowRef = window.open('/notes_window', 'notes_window', 'width=800,height=600,left=150,top=150,resizable=yes,scrollbars=yes');
    }
    updateMenuStatus();
  });

  // 経済指標メニュー項目: 子ウィンドウを開く/前面に出す
  const menuEconomicCalendar = document.getElementById('menuEconomicCalendar');
  if (menuEconomicCalendar) menuEconomicCalendar.addEventListener('click', () => {
    if (economicCalendarWindowRef && !economicCalendarWindowRef.closed) {
      economicCalendarWindowRef.focus();
    } else {
      economicCalendarWindowRef = window.open('/economic_calendar_window', 'economic_calendar_window', 'width=600,height=500,left=200,top=100,resizable=yes,scrollbars=yes');
    }
    updateMenuStatus();
  });

  // 羊飼いメニュー項目: 子ウィンドウを開く/前面に出す
  const menuShepherdColumn = document.getElementById('menuShepherdColumn');
  if (menuShepherdColumn) menuShepherdColumn.addEventListener('click', () => {
    if (shepherdColumnWindowRef && !shepherdColumnWindowRef.closed) {
      shepherdColumnWindowRef.focus();
    } else {
      shepherdColumnWindowRef = window.open('/shepherd_column_window', 'shepherd_column_window', 'width=700,height=600,left=250,top=150,resizable=yes,scrollbars=yes');
    }
    updateMenuStatus();
  });

  // 確定タイマーメニュー項目: 子ウィンドウを開く/前面に出す
  const menuTimer = document.getElementById('menuTimer');
  if (menuTimer) menuTimer.addEventListener('click', () => {
    if (timerWindowRef && !timerWindowRef.closed) {
      timerWindowRef.focus();
    } else {
      timerWindowRef = window.open('/timer_window', 'timer_window', 'width=500,height=700,left=300,top=100,resizable=yes,scrollbars=yes');
    }
    updateMenuStatus();
  });

  // ウィンドウが閉じられたときのステータス更新（定期チェック）
  setInterval(updateMenuStatus, 1000);

  // 設定ボタン: 子ウィンドウを開く/復帰させる（旧コード - 互換性のため残す）
  const openBtn = document.getElementById('openSettings');
  const closeBtn = document.getElementById('closeSettings');
  const overlay = document.getElementById('settingsModal');
  const modal = document.querySelector('.modal');

  if (openBtn) openBtn.addEventListener('click', () => { 
    // 子ウィンドウが既に開いているか確認
    if (settingsWindowRef && !settingsWindowRef.closed) {
      // 既存ウィンドウを前面に
      settingsWindowRef.focus();
    } else {
      // 新しい子ウィンドウを開く
      settingsWindowRef = window.open('/settings_window', 'settings_window', 'width=500,height=700,left=100,top=100,resizable=yes,scrollbars=yes');
    }
  });
  // closeBtn は子ウィンドウ側で処理するため、ここでは不要（モーダル用に残す）
  if (closeBtn) closeBtn.addEventListener('click', () => { if (overlay) overlay.style.display = 'none'; });
  if (overlay) overlay.addEventListener('click', (e) => { 
    // リサイズ中はオーバーレイクリックを無視
    if (isResizingSettings) return;
    if (e.target === overlay) overlay.style.display = 'none'; 
  });

// ノートモーダルの開閉（旧コード - 互換性のため残す）
const openNoteBtn = document.getElementById('openNote');
const closeNoteBtn = document.getElementById('closeNote');
const noteOverlay = document.getElementById('noteModal');
const noteModal = noteOverlay ? noteOverlay.querySelector('.modal') : null;

// リサイズ中のフラグ（オーバーレイクリックを防ぐため）
let isResizingNote = false;
let isDraggingNote = false;
// ノートモーダルが開いているかどうか
let isNoteModalOpen = false;

// ノートページ管理
let currentNotePage = 0;
let notePages = [];

if (openNoteBtn) openNoteBtn.addEventListener('click', async () => { 
  // 子ウィンドウが既に開いているか確認
  if (noteWindowRef && !noteWindowRef.closed) {
    // 既存ウィンドウを前面に
    noteWindowRef.focus();
  } else {
    // 新しい子ウィンドウを開く
    noteWindowRef = window.open('/notes_window', 'notes_window', 'width=800,height=600,left=150,top=150,resizable=yes,scrollbars=yes');
  }
});

  // 経済指標ボタン: 子ウィンドウを開く/復帰させる（旧コード - 互換性のため残す）
  const openEconomicCalendarBtn = document.getElementById('openEconomicCalendar');
  if (openEconomicCalendarBtn) openEconomicCalendarBtn.addEventListener('click', () => {
    if (economicCalendarWindowRef && !economicCalendarWindowRef.closed) {
      economicCalendarWindowRef.focus();
    } else {
      economicCalendarWindowRef = window.open('/economic_calendar_window', 'economic_calendar_window', 'width=600,height=500,left=200,top=100,resizable=yes,scrollbars=yes');
    }
  });

  // 羊飼いボタン: 子ウィンドウを開く/復帰させる（旧コード - 互換性のため残す）
  const openShepherdColumnBtn = document.getElementById('openShepherdColumn');
  if (openShepherdColumnBtn) openShepherdColumnBtn.addEventListener('click', () => {
    if (shepherdColumnWindowRef && !shepherdColumnWindowRef.closed) {
      shepherdColumnWindowRef.focus();
    } else {
      shepherdColumnWindowRef = window.open('/shepherd_column_window', 'shepherd_column_window', 'width=700,height=600,left=250,top=150,resizable=yes,scrollbars=yes');
    }
  });

if (closeNoteBtn) closeNoteBtn.addEventListener('click', () => { 
  if (noteOverlay) {
    // クローズ前にサイズと位置を保存
    const modal = noteOverlay.querySelector('.modal');
    if (modal) {
      const rect = modal.getBoundingClientRect();
      const width = Math.round(rect.width);
      const height = Math.round(rect.height);
      const left = Math.round(rect.left);
      const top = Math.round(rect.top);
      console.log('[NOTE] Saving on close:', { width, height, left, top });
      localStorage.setItem('tv_note_modal_width', width.toString());
      localStorage.setItem('tv_note_modal_height', height.toString());
      localStorage.setItem('tv_note_modal_left', left + 'px');
      localStorage.setItem('tv_note_modal_top', top + 'px');
    }
    noteOverlay.style.display = 'none';
    isNoteModalOpen = false;
  }
});

if (noteOverlay) noteOverlay.addEventListener('click', (e) => { 
  // リサイズ中、ドラッグ中、またはリサイズハンドルのクリックは無視
  if (e.target === noteOverlay && !isResizingNote && !isDraggingNote) {
    // オーバーレイクリック時にもサイズと位置を保存
    if (noteModal) {
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        const rect = modal.getBoundingClientRect();
        const width = Math.round(rect.width);
        const height = Math.round(rect.height);
        const left = Math.round(rect.left);
        const top = Math.round(rect.top);
        console.log('[NOTE] Saving on overlay click:', { width, height, left, top });
        localStorage.setItem('tv_note_modal_width', width.toString());
        localStorage.setItem('tv_note_modal_height', height.toString());
        localStorage.setItem('tv_note_modal_left', left + 'px');
        localStorage.setItem('tv_note_modal_top', top + 'px');
      }
    }
    noteOverlay.style.display = 'none';
    isNoteModalOpen = false;
  }
});  // モーダルのドラッグ機能
  let isDragging = false, offsetX = 0, offsetY = 0;
  
  if (modal) {
    modal.addEventListener('mousedown', e => {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA') return;
      
      // リサイズ領域（右下20px）をクリックした場合はドラッグしない
      const rect = modal.getBoundingClientRect();
      const isInResizeArea = (e.clientX > rect.right - 20) && (e.clientY > rect.bottom - 20);
      if (isInResizeArea) {
        isResizingSettings = true;
        return;
      }
      
      isDragging = true;
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;
      modal.style.position = 'fixed';
      modal.style.margin = '0';
    });
  }

  // ノートモーダルのドラッグ機能とリサイズ機能に必要な変数
  let noteOffsetX = 0, noteOffsetY = 0;
  let noteStartWidth = 0, noteStartHeight = 0, noteStartX = 0, noteStartY = 0;
  let noteStartLeft = 0, noteStartTop = 0;  // リサイズ中の位置固定用
  const noteResizeHandle = document.getElementById('noteResizeHandle');
  
  if (noteOverlay) {
    const noteModalContent = noteOverlay.querySelector('.modal');
    if (noteModalContent) {
      noteModalContent.addEventListener('mousedown', e => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA') return;
        if (e.target === noteResizeHandle || noteResizeHandle.contains(e.target)) return; // リサイズハンドルは除外
        isDraggingNote = true;
        const rect = noteModalContent.getBoundingClientRect();
        noteOffsetX = e.clientX - rect.left;
        noteOffsetY = e.clientY - rect.top;
        noteModalContent.style.position = 'fixed';
        noteModalContent.style.left = rect.left + 'px';
        noteModalContent.style.top = rect.top + 'px';
        noteModalContent.style.margin = '0';
        noteModalContent.style.transform = 'none'; // ドラッグ中にtransformを無効化
        console.log('[NOTE] Drag started');
      });
    }
  }
  
  // リサイズハンドルのイベント
  if (noteResizeHandle && noteOverlay) {
    noteResizeHandle.addEventListener('mousedown', e => {
      e.preventDefault();
      e.stopPropagation();
      isResizingNote = true;
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        const rect = modal.getBoundingClientRect();
        noteStartWidth = rect.width;
        noteStartHeight = rect.height;
        noteStartX = e.clientX;
        noteStartY = e.clientY;
        noteStartLeft = rect.left;  // 位置を保存
        noteStartTop = rect.top;    // 位置を保存
        
        // リサイズ開始時に位置を固定（transformを無効化してleft/topで位置を設定）
        modal.style.position = 'fixed';
        modal.style.left = rect.left + 'px';
        modal.style.top = rect.top + 'px';
        modal.style.margin = '0';
        modal.style.transform = 'none';
        
        console.log('[NOTE] Resize started:', { width: noteStartWidth, height: noteStartHeight, left: rect.left, top: rect.top });
      }
    });
  }

  document.addEventListener('mousemove', e => {
    if (!isDragging && !isDraggingNote && !isResizingNote) return;
    
    if (isDragging && modal) {
      modal.style.left = (e.clientX - offsetX) + 'px';
      modal.style.top = (e.clientY - offsetY) + 'px';
    }
    
    if (isDraggingNote && noteOverlay) {
      const noteModalContent = noteOverlay.querySelector('.modal');
      if (noteModalContent) {
        noteModalContent.style.left = (e.clientX - noteOffsetX) + 'px';
        noteModalContent.style.top = (e.clientY - noteOffsetY) + 'px';
      }
    }
    
    if (isResizingNote && noteOverlay) {
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        // ウィンドウサイズを取得
        const maxWidth = window.innerWidth * 0.95; // 画面幅の95%まで
        const maxHeight = window.innerHeight * 0.95; // 画面高さの95%まで
        const minWidth = 300;
        const minHeight = 200;
        
        const newWidth = Math.max(minWidth, Math.min(maxWidth, noteStartWidth + (e.clientX - noteStartX)));
        const newHeight = Math.max(minHeight, Math.min(maxHeight, noteStartHeight + (e.clientY - noteStartY)));
        
        // 位置を固定したままサイズのみ変更
        modal.style.left = noteStartLeft + 'px';
        modal.style.top = noteStartTop + 'px';
        modal.style.width = newWidth + 'px';
        modal.style.height = newHeight + 'px';
      }
    }
  });

  document.addEventListener('mouseup', () => {
    if ((isDraggingNote || isResizingNote) && noteOverlay && isNoteModalOpen) {
      // ドラッグまたはリサイズ終了時にサイズと位置を保存
      const modal = noteOverlay.querySelector('.modal');
      if (modal) {
        const rect = modal.getBoundingClientRect();
        const width = Math.round(rect.width);
        const height = Math.round(rect.height);
        const left = Math.round(rect.left);
        const top = Math.round(rect.top);
        console.log('[NOTE] Saving on mouse up:', { width, height, left, top });
        localStorage.setItem('tv_note_modal_width', width.toString());
        localStorage.setItem('tv_note_modal_height', height.toString());
        localStorage.setItem('tv_note_modal_left', left + 'px');
        localStorage.setItem('tv_note_modal_top', top + 'px');
      }
    }
    
    // 設定モーダルのサイズと位置を保存
    if ((isDragging || isResizingSettings) && modal) {
      const rect = modal.getBoundingClientRect();
      localStorage.setItem('tv_settings_modal_width', Math.round(rect.width).toString());
      localStorage.setItem('tv_settings_modal_height', Math.round(rect.height).toString());
      localStorage.setItem('tv_settings_modal_left', modal.style.left || '');
      localStorage.setItem('tv_settings_modal_top', modal.style.top || '');
      console.log('[SETTINGS] Saved modal size/position:', { width: rect.width, height: rect.height });
    }
    
    isDragging = false;
    isDraggingNote = false;
    isResizingNote = false;
    isResizingSettings = false;
  });

  // ルール関連のイベントリスナー
  const newRuleBtn = document.getElementById('newRuleBtn');
  if (newRuleBtn) {
    newRuleBtn.addEventListener('click', () => {
      console.log('[EVENT] New rule button clicked');
      document.getElementById('ruleName').value = '';
      document.getElementById('conditionsContainer').innerHTML = '';
      addConditionRow();
      document.getElementById('saveRuleBtn').dataset.editing = '';

      // clear voice settings
      document.getElementById('voiceMessage').value = '';
      document.getElementById('voiceMessageUp').value = '';
      document.getElementById('voiceMessageDown').value = '';
      document.getElementById('voiceDirectionBased').checked = false;
      document.getElementById('directionMessages').style.display = 'none';
      document.getElementById('voiceMessagePosition').value = 'suffix';
      document.getElementById('voiceSelect').value = '';
      document.getElementById('playChimeFirst').checked = false;
      document.getElementById('chimeSelect').value = '';
    });
  }

  const addCondBtn = document.getElementById('addCondBtn');
  if (addCondBtn) {
    addCondBtn.addEventListener('click', () => {
      console.log('[EVENT] Add condition button clicked');
      addConditionRow();
    });
  }

  const voiceDirectionBased = document.getElementById('voiceDirectionBased');
  if (voiceDirectionBased) {
    voiceDirectionBased.addEventListener('change', e => {
      console.log('[EVENT] Voice direction based changed:', e.target.checked);
      const directionDiv = document.getElementById('directionMessages');
      if (directionDiv) {
        directionDiv.style.display = e.target.checked ? 'flex' : 'none';
      }
    });
  }

  const alignMissingTooltip = document.getElementById('alignMissingTooltip');
  if (alignMissingTooltip) {
    alignMissingTooltip.addEventListener('click', () => {
      alert(`・無視\n欠損した TF を判定から除外し、残りの TF で整列条件を評価します。データが一部欠けていても、条件を満たせば整列成立とみなします。\n例1: 5m、15m、1H、4H全てチェック、15m欠損の場合、15mを除外して5m、1H、4Hの順序が雲の順番と一致すれば成立。\n例2: 5m、15m、1H、4H全てチェック、雲が5m、15m、4H、1H、4H欠損の場合、4Hを除外して5m、15m、1Hの順序が一致して発火。\n\n・不一致\n欠損した TF があれば、即座に整列条件を不成立と判定します。データが完全でないと条件を満たさない厳格な扱いになります。\n例: 5m、15m、1H、4H全てチェック、15m欠損の場合、欠損があるため不成立。`);
    });
  }

  const testVoiceBtn = document.getElementById('testVoiceBtn');
  if (testVoiceBtn) {
    testVoiceBtn.addEventListener('click', () => {
      console.log('[EVENT] Test voice button clicked');
      const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
      const voiceName = document.getElementById('voiceSelect').value;
      const messagePosition = document.getElementById('voiceMessagePosition').value;
      const playChime = document.getElementById('playChimeFirst').checked;
      const chimeFile = document.getElementById('chimeSelect').value;
      const insertSymbol = document.getElementById('insertSymbol').checked;
      const ruleScope = document.getElementById('ruleScope').value;

      let testMessage = '';
      if (isDirectionBased) {
        const messageUp = document.getElementById('voiceMessageUp').value.trim();
        const messageDown = document.getElementById('voiceMessageDown').value.trim();
        const directionMessage = messageUp || 'テストメッセージ（上昇）';
        const baseMessage = document.getElementById('voiceMessage').value.trim() || 'ルールが発火しました';

        if (messagePosition === 'prefix') {
          testMessage = directionMessage + ' ' + baseMessage;
        } else if (messagePosition === 'suffix') {
          testMessage = baseMessage + ' ' + directionMessage;
        } else if (messagePosition === 'both') {
          testMessage = directionMessage + ' ' + baseMessage + ' ' + directionMessage;
        }
      } else {
        testMessage = document.getElementById('voiceMessage').value.trim() || 'テストメッセージ';
      }

      // 通貨名挿入処理
      if (insertSymbol && ruleScope) {
        const japaneseName = currencyNames[ruleScope] || ruleScope;
        const symbolInsertPosition = document.getElementById('symbolInsertPosition').value;
        if (testMessage.includes('{symbol}')) {
          testMessage = testMessage.replace('{symbol}', japaneseName);
        } else {
          if (symbolInsertPosition === 'prefix') {
            testMessage = japaneseName + ' ' + testMessage;
          } else if (symbolInsertPosition === 'suffix') {
            testMessage = testMessage + ' ' + japaneseName;
          } else if (symbolInsertPosition === 'both') {
            testMessage = japaneseName + ' ' + testMessage + ' ' + japaneseName;
          }
        }
      }

      const voiceSettings = {};
      if (voiceName) voiceSettings.voice_name = voiceName;
      if (playChime && chimeFile) voiceSettings.chime_file = chimeFile;
      if (insertSymbol && ruleScope) {
        voiceSettings.insert_symbol = true;
        voiceSettings.symbol_insert_position = document.getElementById('symbolInsertPosition').value;
      }
      const rateSuffix = testMessage ? '' : '。音速は' + document.getElementById('voiceRate').value + '倍です。';
      playVoiceAlert(testMessage + rateSuffix, voiceSettings, ruleScope || 'USDJPY');
    });
  }

  const saveRuleBtn = document.getElementById('saveRuleBtn');
  if (saveRuleBtn) {
    saveRuleBtn.addEventListener('click', async () => {
      console.log('[EVENT] Save rule button clicked');
      // validate alignment first
      const alignValid = validateAlignmentForSave();
      if(!alignValid.ok){ return; }

      const name = document.getElementById('ruleName').value || ('rule-' + Date.now());
      const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
      const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
      const conditions = condRows.map(r => {
        const tf = r.querySelector('.cond-tf').value;
        const fld = r.querySelector('.cond-field').value;
        const valEl = r.querySelector('.cond-value');
        const valVal = valEl ? valEl.value : null;
        return { label: tf, field: fld, value: valVal };
      });
      const alignment = getAlignmentSettingsFromUI();
      const ruleObj = { conditions: conditions };
      // include alignment only if TFs selected
      if(alignment.tfs && alignment.tfs.length > 0){ ruleObj.alignment = alignment; }

      // include voice settings
      const isDirectionBased = document.getElementById('voiceDirectionBased').checked;
      const voiceName = document.getElementById('voiceSelect').value;
      const messagePosition = document.getElementById('voiceMessagePosition').value;
      const commonMessage = document.getElementById('voiceMessage').value.trim();
      const messageUp = document.getElementById('voiceMessageUp').value.trim();
      const messageDown = document.getElementById('voiceMessageDown').value.trim();
      const playChime = document.getElementById('playChimeFirst').checked;
      const chimeFile = document.getElementById('chimeSelect').value;

      // Check if any voice setting exists
      if (commonMessage || messageUp || messageDown || voiceName || (playChime && chimeFile)) {
        ruleObj.voice = {};

        // Always save common message if present
        if (commonMessage) {
          ruleObj.voice.message = commonMessage;
        }

        // Save direction-based messages if direction-based mode is enabled
        if (isDirectionBased) {
          ruleObj.voice.message_up = messageUp;
          ruleObj.voice.message_down = messageDown;
          ruleObj.voice.message_position = messagePosition;
        }

        // Always save voice name if selected
        if (voiceName) {
          ruleObj.voice.voice_name = voiceName;
        }

        // Save chime settings
        if (playChime && chimeFile) {
          ruleObj.voice.chime_file = chimeFile;
        }

        // Save symbol insert setting
        if (document.getElementById('insertSymbol').checked) {
          ruleObj.voice.insert_symbol = true;
          ruleObj.voice.symbol_insert_position = document.getElementById('symbolInsertPosition').value;
        } else {
          delete ruleObj.voice.insert_symbol;
          delete ruleObj.voice.symbol_insert_position;
        }
      }

      const payload = { id: document.getElementById('saveRuleBtn').dataset.editing || name, name: name, enabled: true, scope: scope, rule: ruleObj };
      try {
        const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await res.json();
        if (j.status === 'success') {
          alert('ルールを保存しました');
          // ルール一覧を再度読み込んで、最新のデータを取得
          await loadRules();
          // 保存したルールを再度開いて、UIを最新の状態に更新
          try {
            const rulesRes = await fetch('/rules');
            const rulesData = await rulesRes.json();
            if (rulesData.status === 'success') {
              const savedRule = rulesData.rules.find(r => r.id === payload.id);
              if (savedRule) {
                openRuleEditor(savedRule);
              }
            }
          } catch (e) {
            console.log('Error reloading rule after save:', e);
          }
        }
        else { alert('保存失敗: ' + (j.msg || JSON.stringify(j))); }
      } catch (e) { console.log('save error', e); alert('保存時エラー: ' + e.message); }
    });
  }

  const testRuleBtn = document.getElementById('testRuleBtn');
  if (testRuleBtn) {
    testRuleBtn.addEventListener('click', async () => {
      console.log('[EVENT] Test rule button clicked');
      const panel = document.getElementById('ruleTestResult');
      const badge = document.getElementById('testBadge');
      const short = document.getElementById('testShort');
      const detailsEl = document.getElementById('testDetails');

      badge.style.background = '#777'; badge.textContent = '実行中...';
      short.textContent = '';
      detailsEl.innerHTML = '';

      // build payload
      const scope = (document.getElementById('ruleScope').value ? { symbol: document.getElementById('ruleScope').value } : {});
      const condRows = Array.from(document.querySelectorAll('#conditionsContainer .cond-row'));
      const conditions = condRows.map(r => {
        const tf = r.querySelector('.cond-tf').value;
        const fld = r.querySelector('.cond-field').value;
        const valEl = r.querySelector('.cond-value');
        const valVal = valEl ? (valEl.value || null) : null;
        return { label: tf, field: fld, value: valVal };
      });
      const payload = { rule: { logic: 'AND', conditions: conditions }, scope: scope };
      const alignment = getAlignmentSettingsFromUI();
      if(alignment.tfs && alignment.tfs.length > 0){ payload.rule.alignment = alignment; }

      // alignment validation - we show a non-blocking warning
      const alignValid = validateAlignmentForSave();
      if(!alignValid.ok){ short.textContent = '注意: ' + alignValid.msg; }

      // テスト時に現在のダッシュボードデータを state_override として送信
      if (currentDashboardData && currentDashboardData.length > 0) {
        let selectedState = null;
        const ruleSymbol = scope.symbol;

        if (ruleSymbol) {
          // ルールが特定の通貨に限定されている場合、その通貨の5mデータを使用
          selectedState = currentDashboardData.find(s => s.symbol === ruleSymbol && (s.tf === '5' || s.tf === '5m'));

          // 5mが見つからなければ、その通貨の任意のデータを使用
          if (!selectedState) {
            selectedState = currentDashboardData.find(s => s.symbol === ruleSymbol);
          }
        } else {
          // 通貨指定なしの場合、最初の5mデータを使用
          selectedState = currentDashboardData.find(s => s.tf === '5' || s.tf === '5m');

          // 5mが見つからなければ最初のデータを使用
          if (!selectedState) {
            selectedState = currentDashboardData[0];
          }
        }

        if (selectedState) {
          payload.state_override = selectedState;
        }
      }

      try {
        const res = await fetch('/rules/test', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
        const j = await res.json();
        if (j.status === 'success') {
          const matched = !!j.matched;
          if (matched) { badge.style.background = '#2d8a3d'; badge.textContent = 'OK'; }
          else { badge.style.background = '#b02a2a'; badge.textContent = 'NG'; }

          const condCount = Array.isArray(payload.rule.conditions) ? payload.rule.conditions.length : 0;
          const passCount = Array.isArray(j.details) ? j.details.filter(d => d.result).length : (matched ? condCount : 0);
          short.textContent = `判定: ${matched ? 'OK' : 'NG'} — 条件合致 ${passCount}/${condCount}${payload.rule.alignment ? ' / 雲整列を含む' : ''}`;

          // 生データ表示/コピー機能の追加
          const rawDataControls = document.createElement('div');
          rawDataControls.style.marginTop = '8px';
          rawDataControls.style.display = 'flex';
          rawDataControls.style.gap = '8px';
          rawDataControls.style.alignItems = 'center';

          const toggleRawBtn = document.createElement('button');
          toggleRawBtn.textContent = '▼生データを表示';
          toggleRawBtn.style.padding = '4px 8px';
          toggleRawBtn.style.border = '1px solid rgba(255,255,255,0.3)';
          toggleRawBtn.style.borderRadius = '4px';
          toggleRawBtn.style.background = 'rgba(255,255,255,0.1)';
          toggleRawBtn.style.color = 'inherit';
          toggleRawBtn.style.cursor = 'pointer';
          toggleRawBtn.style.fontSize = '0.85em';

          const copyRawBtn = document.createElement('button');
          copyRawBtn.textContent = '生データをコピー';
          copyRawBtn.style.padding = '4px 8px';
          copyRawBtn.style.border = '1px solid rgba(255,255,255,0.3)';
          copyRawBtn.style.borderRadius = '4px';
          copyRawBtn.style.background = 'rgba(255,255,255,0.1)';
          copyRawBtn.style.color = 'inherit';
          copyRawBtn.style.cursor = 'pointer';
          copyRawBtn.style.fontSize = '0.85em';

          const rawDataDisplay = document.createElement('pre');
          rawDataDisplay.style.display = 'none';
          rawDataDisplay.style.background = 'rgba(0,0,0,0.3)';
          rawDataDisplay.style.padding = '8px';
          rawDataDisplay.style.borderRadius = '4px';
          rawDataDisplay.style.marginTop = '8px';
          rawDataDisplay.style.fontSize = '0.8em';
          rawDataDisplay.style.maxHeight = '200px';
          rawDataDisplay.style.overflow = 'auto';
          rawDataDisplay.style.whiteSpace = 'pre-wrap';
          rawDataDisplay.textContent = JSON.stringify(j, null, 2);

          toggleRawBtn.addEventListener('click', () => {
            if (rawDataDisplay.style.display === 'none') {
              rawDataDisplay.style.display = 'block';
              toggleRawBtn.textContent = '▲生データを隠す';
            } else {
              rawDataDisplay.style.display = 'none';
              toggleRawBtn.textContent = '▼生データを表示';
            }
          });

          copyRawBtn.addEventListener('click', async () => {
            try {
              await navigator.clipboard.writeText(JSON.stringify(j, null, 2));
              const originalText = copyRawBtn.textContent;
              copyRawBtn.textContent = 'コピーしました！';
              copyRawBtn.style.background = '#2d8a3d';
              setTimeout(() => {
                copyRawBtn.textContent = originalText;
                copyRawBtn.style.background = 'rgba(255,255,255,0.1)';
              }, 2000);
            } catch (err) {
              console.error('コピー失敗:', err);
              alert('コピーに失敗しました');
            }
          });

          rawDataControls.appendChild(toggleRawBtn);
          rawDataControls.appendChild(copyRawBtn);
          detailsEl.appendChild(rawDataControls);
          detailsEl.appendChild(rawDataDisplay);

          if (Array.isArray(j.details) && j.details.length > 0) {
            const ul = document.createElement('ul');
            ul.style.margin = '6px 0 0 14px'; ul.style.padding = '0'; ul.style.listStyle = 'disc';
            j.details.forEach(d => {
              const li = document.createElement('li');
              try {
                const rawName = d.cond || (d.label ? `${d.label}.${d.field}` : JSON.stringify(d));
                const fieldMap = {
                  'alignment':'雲整列', '雲整列':'雲整列',
                  'dauten':'ダウ転換', 'gc':'雲交差', 'bos_count':'突破数', 'daytrade_bos':'突破数',
                  'distance_from_prev':'各雲間', 'distance_from_price':'価格間',
                  'angle':'雲角度', 'thickness':'雲厚み', 'transfer_time_diff':'転換時間差',
                  'presence_check':'存在確認', 'direction_consistency':'方向一貫性'
                };
                let name = rawName;
                const key = d.field || d.cond || rawName;
                if (typeof rawName === 'string' && rawName.includes('.')) {
                  const parts = rawName.split('.');
                  const tfPart = parts[0];
                  const fieldPart = parts[1];
                  const mappedField = fieldMap[fieldPart] || fieldPart;
                  name = `${tfPart}.${mappedField}`;
                } else if (fieldMap[key]) {
                  name = fieldMap[key];
                }
                const ok = d.result ? 'OK' : 'NG';
                li.textContent = `${name}：${ok}`.trim();
              } catch (e) { li.textContent = JSON.stringify(d); }
              ul.appendChild(li);
            });
            detailsEl.appendChild(ul);
          } else {
            detailsEl.textContent = '詳細情報はありません。';
          }
        } else {
          badge.style.background = '#aa5500'; badge.textContent = 'エラー';
          short.textContent = 'エラー: ' + (j.msg || JSON.stringify(j));
          detailsEl.textContent = '';
        }
      } catch (e) {
        badge.style.background = '#aa5500'; badge.textContent = '実行エラー';
        short.textContent = e.message;
        detailsEl.textContent = '';
      }
    });
  }

  const testFireBtn = document.getElementById('test-fire-btn');
  if (testFireBtn) {
    testFireBtn.addEventListener('click', () => {
      console.log('[EVENT] Test fire button clicked');
      testFire();
    });
  }

  const clearFireHistoryBtn = document.getElementById('clear-fire-history-btn');
  if (clearFireHistoryBtn) {
    clearFireHistoryBtn.addEventListener('click', async () => {
      console.log('[EVENT] Clear fire history button clicked');
      try {
        const res = await fetch('/api/clear_notifications', { method: 'POST' });
        const data = await res.json();
        if (data.status === 'success') {
          const listEl = document.getElementById('fire-history-list');
          if (listEl) {
            listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
          }
          console.log('Notifications cleared');
        } else {
          console.log('Clear failed:', data);
          alert('クリアに失敗しました: ' + (data.msg || JSON.stringify(data)));
        }
      } catch (e) {
        console.log('Clear error:', e);
        alert('クリアエラー: ' + e.message);
      }
    });
  }

  // Align checkbox event listeners
  document.querySelectorAll('.align-tf').forEach(cb => cb.addEventListener('change', () => {
    console.log('[EVENT] Align TF checkbox changed');
    // no-op for now; validation on save/test
  }));

  const alignAllTf = document.getElementById('alignAllTf');
  if (alignAllTf) {
    alignAllTf.addEventListener('change', (e) => {
      console.log('[EVENT] Align all TF checkbox changed:', e.target.checked);
      const checked = e.target.checked;
      document.querySelectorAll('.align-tf').forEach(cb => cb.checked = checked);
    });
  }

  // 経済指標カレンダーと外部サイトウィンドウは別ウィンドウに移動したため、言語選択イベントリスナーは不要

// ノート項目の作成関数
function createNoteSection(title = '', content = '', images = []) {
  const section = document.createElement('div');
  section.className = 'note-section';
  section.draggable = true;
  
  const header = document.createElement('div');
  header.className = 'note-section-header';
  
  const dragHandle = document.createElement('span');
  dragHandle.textContent = '≡';
  dragHandle.style.cursor = 'grab';
  dragHandle.style.marginRight = '8px';
  dragHandle.style.color = 'rgba(255,255,255,0.6)';
  dragHandle.style.fontSize = '18px';
  dragHandle.style.lineHeight = '1';
  
  const titleInput = document.createElement('input');
  titleInput.type = 'text';
  titleInput.className = 'note-section-title';
  titleInput.placeholder = '項目タイトル';
  titleInput.value = title;
  
  const buttonContainer = document.createElement('div');
  buttonContainer.style.display = 'flex';
  buttonContainer.style.gap = '4px';
  
  const upBtn = document.createElement('button');
  upBtn.textContent = '↑';
  upBtn.style.padding = '4px 8px';
  upBtn.style.background = 'rgba(102,126,234,0.2)';
  upBtn.style.color = '#667eea';
  upBtn.style.border = '1px solid #667eea';
  upBtn.style.borderRadius = '4px';
  upBtn.style.cursor = 'pointer';
  upBtn.style.fontSize = '14px';
  upBtn.addEventListener('click', () => {
    const prev = section.previousElementSibling;
    if (prev) {
      section.parentNode.insertBefore(section, prev);
      autoSaveNote();
    }
  });
  
  const downBtn = document.createElement('button');
  downBtn.textContent = '↓';
  downBtn.style.padding = '4px 8px';
  downBtn.style.background = 'rgba(102,126,234,0.2)';
  downBtn.style.color = '#667eea';
  downBtn.style.border = '1px solid #667eea';
  downBtn.style.borderRadius = '4px';
  downBtn.style.cursor = 'pointer';
  downBtn.style.fontSize = '14px';
  downBtn.addEventListener('click', () => {
    const next = section.nextElementSibling;
    if (next) {
      section.parentNode.insertBefore(next, section);
      autoSaveNote();
    }
  });
  
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'note-section-delete';
  deleteBtn.textContent = '×';
  deleteBtn.style.width = 'auto';
  deleteBtn.style.padding = '4px 8px';
  deleteBtn.addEventListener('click', () => {
    if (confirm('この項目を削除しますか？')) {
      section.remove();
      autoSaveNote();
    }
  });
  
  header.appendChild(dragHandle);
  header.appendChild(titleInput);
  buttonContainer.appendChild(upBtn);
  buttonContainer.appendChild(downBtn);
  buttonContainer.appendChild(deleteBtn);
  header.appendChild(buttonContainer);
  
  const contentTextarea = document.createElement('textarea');
  contentTextarea.className = 'note-section-content';
  contentTextarea.placeholder = '内容を入力してください...';
  contentTextarea.value = content;
  
  // 画像表示エリア
  const imageContainer = document.createElement('div');
  imageContainer.className = 'note-section-images';
  imageContainer.style.display = 'flex';
  imageContainer.style.flexWrap = 'wrap';
  imageContainer.style.gap = '8px';
  imageContainer.style.marginTop = '8px';
  imageContainer.style.padding = '8px';
  imageContainer.style.borderTop = '1px solid rgba(255,255,255,0.1)';
  
  // ドラッグ&ドロップエリア
  const dropZone = document.createElement('div');
  dropZone.style.border = '2px dashed rgba(255,255,255,0.2)';
  dropZone.style.borderRadius = '4px';
  dropZone.style.padding = '16px';
  dropZone.style.textAlign = 'center';
  dropZone.style.color = 'rgba(255,255,255,0.6)';
  dropZone.style.fontSize = '12px';
  dropZone.style.cursor = 'pointer';
  dropZone.style.transition = 'all 0.3s ease';
  dropZone.textContent = '画像をドラッグ&ドロップ';
  
  // 既存画像を表示
  images.forEach(imageData => {
    const imgThumb = document.createElement('div');
    imgThumb.className = 'note-image-thumb';
    imgThumb.style.width = '60px';
    imgThumb.style.height = '60px';
    imgThumb.style.borderRadius = '4px';
    imgThumb.style.overflow = 'hidden';
    imgThumb.style.cursor = 'pointer';
    imgThumb.style.border = '1px solid rgba(255,255,255,0.2)';
    imgThumb.style.position = 'relative';
    
    const img = document.createElement('img');
    img.style.width = '100%';
    img.style.height = '100%';
    img.style.objectFit = 'cover';
    
    // 旧フォーマット（文字列）との互換性
    let imageHash = null;
    let base64Data = null;
    
    if (typeof imageData === 'string') {
      // 旧フォーマット：Base64またはファイルパス
      if (imageData.startsWith('data:')) {
        base64Data = imageData;
        img.src = base64Data;
      } else {
        // ファイルパスの場合は表示できないため、スキップ
        return;
      }
    } else if (imageData.type === 'hash') {
      // 新フォーマット：ハッシュ値
      imageHash = imageData.value;
      img.dataset.imagehash = imageHash;
      
      // IndexedDB から画像を取得（非同期）
      getImageFromIndexedDB(imageHash).then(base64 => {
        if (base64) {
          console.log('[NOTE] Using cached image from IndexedDB:', imageHash.substring(0, 16) + '...');
          img.src = base64;
        } else {
          // IndexedDB にない場合はサーバーから取得
          console.log('[NOTE] Image not in IndexedDB, using server API:', imageHash.substring(0, 16) + '...');
          img.src = `/api/note-image/${imageHash}`;
        }
      }).catch(e => {
        console.warn('[NOTE] Error loading from IndexedDB, using server API:', e);
        img.src = `/api/note-image/${imageHash}`;
      });
    } else if (imageData.type === 'base64') {
      // 新フォーマット：Base64
      base64Data = imageData.value;
      img.src = base64Data;
      
      // ハッシュを計算してIndexedDBに保存（オプション）
      if (imageData.hash) {
        saveImageToIndexedDB(imageData.hash, base64Data).catch(e => 
          console.warn('[INDEXEDDB] Failed to cache image:', e)
        );
      }
    }
    
    const deleteImgBtn = document.createElement('button');
    deleteImgBtn.textContent = '×';
    deleteImgBtn.style.position = 'absolute';
    deleteImgBtn.style.top = '0';
    deleteImgBtn.style.right = '0';
    deleteImgBtn.style.background = 'rgba(0,0,0,0.7)';
    deleteImgBtn.style.color = '#fff';
    deleteImgBtn.style.border = 'none';
    deleteImgBtn.style.width = '20px';
    deleteImgBtn.style.height = '20px';
    deleteImgBtn.style.cursor = 'pointer';
    deleteImgBtn.style.fontSize = '14px';
    deleteImgBtn.style.display = 'none';
    
    imgThumb.addEventListener('mouseenter', () => deleteImgBtn.style.display = 'block');
    imgThumb.addEventListener('mouseleave', () => deleteImgBtn.style.display = 'none');
    
    deleteImgBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      // IndexedDB から削除
      if (imageHash) {
        deleteImageFromIndexedDB(imageHash).catch(e => 
          console.warn('[INDEXEDDB] Failed to delete image:', e)
        );
      }
      imgThumb.remove();
      autoSaveNote();
    });
    
    imgThumb.appendChild(img);
    imgThumb.appendChild(deleteImgBtn);
    
    imgThumb.addEventListener('click', () => {
      const modal = document.createElement('div');
      modal.style.position = 'fixed';
      modal.style.top = '0';
      modal.style.left = '0';
      modal.style.width = '100%';
      modal.style.height = '100%';
      modal.style.background = 'rgba(0,0,0,0.8)';
      modal.style.display = 'flex';
      modal.style.alignItems = 'center';
      modal.style.justifyContent = 'center';
      modal.style.zIndex = '10000';
      
      // ローディング表示
      const loader = document.createElement('div');
      loader.textContent = '読み込み中...';
      loader.style.color = 'white';
      loader.style.fontSize = '18px';
      modal.appendChild(loader);
      document.body.appendChild(modal);
      
      const largeImg = document.createElement('img');
      largeImg.style.maxWidth = '90%';
      largeImg.style.maxHeight = '90%';
      
      // 画像読み込み成功時
      largeImg.onload = () => {
        modal.innerHTML = '';
        modal.appendChild(largeImg);
      };
      
      // 画像読み込みエラー時
      largeImg.onerror = () => {
        loader.textContent = '画像の読み込みに失敗しました';
        loader.style.color = '#ff6b6b';
        console.error('[NOTE] Image load error for:', img.src);
      };
      
      // 画像ソースを設定（ハッシュベースまたはBase64）
      largeImg.src = img.src;
      
      // クリックでモーダルを閉じる（ただし画像上でのクリックは除く）
      modal.addEventListener('click', (e) => {
        if (e.target === modal || e.target === loader) {
          modal.remove();
        }
      });
    });
    
    imageContainer.appendChild(imgThumb);
  });
  
  imageContainer.appendChild(dropZone);
  
  // ドラッグ&ドロップイベント
  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.style.background = 'rgba(102,126,234,0.2)';
    dropZone.style.borderColor = '#667eea';
  });
  
  dropZone.addEventListener('dragleave', () => {
    dropZone.style.background = 'transparent';
    dropZone.style.borderColor = 'rgba(255,255,255,0.2)';
  });
  
  dropZone.addEventListener('drop', async (e) => {
    e.preventDefault();
    dropZone.style.background = 'transparent';
    dropZone.style.borderColor = 'rgba(255,255,255,0.2)';
    
    const files = e.dataTransfer.files;
    for (let file of files) {
      if (file.type.startsWith('image/')) {
        await uploadImage(file, imageContainer, dropZone);
      }
    }
  });
  
  section.appendChild(header);
  section.appendChild(contentTextarea);
  section.appendChild(imageContainer);
  
  // 現在のノートフォントサイズを適用
  const currentNoteFontSize = localStorage.getItem('tv_note_font_size') || '15';
  titleInput.style.fontSize = currentNoteFontSize + 'px';
  contentTextarea.style.fontSize = currentNoteFontSize + 'px';
  
  // 自動保存イベントリスナー
  titleInput.addEventListener('input', () => autoSaveNote());
  contentTextarea.addEventListener('input', () => autoSaveNote());
  
  // 項目間のドラッグ&ドロップ
  section.addEventListener('dragstart', (e) => {
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', section.innerHTML);
    section.style.opacity = '0.5';
  });
  
  section.addEventListener('dragend', () => {
    section.style.opacity = '1';
  });
  
  section.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    section.style.borderTop = '2px solid #667eea';
  });
  
  section.addEventListener('dragleave', () => {
    section.style.borderTop = '';
  });
  
  section.addEventListener('drop', (e) => {
    e.preventDefault();
    e.stopPropagation();
    section.style.borderTop = '';
    // ドロップされた項目の前に挿入
    const draggedSection = document.querySelector('[style*="opacity: 0.5"]');
    if (draggedSection && draggedSection !== section) {
      section.parentNode.insertBefore(draggedSection, section);
      autoSaveNote();
    }
  });
  
  return section;
}

// 画像アップロード関数
async function uploadImage(file, imageContainer, dropZone) {
  const reader = new FileReader();
  reader.onload = async (e) => {
    const base64Data = e.target.result;
    
    console.log('[NOTE] Uploading image:', file.name, 'size:', file.size);
    
    try {
      const response = await fetch('/api/upload-note-image', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ imageData: base64Data })
      });
      
      const result = await response.json();
      
      console.log('[NOTE] Upload response:', result);
      
      if (result.status === 'success') {
        // 既存のサムネイルと同じファイルがないかチェック
        const existingThumbs = imageContainer.querySelectorAll('.note-image-thumb');
        let isDuplicate = false;
        for (let thumb of existingThumbs) {
          const img = thumb.querySelector('img');
          if (img && img.dataset.imagehash === result.imageHash) {
            isDuplicate = true;
            break;
          }
        }
        
        if (isDuplicate) {
          console.log('[NOTE] Image already added in this section');
          return;
        }
        
        // IndexedDB に画像を保存（非同期）
        saveImageToIndexedDB(result.imageHash, base64Data).catch(e => 
          console.warn('[INDEXEDDB] Failed to cache image:', e)
        );
        
        // サーバーにファイルが保存されているか確認
        if (result.fileExists) {
          console.log('[NOTE] ✓ File confirmed on server:', result.filepath);
        } else {
          console.warn('[NOTE] ✗ File NOT confirmed on server:', result.filepath);
        }
        
        // 画像サムネイルを追加
        const imgThumb = document.createElement('div');
        imgThumb.className = 'note-image-thumb';
        imgThumb.style.width = '60px';
        imgThumb.style.height = '60px';
        imgThumb.style.borderRadius = '4px';
        imgThumb.style.overflow = 'hidden';
        imgThumb.style.cursor = 'pointer';
        imgThumb.style.border = '1px solid rgba(255,255,255,0.2)';
        imgThumb.style.position = 'relative';
        
        const img = document.createElement('img');
        img.src = base64Data;
        img.dataset.imagehash = result.imageHash;
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.objectFit = 'cover';
        
        const deleteImgBtn = document.createElement('button');
        deleteImgBtn.textContent = '×';
        deleteImgBtn.style.position = 'absolute';
        deleteImgBtn.style.top = '0';
        deleteImgBtn.style.right = '0';
        deleteImgBtn.style.background = 'rgba(0,0,0,0.7)';
        deleteImgBtn.style.color = '#fff';
        deleteImgBtn.style.border = 'none';
        deleteImgBtn.style.width = '20px';
        deleteImgBtn.style.height = '20px';
        deleteImgBtn.style.cursor = 'pointer';
        deleteImgBtn.style.fontSize = '14px';
        deleteImgBtn.style.display = 'none';
        
        imgThumb.addEventListener('mouseenter', () => deleteImgBtn.style.display = 'block');
        imgThumb.addEventListener('mouseleave', () => deleteImgBtn.style.display = 'none');
        
        deleteImgBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          imgThumb.remove();
          autoSaveNote();
        });
        
        imgThumb.appendChild(img);
        imgThumb.appendChild(deleteImgBtn);
        
        imgThumb.addEventListener('click', () => {
          const modal = document.createElement('div');
          modal.style.position = 'fixed';
          modal.style.top = '0';
          modal.style.left = '0';
          modal.style.width = '100%';
          modal.style.height = '100%';
          modal.style.background = 'rgba(0,0,0,0.8)';
          modal.style.display = 'flex';
          modal.style.alignItems = 'center';
          modal.style.justifyContent = 'center';
          modal.style.zIndex = '10000';
          
          // ローディング表示
          const loader = document.createElement('div');
          loader.textContent = '読み込み中...';
          loader.style.color = 'white';
          loader.style.fontSize = '18px';
          modal.appendChild(loader);
          document.body.appendChild(modal);
          
          const largeImg = document.createElement('img');
          largeImg.style.maxWidth = '90%';
          largeImg.style.maxHeight = '90%';
          
          // 画像読み込み成功時
          largeImg.onload = () => {
            modal.innerHTML = '';
            modal.appendChild(largeImg);
          };
          
          // 画像読み込みエラー時
          largeImg.onerror = () => {
            loader.textContent = '画像の読み込みに失敗しました';
            loader.style.color = '#ff6b6b';
            console.error('[NOTE] Image load error');
          };
          
          // 画像ソースを設定（アップロード直後はBase64、再ロード後はハッシュベースURL）
          largeImg.src = img.dataset.imagehash 
            ? `/api/note-image/${img.dataset.imagehash}`
            : base64Data;
          
          // クリックでモーダルを閉じる（ただし画像上でのクリックは除く）
          modal.addEventListener('click', (e) => {
            if (e.target === modal || e.target === loader) {
              modal.remove();
            }
          });
        });
        
        imageContainer.insertBefore(imgThumb, dropZone);
        autoSaveNote();
        console.log('[NOTE] Image uploaded:', result.filename);
      } else {
        alert('画像アップロードエラー: ' + result.msg);
      }
    } catch (error) {
      console.error('[ERROR] Image upload failed:', error);
      alert('画像アップロードに失敗しました');
    }
  };
  reader.readAsDataURL(file);
}

// ノートページのデータを取得
function getNotePageData(pageIndex) {
  if (pageIndex < 0 || pageIndex >= notePages.length) return [];
  
  const sections = [];
  const sectionElements = document.querySelectorAll('.note-section');
  
  sectionElements.forEach(section => {
    const titleInput = section.querySelector('.note-section-title');
    const contentTextarea = section.querySelector('.note-section-content');
    const imageElements = section.querySelectorAll('.note-image-thumb img');
    
    if (titleInput && contentTextarea) {
      const images = [];
      imageElements.forEach(img => {
        // 画像データを最適化：ファイルパスを優先
        const imageHash = img.dataset.imagehash;
        const imgSrc = img.src;
        
        if (imageHash) {
          // サーバーに保存されている画像
          images.push({ type: 'hash', value: imageHash });
        } else if (imgSrc && imgSrc.startsWith('data:')) {
          // Base64データ（古い形式）- ファイルパスに変換を試みる
          images.push({ type: 'base64', value: imgSrc });
        } else if (imgSrc && imgSrc.startsWith('file://')) {
          // ローカルファイルパス
          const filePath = decodeURIComponent(imgSrc.replace('file:///', ''));
          images.push({ type: 'path', value: filePath });
        } else {
          // その他の場合
          images.push({ type: 'path', value: imgSrc });
        }
      });
      
      sections.push({
        title: titleInput.value.trim(),
        content: contentTextarea.value.trim(),
        images: images
      });
    }
  });
  
  return sections;
}

// IndexedDB初期化
let db = null;

// IndexedDB の初期化
async function initIndexedDB() {
  return new Promise((resolve) => {
    try {
      // IndexedDB が利用可能かチェック
      if (!window.indexedDB) {
        console.warn('[INDEXEDDB] IndexedDB not supported in this browser');
        resolve(false);
        return;
      }

      // すでに初期化済みかチェック
      if (db) {
        console.log('[INDEXEDDB] Already initialized');
        resolve(true);
        return;
      }

      const request = indexedDB.open('TradingViewNotes', 2);

      request.onerror = (event) => {
        console.error('[INDEXEDDB] Failed to open database:', event.target.error);
        db = null; // 明示的にnullに設定
        resolve(false);
      };

      request.onsuccess = (event) => {
        db = event.target.result;
        console.log('[INDEXEDDB] ✓ Database opened successfully');

        // データベース接続が予期せず閉じられた場合の処理
        db.onclose = () => {
          console.warn('[INDEXEDDB] Database connection closed unexpectedly');
          db = null;
        };

        db.onerror = (event) => {
          console.error('[INDEXEDDB] Database error:', event.target.error);
        };

        resolve(true);
      };

      request.onupgradeneeded = (event) => {
        try {
          const database = event.target.result;
          console.log('[INDEXEDDB] Upgrading database to version', database.version);

          // 画像ストア作成（ハッシュをキーとして使用）
          if (!database.objectStoreNames.contains('noteImages')) {
            const imageStore = database.createObjectStore('noteImages', { keyPath: 'hash' });
            console.log('[INDEXEDDB] ✓ Created noteImages store');
          }

          // ノートメタデータストア作成
          if (!database.objectStoreNames.contains('noteMetadata')) {
            const metadataStore = database.createObjectStore('noteMetadata', { keyPath: 'id' });
            console.log('[INDEXEDDB] ✓ Created noteMetadata store');
          }
        } catch (e) {
          console.error('[INDEXEDDB] Error in onupgradeneeded:', e);
          resolve(false);
        }
      };

      // タイムアウト処理
      setTimeout(() => {
        if (!db) {
          console.warn('[INDEXEDDB] Initialization timeout after 10 seconds');
          resolve(false);
        }
      }, 10000);

    } catch (e) {
      console.error('[INDEXEDDB] Unexpected error during initialization:', e);
      db = null;
      resolve(false);
    }
  });
}

// IndexedDB に画像を保存（Base64形式）
async function saveImageToIndexedDB(imageHash, base64Data) {
  return new Promise((resolve) => {
    if (!db) {
      console.warn('[INDEXEDDB] DB not available for image save');
      resolve(false);
      return;
    }
    
    try {
      const transaction = db.transaction(['noteImages'], 'readwrite');
      const store = transaction.objectStore('noteImages');
      
      const imageData = {
        hash: imageHash,
        data: base64Data,
        savedAt: new Date().toISOString()
      };
      
      const request = store.put(imageData);
      
      transaction.oncomplete = () => {
        console.log('[INDEXEDDB] ✓ Image saved:', imageHash.substring(0, 16) + '...');
        resolve(true);
      };
      
      transaction.onerror = () => {
        console.error('[INDEXEDDB] Error saving image:', transaction.error);
        resolve(false);
      };
    } catch (e) {
      console.error('[INDEXEDDB] Error:', e);
      resolve(false);
    }
  });
}

// IndexedDB から画像を取得（Base64形式）
async function getImageFromIndexedDB(imageHash) {
  return new Promise((resolve) => {
    if (!db) {
      resolve(null);
      return;
    }
    
    try {
      const transaction = db.transaction(['noteImages'], 'readonly');
      const store = transaction.objectStore('noteImages');
      const request = store.get(imageHash);
      
      request.onsuccess = () => {
        if (request.result) {
          console.log('[INDEXEDDB] ✓ Image loaded:', imageHash.substring(0, 16) + '...');
          resolve(request.result.data);
        } else {
          resolve(null);
        }
      };
      
      request.onerror = () => {
        console.error('[INDEXEDDB] Error loading image:', transaction.error);
        resolve(null);
      };
    } catch (e) {
      console.error('[INDEXEDDB] Error:', e);
      resolve(null);
    }
  });
}

// IndexedDB から画像を削除
async function deleteImageFromIndexedDB(imageHash) {
  return new Promise((resolve) => {
    if (!db) {
      resolve(false);
      return;
    }
    
    try {
      const transaction = db.transaction(['noteImages'], 'readwrite');
      const store = transaction.objectStore('noteImages');
      const request = store.delete(imageHash);
      
      transaction.oncomplete = () => {
        console.log('[INDEXEDDB] ✓ Image deleted:', imageHash.substring(0, 16) + '...');
        resolve(true);
      };
      
      transaction.onerror = () => {
        resolve(false);
      };
    } catch (e) {
      console.error('[INDEXEDDB] Error:', e);
      resolve(false);
    }
  });
}

// 画像データのハッシュを生成（簡易版）
async function generateImageHash(base64Data) {
  try {
    // Base64データをArrayBufferに変換
    const binaryString = atob(base64Data.split(',')[1] || base64Data);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    
    // 簡易ハッシュ生成（SHA-256が利用可能なら使用）
    if (crypto && crypto.subtle) {
      const hashBuffer = await crypto.subtle.digest('SHA-256', bytes);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    } else {
      // フォールバック：簡易ハッシュ
      let hash = 0;
      for (let i = 0; i < bytes.length; i++) {
        const char = bytes[i];
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // 32bitに制限
      }
      return Math.abs(hash).toString(16);
    }
  } catch (e) {
    console.error('[HASH] Error generating hash:', e);
    // フォールバック：タイムスタンプベース
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
  }
}

// IndexedDB にノートデータをキャッシュ
async function cacheNotePagesToIndexedDB(pages) {
  return true; // ノートデータ自体はサーバーから取得するため、画像のみを管理
}

// IndexedDB からノートデータを読み込み
async function loadNotePagesFromIndexedDB() {
  return null; // ノートデータはサーバーから取得する
}

// ノートページを保存
async function saveNotePages() {
  if (notePages.length === 0) {
    console.log('[NOTE] No pages to save');
    return;
  }
  
  // 現在のページのセクションデータを更新
  if (currentNotePage < notePages.length) {
    notePages[currentNotePage].sections = getNotePageData(currentNotePage);
    notePages[currentNotePage].lastModified = new Date().toISOString();
    console.log('[NOTE] Updated page', currentNotePage, 'with', notePages[currentNotePage].sections.length, 'sections');
  }
  
  try {
    console.log('[NOTE] Saving', notePages.length, 'pages to server...');
    const response = await fetch('/api/save_notes', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(notePages)
    });
    const result = await response.json();
    if (result.status === 'success') {
      console.log('[NOTE] Successfully saved', notePages.length, 'pages to server');
    } else {
      console.log('[NOTE] Server returned error:', result.msg);
    }
  } catch (error) {
    console.error('[NOTE] Error saving to server:', error);
  }
}

// ノートページを読み込み
async function loadNotePages() {
  try {
    console.log('[NOTE] Starting to load note pages...');
    
    // タイムアウト機能付きで fetch を実行
    const timeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Fetch timeout')), 5000)
    );
    
    const response = await Promise.race([
      fetch('/api/load_notes'),
      timeout
    ]);
    
    if (!response.ok) {
      throw new Error('Failed to load notes: ' + response.status);
    }
    const data = await response.json();
    console.log('[NOTE] Fetched from /api/load_notes:', JSON.stringify(data).substring(0, 200));
    
    if (data.notes && Array.isArray(data.notes) && data.notes.length > 0) {
      notePages = data.notes;
      currentNotePage = Math.min(parseInt(localStorage.getItem('tv_note_current_page')) || 0, notePages.length - 1);
      console.log('[NOTE] Loaded pages from server:', notePages.length, 'page:', currentNotePage);
      console.log('[NOTE] First page title:', notePages[0].title, 'sections:', notePages[0].sections?.length);
      
      // IndexedDB にキャッシュを保存（タイムアウト付き）
      try {
        const cacheTimeout = new Promise(resolve => setTimeout(() => {
          console.warn('[NOTE] Cache operation timed out, continuing...');
          resolve(true);
        }, 2000));
        await Promise.race([cacheNotePagesToIndexedDB(notePages), cacheTimeout]);
      } catch (e) {
        console.warn('[NOTE] Cache error (non-critical):', e);
      }
      
      // UIを更新
      updatePageNavigation();
      loadCurrentPage();
      console.log('[NOTE] UI updated - page navigation and content loaded');
    } else {
      // サーバーにデータがない場合
      console.log('[NOTE] No notes on server (data.notes =', data.notes, '), trying IndexedDB cache...');
      
      // IndexedDB からキャッシュを取得（タイムアウト付き）
      let cachedPages = null;
      try {
        const loadTimeout = new Promise(resolve => setTimeout(() => {
          console.warn('[NOTE] Load from cache timed out');
          resolve(null);
        }, 2000));
        cachedPages = await Promise.race([loadNotePagesFromIndexedDB(), loadTimeout]);
      } catch (e) {
        console.warn('[NOTE] Error loading cache:', e);
      }
      
      if (cachedPages && cachedPages.length > 0) {
        notePages = cachedPages;
        currentNotePage = Math.min(parseInt(localStorage.getItem('tv_note_current_page')) || 0, notePages.length - 1);
        console.log('[NOTE] Loaded from IndexedDB cache:', notePages.length, 'pages');
        updatePageNavigation();
        loadCurrentPage();
      } else {
        // キャッシュもない場合はデフォルトを作成
        console.log('[NOTE] No cache found, creating default pages');
        createDefaultPages();
        updatePageNavigation();
        loadCurrentPage();
      }
    }
  } catch (error) {
    console.error('[NOTE] Error loading from server:', error);
    // サーバーエラー時は IndexedDB キャッシュから復旧を試みる
    console.log('[NOTE] Server error, trying IndexedDB cache...');
    
    let cachedPages = null;
    try {
      const loadTimeout = new Promise(resolve => setTimeout(() => {
        console.warn('[NOTE] Load from cache (after error) timed out');
        resolve(null);
      }, 2000));
      cachedPages = await Promise.race([loadNotePagesFromIndexedDB(), loadTimeout]);
    } catch (e) {
      console.warn('[NOTE] Error loading cache (after server error):', e);
    }
    
    if (cachedPages && cachedPages.length > 0) {
      notePages = cachedPages;
      currentNotePage = Math.min(parseInt(localStorage.getItem('tv_note_current_page')) || 0, notePages.length - 1);
      console.log('[NOTE] Loaded from IndexedDB cache (after error):', notePages.length, 'pages');
      updatePageNavigation();
      loadCurrentPage();
    } else {
      // キャッシュもない場合はデフォルトを作成
      console.log('[NOTE] Error and no cache, creating default pages');
      createDefaultPages();
      updatePageNavigation();
      loadCurrentPage();
    }
  }
}

function migrateFromLocalStorage() {
  const savedPages = localStorage.getItem('tv_note_pages');
  const savedCurrentPage = parseInt(localStorage.getItem('tv_note_current_page')) || 0;
  
  if (savedPages) {
    try {
      notePages = JSON.parse(savedPages);
      currentNotePage = Math.min(savedCurrentPage, notePages.length - 1);
      console.log('[NOTE] Migrated from localStorage:', notePages.length, 'current:', currentNotePage);
    } catch (e) {
      console.log('[NOTE] Failed to parse saved pages, creating default');
      createDefaultPages();
    }
  } else {
    // 既存のtv_note_sectionsがある場合は移行
    const savedSections = localStorage.getItem('tv_note_sections');
    if (savedSections) {
      try {
        const sections = JSON.parse(savedSections);
        notePages = [{
          id: 1,
          title: 'ノート',
          sections: sections,
          lastModified: new Date().toISOString()
        }];
        currentNotePage = 0;
        console.log('[NOTE] Migrated old sections to pages');
      } catch (e) {
        console.log('[NOTE] Failed to migrate old sections');
        createDefaultPages();
      }
    } else {
      createDefaultPages();
    }
  }
}

// デフォルトページを作成
function createDefaultPages() {
  notePages = [{
    id: 1,
    title: 'ノート',
    sections: [],
    lastModified: new Date().toISOString()
  }];
  currentNotePage = 0;
}

// localStorage の古いデータをクリーンアップ
function cleanupOldNoteStorage() {
  try {
    const keysToRemove = [
      'tv_note_pages',           // 古いノートページデータ
      'tv_note_sections',        // 古いセクションデータ
      'tv_note_current_page',    // 現在のページは必要だが、サーバーから取得後に更新
    ];
    
    keysToRemove.forEach(key => {
      if (localStorage.getItem(key)) {
        console.log(`[NOTE CLEANUP] Removing old key: ${key}`);
        localStorage.removeItem(key);
      }
    });
    
    console.log('[NOTE CLEANUP] Old localStorage data cleaned up');
  } catch (e) {
    console.error('[NOTE CLEANUP] Error cleaning up:', e);
  }
}

// 現在のページを読み込み
function loadCurrentPage() {
  if (notePages.length === 0) return;
  
  const page = notePages[currentNotePage];
  loadNoteSections(page.sections);
}

// ノート項目を読み込み
function loadNoteSections(sections) {
  const container = document.getElementById('noteSectionsContainer');
  container.innerHTML = ''; // 既存の項目をクリア
  
  if (!sections || sections.length === 0) {
    // デフォルトの空項目を追加
    container.appendChild(createNoteSection());
    return;
  }
  
  sections.forEach(sectionData => {
    const section = createNoteSection(
      sectionData.title || '',
      sectionData.content || '',
      sectionData.images || []
    );
    container.appendChild(section);
  });
}

// ページナビゲーションを更新
function updatePageNavigation() {
  const pageIndicator = document.getElementById('pageIndicator');
  const pageTitleInput = document.getElementById('pageTitleInput');
  const prevBtn = document.getElementById('prevPage');
  const nextBtn = document.getElementById('nextPage');
  
  if (pageIndicator) {
    pageIndicator.textContent = `${currentNotePage + 1}/${notePages.length}`;
  }
  
  if (pageTitleInput && notePages.length > 0) {
    const currentPage = notePages[currentNotePage];
    pageTitleInput.value = currentPage.title || `ページ ${currentNotePage + 1}`;
    // ページ切り替え時にwidthを自動調整
    pageTitleInput.style.width = 'auto';
    pageTitleInput.style.width = pageTitleInput.scrollWidth + 'px';
  }
  
  if (prevBtn) {
    prevBtn.disabled = currentNotePage === 0;
    prevBtn.style.opacity = currentNotePage === 0 ? '0.5' : '1';
  }
  
  if (nextBtn) {
    nextBtn.disabled = currentNotePage >= notePages.length - 1;
    nextBtn.style.opacity = currentNotePage >= notePages.length - 1 ? '0.5' : '1';
  }
}

// ページを切り替え
function switchToPage(pageIndex) {
  if (pageIndex < 0 || pageIndex >= notePages.length) return;
  
  // 現在のページを保存
  saveNotePages();
  
  // ページを切り替え
  currentNotePage = pageIndex;
  
  // UIを更新
  updatePageNavigation();
  loadCurrentPage();
  
  console.log('[NOTE] Switched to page:', currentNotePage + 1);
}

// ページナビゲーションイベントハンドラーを設定
function setupPageNavigationHandlers() {
  const prevBtn = document.getElementById('prevPage');
  const nextBtn = document.getElementById('nextPage');
  const addPageBtn = document.getElementById('addPage');
  const deletePageBtn = document.getElementById('deletePage');
  const pageTitleInput = document.getElementById('pageTitleInput');
  
  if (prevBtn) {
    prevBtn.removeEventListener('click', handlePrevPage);
    prevBtn.addEventListener('click', handlePrevPage);
  }
  
  if (nextBtn) {
    nextBtn.removeEventListener('click', handleNextPage);
    nextBtn.addEventListener('click', handleNextPage);
  }
  
  if (addPageBtn) {
    addPageBtn.removeEventListener('click', handleAddPage);
    addPageBtn.addEventListener('click', handleAddPage);
  }
  
  if (deletePageBtn) {
    deletePageBtn.removeEventListener('click', handleDeletePage);
    deletePageBtn.addEventListener('click', handleDeletePage);
  }
  
  if (pageTitleInput) {
    pageTitleInput.removeEventListener('input', handlePageTitleInput);
    pageTitleInput.addEventListener('input', handlePageTitleInput);
    
    pageTitleInput.removeEventListener('keydown', handlePageTitleKeydown);
    pageTitleInput.addEventListener('keydown', handlePageTitleKeydown);
  }
}

// ページナビゲーションのハンドラー関数（グローバルに定義）
function handlePrevPage() {
  if (currentNotePage > 0) {
    switchToPage(currentNotePage - 1);
  }
}

function handleNextPage() {
  if (currentNotePage < notePages.length - 1) {
    switchToPage(currentNotePage + 1);
  }
}

function handleAddPage() {
  addNewPage();
}

function handleDeletePage() {
  deleteCurrentPage();
}

function handlePageTitleInput() {
  if (notePages.length > 0 && currentNotePage < notePages.length) {
    notePages[currentNotePage].title = pageTitleInput.value.trim() || `ページ ${currentNotePage + 1}`;
    notePages[currentNotePage].lastModified = new Date().toISOString();
    saveNotePages();
  }
  // 文字数に応じてwidthを自動調整
  pageTitleInput.style.width = 'auto';
  pageTitleInput.style.width = pageTitleInput.scrollWidth + 'px';
}

function handlePageTitleKeydown(e) {
  if (e.key === 'Enter') {
    pageTitleInput.blur();
  }
}

// 新しいページを追加
function addNewPage() {
  const pageTitle = prompt('新しいページのタイトルを入力してください:', `ページ ${notePages.length + 1}`);
  if (!pageTitle || pageTitle.trim() === '') return;
  
  // 現在のページを保存
  saveNotePages();
  
  const newPage = {
    id: Date.now(),
    title: pageTitle.trim(),
    sections: [],
    lastModified: new Date().toISOString()
  };
  
  notePages.push(newPage);
  currentNotePage = notePages.length - 1;
  
  updatePageNavigation();
  loadCurrentPage();
  
  // 新しいページのタイトル入力フィールドにフォーカスを当てる
  setTimeout(() => {
    const pageTitleInput = document.getElementById('pageTitleInput');
    if (pageTitleInput) {
      pageTitleInput.focus();
      pageTitleInput.select();
    }
  }, 100);
  
  console.log('[NOTE] Added new page:', pageTitle);
}

// 現在のページを削除
function deleteCurrentPage() {
  if (notePages.length <= 1) {
    alert('最後のページは削除できません。');
    return;
  }
  
  const pageTitle = notePages[currentNotePage].title;
  if (!confirm(`ページ "${pageTitle}" を削除しますか？\nこの操作は取り消せません。`)) {
    return;
  }
  
  notePages.splice(currentNotePage, 1);
  
  if (currentNotePage >= notePages.length) {
    currentNotePage = notePages.length - 1;
  }
  
  updatePageNavigation();
  loadCurrentPage();
  
  console.log('[NOTE] Deleted page:', pageTitle);
}

// ノートページを出力
async function exportNotePages() {
  if (notePages.length === 0) {
    alert('出力するデータがありません。');
    return;
  }

  // IndexedDBの状態を再確認
  if (!db) {
    console.log('[EXPORT] DB not available, attempting to initialize...');
    const initialized = await initIndexedDB();
    if (!initialized) {
      const proceed = confirm('IndexedDBが利用できません。画像データを含めずにエクスポートしますか？\n\nはい: 画像なしでエクスポート\nいいえ: キャンセル');
      if (!proceed) {
        return;
      }
      includeImages = false;
    }
  }

  // 現在のページを保存
  saveNotePages();

  let includeImages = true;
  if (!db) {
    includeImages = false;
  }

  try {
    let pagesToExport = notePages;

    if (includeImages) {
      // 画像データを収集して埋め込む
      pagesToExport = await Promise.all(notePages.map(async (page) => {
        const sectionsWithImages = await Promise.all(page.sections.map(async (section) => {
          const imagesWithData = await Promise.all((section.images || []).map(async (image) => {
            if (image.type === 'hash' && image.value) {
              // IndexedDBから画像データを取得
              const base64Data = await getImageFromIndexedDB(image.value);
              if (base64Data) {
                return {
                  type: 'base64',
                  value: base64Data,
                  hash: image.value // ハッシュも保持
                };
              } else {
                console.warn('[EXPORT] Image not found in IndexedDB:', image.value);
                return image; // ハッシュのまま返す
              }
            }
            // ハッシュがない場合や取得失敗時はそのまま返す
            return image;
          }));

          return {
            ...section,
            images: imagesWithData
          };
        }));

        return {
          ...page,
          sections: sectionsWithImages
        };
      }));
    }

    const exportData = {
      version: includeImages ? '1.1' : '1.0', // 画像データを含む場合は1.1
      exportedAt: new Date().toISOString(),
      includeImages: includeImages,
      pages: pagesToExport
    };

    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);

    const link = document.createElement('a');
    link.href = url;
    link.download = `note_pages_export_${new Date().toISOString().split('T')[0]}${includeImages ? '_with_images' : '_no_images'}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    console.log('[NOTE] Exported pages:', notePages.length, 'with images:', includeImages);
    alert(includeImages ? 'ノートページを画像データ付きでエクスポートしました。' : 'ノートページを画像データなしでエクスポートしました。');

  } catch (error) {
    console.error('[NOTE] Export error:', error);
    alert('エクスポート中にエラーが発生しました: ' + error.message);
  }
}

// ノートページを読込（オプション選択ダイアログ）
function showImportOptionsDialog(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const importData = JSON.parse(e.target.result);
      
      if (!importData.pages || !Array.isArray(importData.pages)) {
        throw new Error('無効なファイル形式です。');
      }
      
      // 読込オプション選択ダイアログを作成
      const dialog = document.createElement('div');
      dialog.style.position = 'fixed';
      dialog.style.top = '0';
      dialog.style.left = '0';
      dialog.style.width = '100%';
      dialog.style.height = '100%';
      dialog.style.background = 'rgba(0,0,0,0.5)';
      dialog.style.display = 'flex';
      dialog.style.alignItems = 'center';
      dialog.style.justifyContent = 'center';
      dialog.style.zIndex = '10000';
      
      const dialogContent = document.createElement('div');
      dialogContent.style.background = 'rgba(0,0,0,0.9)';
      dialogContent.style.border = '1px solid rgba(255,255,255,0.3)';
      dialogContent.style.borderRadius = '8px';
      dialogContent.style.padding = '20px';
      dialogContent.style.maxWidth = '400px';
      dialogContent.style.width = '90%';
      
      const title = document.createElement('h3');
      title.textContent = '読込オプションを選択';
      title.style.margin = '0 0 16px 0';
      title.style.color = '#fff';
      
      const form = document.createElement('form');
      
      const options = [
        { value: 'replace', label: '完全置き換え: 現在のデータを読込データで完全に上書きします' },
        { value: 'merge', label: 'マージ追加: 読込データを新しいページとして追加します' },
        { value: 'preview', label: 'プレビュー表示: 読込データを確認のみ表示します（現在のデータに影響なし）' }
      ];
      
      options.forEach(option => {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.margin = '8px 0';
        label.style.color = '#fff';
        label.style.cursor = 'pointer';
        
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'importOption';
        radio.value = option.value;
        radio.style.marginRight = '8px';
        
        label.appendChild(radio);
        label.appendChild(document.createTextNode(option.label));
        form.appendChild(label);
      });
      
      const buttonContainer = document.createElement('div');
      buttonContainer.style.display = 'flex';
      buttonContainer.style.gap = '12px';
      buttonContainer.style.marginTop = '20px';
      buttonContainer.style.justifyContent = 'flex-end';
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'キャンセル';
      cancelBtn.type = 'button';
      cancelBtn.style.padding = '8px 16px';
      cancelBtn.style.background = 'rgba(128,128,128,0.2)';
      cancelBtn.style.color = '#fff';
      cancelBtn.style.border = '1px solid #666';
      cancelBtn.style.borderRadius = '4px';
      cancelBtn.style.cursor = 'pointer';
      cancelBtn.addEventListener('click', () => dialog.remove());
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = '実行';
      confirmBtn.type = 'submit';
      confirmBtn.style.padding = '8px 16px';
      confirmBtn.style.background = 'rgba(102,126,234,0.2)';
      confirmBtn.style.color = '#667eea';
      confirmBtn.style.border = '1px solid #667eea';
      confirmBtn.style.borderRadius = '4px';
      confirmBtn.style.cursor = 'pointer';
      
      buttonContainer.appendChild(cancelBtn);
      buttonContainer.appendChild(confirmBtn);
      
      form.appendChild(buttonContainer);
      
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        const selectedOption = form.querySelector('input[name="importOption"]:checked');
        if (!selectedOption) {
          alert('オプションを選択してください。');
          return;
        }
        
        const option = selectedOption.value;
        dialog.remove();
        
        if (option === 'replace') {
          importNotePages(importData, 'replace');
        } else if (option === 'merge') {
          importNotePages(importData, 'merge');
        } else if (option === 'preview') {
          previewImportData(importData);
        }
      });
      
      dialogContent.appendChild(title);
      dialogContent.appendChild(form);
      dialog.appendChild(dialogContent);
      document.body.appendChild(dialog);
      
    } catch (error) {
      alert('ファイルの読み込みに失敗しました: ' + error.message);
      console.error('[NOTE] Import dialog failed:', error);
    }
  };
  reader.readAsText(file);
}

// ノートページを読込（モード指定）
async function importNotePages(importData, mode) {
  try {
    if (!importData.pages || !Array.isArray(importData.pages)) {
      throw new Error('無効な読込データです。');
    }
    
    // 現在のページを保存
    saveNotePages();
    
    if (mode === 'replace') {
      // 完全置き換え
      const processedPages = await Promise.all(importData.pages.map(async (page) => {
        const processedSections = await Promise.all(page.sections.map(async (section) => {
          const processedImages = await Promise.all((section.images || []).map(async (image) => {
            if (image.type === 'base64' && image.value) {
              // Base64データをIndexedDBに保存
              const hash = image.hash || await generateImageHash(image.value);
              await saveImageToIndexedDB(hash, image.value);
              return { type: 'hash', value: hash };
            }
            return image;
          }));
          
          return {
            ...section,
            images: processedImages
          };
        }));
        
        return {
          ...page,
          id: page.id || Date.now() + Math.random(), // IDがなければ新規生成
          lastModified: new Date().toISOString(),
          sections: processedSections
        };
      }));
      
      notePages = processedPages;
      currentNotePage = 0;
      console.log('[NOTE] Replaced all pages with imported data (with images):', notePages.length);
      
    } else if (mode === 'merge') {
      // マージ追加（新しいページとして追加）
      const processedPages = await Promise.all(importData.pages.map(async (page) => {
        const processedSections = await Promise.all(page.sections.map(async (section) => {
          const processedImages = await Promise.all((section.images || []).map(async (image) => {
            if (image.type === 'base64' && image.value) {
              // Base64データをIndexedDBに保存
              const hash = image.hash || await generateImageHash(image.value);
              await saveImageToIndexedDB(hash, image.value);
              return { type: 'hash', value: hash };
            }
            return image;
          }));
          
          return {
            ...section,
            images: processedImages
          };
        }));
        
        return {
          ...page,
          id: Date.now() + Math.random(), // 新しいIDを生成
          title: page.title + ' (読込)', // タイトルにマークを付ける
          lastModified: new Date().toISOString(),
          sections: processedSections
        };
      }));
      
      notePages = notePages.concat(processedPages);
      currentNotePage = notePages.length - processedPages.length; // 最初の追加ページに移動
      console.log('[NOTE] Merged imported pages (with images):', processedPages.length, 'total pages:', notePages.length);
    }
    
    // UI更新
    updatePageNavigation();
    loadCurrentPage();
    
    // 保存
    saveNotePages();
    
    alert(mode === 'replace' ? 'ノートを完全に置き換えました。' : 'ノートをマージ追加しました。');
    
  } catch (error) {
    alert('インポートに失敗しました: ' + error.message);
    console.error('[NOTE] Import failed:', error);
  }
}

// 読込データをプレビュー表示
function previewImportData(importData) {
  try {
    if (!importData.pages || !Array.isArray(importData.pages)) {
      throw new Error('無効なインポートデータです。');
    }
    
    // プレビューモーダルを作成
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.background = 'rgba(0,0,0,0.8)';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    modal.style.zIndex = '10001';
    
    const modalContent = document.createElement('div');
    modalContent.style.background = 'rgba(0,0,0,0.95)';
    modalContent.style.border = '1px solid rgba(255,255,255,0.3)';
    modalContent.style.borderRadius = '8px';
    modalContent.style.padding = '20px';
    modalContent.style.maxWidth = '800px';
    modalContent.style.width = '90%';
    modalContent.style.maxHeight = '80vh';
    modalContent.style.overflowY = 'auto';
    
    const title = document.createElement('h3');
    title.textContent = '読込データプレビュー';
    title.style.margin = '0 0 16px 0';
    title.style.color = '#fff';
    
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '閉じる';
    closeBtn.style.padding = '8px 16px';
    closeBtn.style.background = 'rgba(128,128,128,0.2)';
    closeBtn.style.color = '#fff';
    closeBtn.style.border = '1px solid #666';
    closeBtn.style.borderRadius = '4px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.float = 'right';
    closeBtn.addEventListener('click', () => modal.remove());
    
    title.appendChild(closeBtn);
    
    const content = document.createElement('div');
    content.style.marginTop = '20px';
    
    // インポートデータの概要を表示
    const summary = document.createElement('div');
    summary.style.marginBottom = '20px';
    summary.style.padding = '10px';
    summary.style.background = 'rgba(255,255,255,0.1)';
    summary.style.borderRadius = '4px';
    summary.innerHTML = `
      <strong>バージョン:</strong> ${importData.version || '不明'}<br>
      <strong>出力日時:</strong> ${importData.exportedAt ? new Date(importData.exportedAt).toLocaleString('ja-JP') : '不明'}<br>
      <strong>ページ数:</strong> ${importData.pages.length}<br>
      <strong>画像データ:</strong> ${importData.version === '1.1' ? '含む' : 'なし'}
    `;
    content.appendChild(summary);
    
    // 各ページの情報を表示
    importData.pages.forEach((page, index) => {
      const pageDiv = document.createElement('div');
      pageDiv.style.marginBottom = '20px';
      pageDiv.style.padding = '15px';
      pageDiv.style.border = '1px solid rgba(255,255,255,0.2)';
      pageDiv.style.borderRadius = '6px';
      
      const pageTitle = document.createElement('h4');
      pageTitle.textContent = `ページ ${index + 1}: ${page.title || '無題'}`;
      pageTitle.style.margin = '0 0 10px 0';
      pageTitle.style.color = '#fff';
      pageTitle.style.fontWeight = 'bold';
      
      const pageInfo = document.createElement('div');
      pageInfo.style.marginBottom = '15px';
      pageInfo.style.fontSize = '0.9em';
      pageInfo.style.color = 'rgba(255,255,255,0.8)';
      const imageCount = page.sections ? page.sections.reduce((total, section) => {
        return total + (section.images ? section.images.length : 0);
      }, 0) : 0;
      pageInfo.innerHTML = `
        <div style="margin-bottom: 5px;"><strong>項目数:</strong> ${page.sections ? page.sections.length : 0}</div>
        <div style="margin-bottom: 5px;"><strong>画像数:</strong> ${imageCount}</div>
        <div><strong>最終更新:</strong> ${page.lastModified ? new Date(page.lastModified).toLocaleString('ja-JP') : '不明'}</div>
      `;
      
      pageDiv.appendChild(pageTitle);
      pageDiv.appendChild(pageInfo);
      
      // セクションの詳細表示
      if (page.sections && page.sections.length > 0) {
        const sectionsContainer = document.createElement('div');
        sectionsContainer.style.marginTop = '10px';
        
        page.sections.forEach((section, secIndex) => {
          const sectionDiv = document.createElement('div');
          sectionDiv.style.marginBottom = '12px';
          sectionDiv.style.padding = '10px';
          sectionDiv.style.background = 'rgba(255,255,255,0.05)';
          sectionDiv.style.borderRadius = '4px';
          sectionDiv.style.border = '1px solid rgba(255,255,255,0.1)';
          
          const sectionTitle = document.createElement('div');
          sectionTitle.textContent = `項目 ${secIndex + 1}: ${section.title || '無題'}`;
          sectionTitle.style.fontWeight = 'bold';
          sectionTitle.style.color = '#fff';
          sectionTitle.style.marginBottom = '5px';
          
          const sectionContent = document.createElement('div');
          sectionContent.style.fontSize = '0.85em';
          sectionContent.style.color = 'rgba(255,255,255,0.7)';
          sectionContent.style.lineHeight = '1.4';
          sectionContent.textContent = section.content ? 
            (section.content.length > 100 ? section.content.substring(0, 100) + '...' : section.content) : 
            '内容なし';
          
          sectionDiv.appendChild(sectionTitle);
          sectionDiv.appendChild(sectionContent);
          sectionsContainer.appendChild(sectionDiv);
        });
        
        pageDiv.appendChild(sectionsContainer);
      } else {
        const noSections = document.createElement('div');
        noSections.textContent = '項目なし';
        noSections.style.fontSize = '0.9em';
        noSections.style.color = 'rgba(255,255,255,0.5)';
        noSections.style.fontStyle = 'italic';
        pageDiv.appendChild(noSections);
      }
      
      content.appendChild(pageDiv);
    });
    
    modalContent.appendChild(title);
    modalContent.appendChild(content);
    modal.appendChild(modalContent);
    
    // モーダルを閉じるためのクリックイベント
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.remove();
      }
    });
    
    document.body.appendChild(modal);
    
    console.log('[NOTE] Preview modal opened for imported data');
    
  } catch (error) {
    alert('プレビュー表示に失敗しました: ' + error.message);
    console.error('[NOTE] Preview failed:', error);
  }
}

// ノートモーダルの保存とクリア機能
const saveNoteBtn = document.getElementById('saveNote');
const exportNoteBtn = document.getElementById('exportNote');
const importNoteBtn = document.getElementById('importNote');
const addNoteSectionBtn = document.getElementById('addNoteSection');

// 自動保存タイマー
let autoSaveTimer = null;

// ノート内容を自動保存する関数
const autoSaveNote = () => {
  if (isNoteModalOpen) {
    saveNotePages();
  }
};

// テキストエリアの入力イベントで自動保存をスケジュール
document.addEventListener('input', (e) => {
  if (e.target.closest('.note-section') && isNoteModalOpen) {
    // 既存のタイマーをクリア
    if (autoSaveTimer) {
      clearTimeout(autoSaveTimer);
    }
    // 3秒後に自動保存
    autoSaveTimer = setTimeout(() => {
      autoSaveNote();
    }, 3000);
  }
});

if (saveNoteBtn) {
  saveNoteBtn.addEventListener('click', () => {
    saveNotePages();
    alert('ノートを保存しました');
    // タイマーをクリア
    if (autoSaveTimer) {
      clearTimeout(autoSaveTimer);
    }
  });
}

if (exportNoteBtn) {
  exportNoteBtn.addEventListener('click', () => {
    exportNotePages();
  });
}

if (importNoteBtn) {
  importNoteBtn.addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        showImportOptionsDialog(file);
      }
    });
    input.click();
  });
}



if (addNoteSectionBtn) {
  addNoteSectionBtn.addEventListener('click', () => {
    const container = document.getElementById('noteSectionsContainer');
    container.appendChild(createNoteSection());
    // 新しいセクションをスクロールして表示
    setTimeout(() => {
      const newSection = container.lastElementChild;
      if (newSection) {
        newSection.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }
    }, 100);
  });
}

// ノートフォントサイズドロップダウンのイベントリスナー
const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
if (noteFontSizeSelect) {
  noteFontSizeSelect.addEventListener('change', (e) => {
    const selectedSize = e.target.value;
    localStorage.setItem('tv_note_font_size', selectedSize);
    applyNoteFontSize(selectedSize);
  });
}  // ノートモーダルを閉じるときにサイズと位置を保存
  const saveNoteModalState = () => {
    if (noteModal) {
      const rect = noteModal.getBoundingClientRect();
      localStorage.setItem('tv_note_modal_width', rect.width);
      localStorage.setItem('tv_note_modal_height', rect.height);
      localStorage.setItem('tv_note_modal_left', noteModal.style.left || '50%');
      localStorage.setItem('tv_note_modal_top', noteModal.style.top || '50%');
    }
    // クローズ時にノート内容も自動保存
    saveNotePages();
  };

  if (closeNoteBtn && noteModal) {
    closeNoteBtn.addEventListener('click', () => {
      saveNoteModalState();
      noteOverlay.style.display = 'none';
      isNoteModalOpen = false;
    });
  }

  // オーバーレイクリックでもサイズと位置を保存
  if (noteOverlay && noteModal) {
    noteOverlay.addEventListener('click', (e) => {
      if (e.target === noteOverlay && !isResizingNote && !isDraggingNote) {
        saveNoteModalState();
        noteOverlay.style.display = 'none';
        isNoteModalOpen = false;
      }
    });
  }

  console.log('[INIT] All event listeners setup complete');
}

// 通貨名マッピング（サーバー側と同じ）
const currencyNames = {
  'USDJPY': 'ドル円',
  'EURUSD': 'ユーロドル',
  'GBPUSD': 'ポンドドル',
  'GBPJPY': 'ポンド円',
  'AUDUSD': 'オージードル',
  'AUDJPY': 'オージー円',
  'NZDUSD': 'ニュージードル',
  'NZDJPY': 'ニュージー円',
  'CADJPY': 'カナダ円',
  'CHFJPY': 'スイス円',
  'EURJPY': 'ユーロ円',
  'GBPAUD': 'ポンドオージー',
  'EURGBP': 'ユーロポンド',
  'USDCAD': 'ドルカナダ',
  'USDCHF': 'ドルスイス'
};

// グローバル変数: Socket.IOコネクション
let socket = null;

// グローバル変数: 現在のダッシュボードデータ（テスト時に使用）
let currentDashboardData = null;

// グローバル変数: 最終WebSocket更新時刻を追跡
let lastWebSocketUpdate = Date.now();

// グローバル変数: 全ルールデータ（ルールカウントボタン用）
let allRules = [];

// 設定パネルの動作: モード切替（body にクラス付与）とフォントサイズの適用
function applyMode(mode) {
  document.body.classList.remove('light-mode','dark-mode');
  if (mode === 'light') {
    document.body.classList.add('light-mode');
    // テーブルを完全ホワイト背景にする
    const tables = document.querySelectorAll('table');
    tables.forEach(table => {
      table.style.background = '#ffffff';
    });
    
    // ページナビゲーションのスタイル適用（ライトモード）
    const pageIndicator = document.getElementById('pageIndicator');
    if (pageIndicator) {
      pageIndicator.style.color = '#000000'; // 黒文字
    }
    
    // ノートモーダルのボタンスタイルをライトモードに統一
    document.querySelectorAll('#addPage, #deletePage, #addNoteSection, #saveNote, #exportNote, #importNote, #closeNote').forEach(btn => {
      btn.style.background = '#ffffff';
      btn.style.color = '#000000';
      btn.style.borderColor = '#000000';
    });
    
    // ノートフォントサイズドロップダウンもライトモードに
    const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
    if (noteFontSizeSelect) {
      noteFontSizeSelect.style.background = '#ffffff';
      noteFontSizeSelect.style.color = '#000000';
      noteFontSizeSelect.style.borderColor = '#000000';
    }
    
    // ページタイトル入力ボックスもボタンと同じスタイルに
    const pageTitleInput = document.getElementById('pageTitleInput');
    if (pageTitleInput) {
      pageTitleInput.style.background = '#ffffff';
      pageTitleInput.style.color = '#000000';
      pageTitleInput.style.borderColor = '#000000';
      pageTitleInput.style.minWidth = '200px';
      pageTitleInput.style.width = 'auto';
      pageTitleInput.style.maxWidth = '500px';
    }
  } else {
    document.body.classList.add('dark-mode');
    // テーブル背景をリセット
    const tables = document.querySelectorAll('table');
    tables.forEach(table => {
      table.style.background = '';
    });
    
    // ページナビゲーションのスタイル適用（ダークモード）
    const pageIndicator = document.getElementById('pageIndicator');
    if (pageIndicator) {
      pageIndicator.style.color = 'rgba(255,255,255,0.8)'; // 白文字
    }
    
    // ノートモーダルのボタンスタイルをダークモードに統一
    document.querySelectorAll('#addPage, #deletePage, #addNoteSection, #saveNote, #exportNote, #importNote, #closeNote').forEach(btn => {
      btn.style.background = 'rgba(0,0,0,0.2)';
      btn.style.color = '#ffffff';
      btn.style.borderColor = '#ffffff';
    });
    
    // ノートフォントサイズドロップダウンもダークモードに
    const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
    if (noteFontSizeSelect) {
      noteFontSizeSelect.style.background = 'rgba(0,0,0,0.2)';
      noteFontSizeSelect.style.color = '#ffffff';
      noteFontSizeSelect.style.borderColor = '#ffffff';
    }
    
    // ページタイトル入力ボックスもボタンと同じスタイルに
    const pageTitleInput = document.getElementById('pageTitleInput');
    if (pageTitleInput) {
      pageTitleInput.style.background = 'rgba(0,0,0,0.2)';
      pageTitleInput.style.color = '#ffffff';
      pageTitleInput.style.borderColor = '#ffffff';
      pageTitleInput.style.minWidth = '200px';
      pageTitleInput.style.width = 'auto';
      pageTitleInput.style.maxWidth = '500px';
    }
  }
}

function applyFontSize(px) {
  // テーブルの th と td にのみフォントサイズを適用（セルの色は変更しない）
  const els = document.querySelectorAll('table th, table td');
  els.forEach(el => {
    el.style.fontSize = px + 'px';
  });
  
  // 発火履歴ウィンドウの全要素にフォントサイズを適用
  const fireHistoryEls = document.querySelectorAll('.currency-fire-history h3, .currency-fire-history button, .fire-item, .fire-time, .fire-name, .fire-direction, .currency-fire-history-list');
  fireHistoryEls.forEach(el => {
    el.style.fontSize = px + 'px';
  });
  
  // 発火履歴ウィンドウの横幅を文字サイズに合わせて調整
  // 基本: 300px (14px時) + 追加幅
  const baseFontSize = 14;
  const additionalWidth = Math.max(0, (px - baseFontSize) * 8); // 文字サイズが1px増えるごとに8px横幅を増やす
  const newWidth = 300 + additionalWidth;
  
  const fireHistories = document.querySelectorAll('.currency-fire-history');
  fireHistories.forEach(fh => {
    fh.style.minWidth = newWidth + 'px';
  });
}

function applyNoteFontSize(px) {
  // ノートセクションのタイトルとコンテンツにフォントサイズを適用
  const noteTitles = document.querySelectorAll('.note-section-title');
  const noteContents = document.querySelectorAll('.note-section-content');
  
  noteTitles.forEach(title => {
    title.style.fontSize = px + 'px';
  });
  
  noteContents.forEach(content => {
    content.style.fontSize = px + 'px';
  });
}

function applyColumnVisibility() {
  // localStorageから設定を読み込み
  const savedCols = JSON.parse(localStorage.getItem('tv_cols') || '{}');
  
  // 列ごとに表示/非表示を適用
  for (let colIndex = 1; colIndex <= 11; colIndex++) {
    const visible = savedCols[colIndex.toString()] !== false; // デフォルトtrue
    const selector = `table th:nth-child(${colIndex + 1}), table td:nth-child(${colIndex + 1})`;
    document.querySelectorAll(selector).forEach(el => {
      el.style.display = visible ? '' : 'none';
    });
  }
  
  // ダッシュボード内のチェックボックスがあれば更新
  document.querySelectorAll('.col-toggle').forEach(cb => {
    const col = cb.dataset.col;
    cb.checked = savedCols[col] !== false;
  });
}

function applyRowVisibility() {
  // localStorageから設定を読み込み
  const savedRows = JSON.parse(localStorage.getItem('tv_rows') || '{}');
  
  const allRows = document.querySelectorAll('table tr');
  allRows.forEach(tr => {
    const labelCell = tr.querySelector('.tf-label');
    if (labelCell) {
      const text = labelCell.textContent.trim();
      let rowLabel = null;
      if (text === '価格') rowLabel = 'price';
      else if (text === '5m') rowLabel = '5m';
      else if (text === '15m') rowLabel = '15m';
      else if (text === '1H') rowLabel = '1H';
      else if (text === '4H') rowLabel = '4H';
      
      if (rowLabel) {
        const visible = savedRows[rowLabel] !== false; // デフォルトtrue
        tr.style.display = visible ? '' : 'none';
      }
    }
  });
  
  // ダッシュボード内のチェックボックスがあれば更新
  document.querySelectorAll('.row-toggle').forEach(cb => {
    const row = cb.dataset.row;
    cb.checked = savedRows[row] !== false;
  });
}

function applyCurrencyFilter() {
  // localStorageから設定を読み込み
  const savedCurrencies = JSON.parse(localStorage.getItem('tv_currencies') || '{}');
  
  // 通貨ごとのセクションを表示/非表示
  document.querySelectorAll('.currency-section').forEach(section => {
    const symbol = section.dataset.symbol;
    const visible = savedCurrencies[symbol] !== false; // デフォルトtrue
    if (visible) {
      section.classList.remove('hidden');
    } else {
      section.classList.add('hidden');
    }
  });
  
  // ダッシュボード内のチェックボックスがあれば更新
  document.querySelectorAll('.currency-toggle').forEach(cb => {
    const currency = cb.dataset.currency;
    cb.checked = savedCurrencies[currency] !== false;
  });
}

function updateCurrencyFilter(availableCurrencies) {
  const container = document.getElementById('currencyFilterContainer');
  const savedCurrencies = JSON.parse(localStorage.getItem('tv_currencies') || '{}');
  
  // TESTERを除外
  const filteredCurrencies = availableCurrencies.filter(c => c !== 'TESTER');
  
  // 既存のチェックボックスの通貨を記録
  const existingCurrencies = new Set();
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    existingCurrencies.add(cb.dataset.currency);
  });
  
  // 新しい通貨があれば追加
  filteredCurrencies.forEach(currency => {
    if (!existingCurrencies.has(currency)) {
      const label = document.createElement('label');
      label.style.fontSize = '0.9em';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'currency-toggle';
      checkbox.dataset.currency = currency;
      checkbox.checked = (savedCurrencies[currency] !== false); // デフォルトtrue
      
      checkbox.addEventListener('change', async () => {
        const currencies = {};
        document.querySelectorAll('.currency-toggle').forEach(cb => {
          currencies[cb.dataset.currency] = cb.checked;
        });
        localStorage.setItem('tv_currencies', JSON.stringify(currencies));
        applyCurrencyFilter();
        await load(); // テーブル再描画
      });
      
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(' ' + currency));
      container.appendChild(label);
    }
  });
  
  // 保存された設定を適用
  container.querySelectorAll('.currency-toggle').forEach(cb => {
    const currency = cb.dataset.currency;
    cb.checked = (savedCurrencies[currency] !== false);
  });
  
  applyCurrencyFilter();
}

function loadSettings() {
  const savedMode = localStorage.getItem('tv_mode') || 'dark';
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  const savedCols = JSON.parse(localStorage.getItem('tv_cols') || '{}');
  const savedRows = JSON.parse(localStorage.getItem('tv_rows') || '{}');
  const savedTimeFormat = localStorage.getItem('tv_time_format') || 'datetime';
  const savedEnable5mUpdate = localStorage.getItem('tv_enable_5m_update') !== 'false'; // デフォルトtrue
  const savedVoiceVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
  const savedVoiceRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
  
  // set UI
  document.getElementById('modeDark').checked = (savedMode === 'dark');
  document.getElementById('modeLight').checked = (savedMode === 'light');
  document.getElementById('fontSizeSelect').value = savedSize;
  document.getElementById('timeFormatSelect').value = savedTimeFormat;
  document.getElementById('enable5mUpdateToggle').checked = savedEnable5mUpdate;
  document.getElementById('voiceVolume').value = savedVoiceVolume;
  document.getElementById('voiceVolumeValue').textContent = Math.round(savedVoiceVolume * 100) + '%';
  document.getElementById('voiceRate').value = savedVoiceRate;
  document.getElementById('voiceRateValue').textContent = savedVoiceRate.toFixed(1) + 'x';
  
  // 列チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    const col = cb.dataset.col;
    cb.checked = (savedCols[col] !== false); // デフォルトtrue
  });
  
  // 行チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    const row = cb.dataset.row;
    cb.checked = (savedRows[row] !== false); // デフォルトtrue
  });
  
  applyMode(savedMode);
  applyFontSize(savedSize);
  applyColumnVisibility();
  applyRowVisibility();
  
  // ノートフォントサイズの設定を読み込み
  const savedNoteFontSize = localStorage.getItem('tv_note_font_size') || '15';
  const noteFontSizeSelect = document.getElementById('noteFontSizeSelect');
  if (noteFontSizeSelect) {
    noteFontSizeSelect.value = savedNoteFontSize;
  }
  applyNoteFontSize(savedNoteFontSize);
}

function wireSettings() {
  document.getElementById('modeDark').addEventListener('change', async e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','dark'); applyMode('dark'); await load(); }
  });
  document.getElementById('modeLight').addEventListener('change', async e => {
    if (e.target.checked) { localStorage.setItem('tv_mode','light'); applyMode('light'); await load(); }
  });
  document.getElementById('fontSizeSelect').addEventListener('change', async e => {
    localStorage.setItem('tv_font_size', e.target.value);
    applyFontSize(e.target.value);
    await load(); // テーブル再描画
  });
  
  // 列表示チェックボックス
  document.querySelectorAll('.col-toggle').forEach(cb => {
    cb.addEventListener('change', async () => {
      const cols = {};
      document.querySelectorAll('.col-toggle').forEach(c => {
        cols[c.dataset.col] = c.checked;
      });
      localStorage.setItem('tv_cols', JSON.stringify(cols));
      applyColumnVisibility();
      await load(); // テーブル再描画
    });
  });
  
  // 行表示チェックボックス
  document.querySelectorAll('.row-toggle').forEach(cb => {
    cb.addEventListener('change', async () => {
      const rows = {};
      document.querySelectorAll('.row-toggle').forEach(r => {
        rows[r.dataset.row] = r.checked;
      });
      localStorage.setItem('tv_rows', JSON.stringify(rows));
      applyRowVisibility();
      await load(); // テーブル再描画
    });
  });
  
  // 経過時間形式プルダウン
  document.getElementById('timeFormatSelect').addEventListener('change', e => {
    localStorage.setItem('tv_time_format', e.target.value);
    load(); // 再読み込みして表示を更新
  });
  
  // 5分毎更新トグル
  document.getElementById('enable5mUpdateToggle').addEventListener('change', e => {
    localStorage.setItem('tv_enable_5m_update', e.target.checked.toString());
  });
  
  // 音声設定（グローバル）
  document.getElementById('voiceVolume').addEventListener('input', e => {
    const vol = parseFloat(e.target.value);
    document.getElementById('voiceVolumeValue').textContent = Math.round(vol * 100) + '%';
    localStorage.setItem('tv_voice_volume', vol.toString());
  });
  document.getElementById('voiceRate').addEventListener('input', e => {
    const rate = parseFloat(e.target.value);
    document.getElementById('voiceRateValue').textContent = rate.toFixed(1) + 'x';
    localStorage.setItem('tv_voice_rate', rate.toString());
  });
}

function wireSectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_sections') || '{}');
    document.querySelectorAll('.section-header').forEach(header => {
      const sec = header.dataset.section;
      const body = document.querySelector(`.section-body[data-section-body="${sec}"]`);
      if (!body) return;
      
      // 既存のリスナーを削除（複数登録を防ぐ）
      const newHeader = header.cloneNode(true);
      header.parentNode.replaceChild(newHeader, header);
      header = newHeader;
      
      const expanded = (saved[sec] !== undefined) ? !!saved[sec] : true;
      if (expanded) {
        header.classList.add('active');
        body.classList.add('active');
      } else {
        header.classList.remove('active');
        body.classList.remove('active');
      }
      
      // クリックイベントを処理（子要素がクリックされても反応）
      header.addEventListener('click', (e) => {
        // selectクリックは無視（言語選択に干渉しないため）
        if (e.target.tagName === 'SELECT') {
          e.stopPropagation();
          return;
        }
        
        const cur = header.classList.contains('active');
        const next = !cur;
        if (next) {
          header.classList.add('active');
          body.classList.add('active');
        } else {
          header.classList.remove('active');
          body.classList.remove('active');
        }
        const s = JSON.parse(localStorage.getItem('tv_sections') || '{}');
        s[sec] = next;
        localStorage.setItem('tv_sections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSectionToggles error', e);
  }
}

// Wire subsection toggles (for saved rules and rule editor)
function wireSubsectionToggles() {
  try {
    const saved = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
    // Handle both savedRules and ruleEditor subsections
    ['savedRules', 'ruleEditor'].forEach(subsec => {
      const header = document.querySelector(`.subsection-header[data-subsection="${subsec}"]`);
      if (!header) return;
      const body = document.querySelector(`.subsection-body[data-subsection-body="${subsec}"]`);
      if (!body) return;
      const expanded = (saved[subsec] !== undefined) ? !!saved[subsec] : true;
      if (expanded) {
        header.classList.add('active');
        body.classList.add('active');
      } else {
        header.classList.remove('active');
        body.classList.remove('active');
      }
      header.addEventListener('click', () => {
        const cur = header.classList.contains('active');
        const next = !cur;
        if (next) {
          header.classList.add('active');
          body.classList.add('active');
        } else {
          header.classList.remove('active');
          body.classList.remove('active');
        }
        const s = JSON.parse(localStorage.getItem('tv_subsections') || '{}');
        s[subsec] = next;
        localStorage.setItem('tv_subsections', JSON.stringify(s));
      });
    });
  } catch (e) {
    console.log('wireSubsectionToggles error', e);
  }
}

// Populate the rule scope select (通貨選択) with available currencies
function populateRuleScopeSelect(availableCurrencies) {
  try {
    const sel = document.getElementById('ruleScope');
    if (!sel) return;
    const cur = sel.value;
    // Always keep the default '全選択' option
    sel.innerHTML = '';
    const optAll = document.createElement('option'); optAll.value = ''; optAll.textContent = '全選択'; sel.appendChild(optAll);
    (availableCurrencies || []).forEach(sym => {
      const o = document.createElement('option'); o.value = sym; o.textContent = sym; sel.appendChild(o);
    });
    // restore previous selection if still present
    if (cur && [...sel.options].some(o => o.value === cur)) sel.value = cur;
  } catch (e) { console.log('populateRuleScopeSelect error', e); }
}

// Populate voice select with available voices
function populateVoiceSelect() {
  if (!('speechSynthesis' in window)) {
    console.log('[VOICE] speechSynthesis not supported');
    return;
  }
  
  const select = document.getElementById('voiceSelect');
  if (!select) {
    console.log('[VOICE] voiceSelect element not found');
    return;
  }
  const currentValue = select.value;
  
  // 選択肢をクリア
  select.innerHTML = '';
  
  const voices = speechSynthesis.getVoices();
  console.log('[VOICE] Total voices available:', voices.length);
  
  // 日本語音声をすべてコンソールに出力
  console.log('[VOICE] ========== All Japanese voices ==========');
  const japaneseVoices = voices.filter(v => v.lang.includes('ja') || v.lang.includes('JP'));
  japaneseVoices.forEach((v, idx) => {
    const globalIdx = voices.indexOf(v);
    console.log(`  Index ${globalIdx}: ${v.name}`);
  });
  console.log(`[VOICE] Total Japanese voices: ${japaneseVoices.length}`);
  console.log('[VOICE] =========================================');
  
  const allowedVoices = {
    'Microsoft 七海 Online (Natural) - Japanese (Japan)': '七海［女性］',
    'Microsoft 圭太 Online (Natural) - Japanese (Japan)': '圭太［男性］'
  };
  
  let addedCount = 0;
  voices.forEach(voice => {
    console.log('[VOICE] Checking voice:', voice.name, 'lang:', voice.lang);
    if (voice.lang.startsWith('ja') && allowedVoices[voice.name]) {
      const option = document.createElement('option');
      option.value = voice.name;
      option.textContent = allowedVoices[voice.name];
      select.appendChild(option);
      addedCount++;
      console.log('[VOICE] Added:', allowedVoices[voice.name]);
    }
  });
  
  console.log('[VOICE] Total voices added:', addedCount);
  
  // Restore previous selection if it still exists
  if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
    select.value = currentValue;
  }
}

// Populate chime select with available chime files
async function populateChimeSelect() {
  const select = document.getElementById('chimeSelect');
  if (!select) return;
  const currentValue = select.value;
  
  select.innerHTML = '<option value="">なし</option>';
  
  try {
    const response = await fetch('/api/chime_files');
    if (!response.ok) {
      throw new Error('HTTP ' + response.status);
    }
    const data = await response.json();
    if (data.status === 'success') {
      data.files.forEach(file => {
        const option = document.createElement('option');
        option.value = file;
        option.textContent = file.replace('.mp3', '');
        select.appendChild(option);
      });
    } else {
      throw new Error('Invalid response status');
    }
  } catch (e) {
    console.log('Error fetching chime files:', e);
    // Fallback to static list
    const chimeFiles = [
      'お寺の鐘.mp3',
      'きらきら輝く6.mp3',
      'ほら貝を吹き鳴らす.mp3',
      'ドンドンパフパフ.mp3',
      'ラッパのファンファーレ.mp3',
      'レベルアップ.mp3',
      '放送開始チャイム.mp3',
      '教会の鐘2.mp3',
      '歓声と拍手.mp3',
      '決定ボタンを押す4.mp3',
      '決定ボタンを押す5.mp3',
      '男衆「イエーイ！」.mp3',
      '男衆「イヤッホー！」.mp3',
      '突撃ラッパ.mp3',
      '警報が鳴る.mp3',
      '開演ブザー.mp3'
    ];
    chimeFiles.forEach(file => {
      const option = document.createElement('option');
      option.value = file;
      option.textContent = file.replace('.mp3', '');
      select.appendChild(option);
    });
  }
  
  // Restore previous selection if it still exists
  if (currentValue && [...select.options].some(opt => opt.value === currentValue)) {
    select.value = currentValue;
  }
}

// 初期化: 設定を読み込み、UI を配線
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // IndexedDB を初期化（失敗しても続行）
    try {
      if (typeof initIndexedDB === 'function') {
        await initIndexedDB();
      } else {
        console.warn('[INDEXEDDB] initIndexedDB function not available');
      }
    } catch (e) {
      console.warn('[INDEXEDDB] Initialization failed, continuing without IndexedDB:', e);
      db = null;
    }
    
    // Socket.IO 初期化
    socket = io();
    
    // Socket.IO イベントハンドラー
    socket.on('connect', () => {
      console.log('[SOCKET] Connected:', socket.id);
    });
    
    socket.on('disconnect', () => {
      console.log('[SOCKET] Disconnected');
    });
    
    socket.on('reconnect', () => {
      console.log('[SOCKET] Reconnected');
    });
    
    // リアルタイムデータ更新イベント（複数のイベント名に対応）
    socket.on('update_table', async (data) => {
      console.log('[SOCKET] Received update_table:', data);
      lastWebSocketUpdate = Date.now(); // WebSocket更新時刻を記録
      // テーブル再描画
      await load();
    });
    
    socket.on('current_state_update', async (data) => {
      console.log('[SOCKET] Received current_state_update:', data);
      lastWebSocketUpdate = Date.now(); // WebSocket更新時刻を記録
      // テーブル再描画
      await load();
    });
    
    // 新しい通知をリアルタイムで受信
    socket.on('new_notification', async (notification) => {
      console.log('[SOCKET] Received new_notification:', notification);
      
      // Update timestamp to prevent duplicate processing
      lastNotificationTimestamp = notification.timestamp;
      
      // 通知を即座に再生
      await playNotification(notification);
      
      // 発火履歴に即座に追加(APIを待たずに)
      addNotificationToHistory(notification);
      
      // 通知リストの更新はポーリングに任せるため、setTimeoutを削除
    });
    
    // 市場ステータス更新
    async function updateMarketStatus() {
      try {
        const res = await fetch('/api/market_status');
        const data = await res.json();
        if (data.status === 'success') {
          const marketOpen = data.market_open;
          const statusLight = document.getElementById('marketStatusLight');
          const statusText = document.getElementById('marketStatusText');
          
          if (marketOpen) {
            statusLight.style.background = '#90EE90';  // 緑
            statusText.textContent = '開';
          } else {
            statusLight.style.background = '#FFB6C6';  // 赤ピンク
            statusText.textContent = '休';
          }
        }
      } catch (e) {
        console.log('[MARKET_STATUS] Error:', e);
      }
    }
    
    // 日本時間でリアルタイム時間更新関数
    function updateDateTimeDisplay() {
      const now = new Date();
      // 日本時間（JST）に変換
      const jstTime = new Date(now.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' }));
      
      // 令和年号を計算（2019年が令和元年）
      const wareki = jstTime.getFullYear() - 2018;
      const year = jstTime.getFullYear();
      const month = String(jstTime.getMonth() + 1).padStart(2, '0');
      const day = String(jstTime.getDate()).padStart(2, '0');
      
      // 曜日を取得
      const daysOfWeek = ['日', '月', '火', '水', '木', '金', '土'];
      const dayOfWeek = daysOfWeek[jstTime.getDay()];
      
      const hours = String(jstTime.getHours()).padStart(2, '0');
      const minutes = String(jstTime.getMinutes()).padStart(2, '0');
      const seconds = String(jstTime.getSeconds()).padStart(2, '0');
      
      // HTML要素を更新
      const dateSmall = document.querySelector('.datetime-small');
      const timeLarge = document.querySelector('.datetime-large');
      
      if (dateSmall) {
        dateSmall.textContent = String(year).slice(-2) + '/' + month + '/' + day + ' ' + dayOfWeek;
      }
      if (timeLarge) {
        timeLarge.textContent = hours + ':' + minutes + ':' + seconds;
      }
    }
    
    // 初期表示
    updateDateTimeDisplay();
    // 毎秒更新
    setInterval(updateDateTimeDisplay, 1000);
    
    // 初期更新
    updateMarketStatus();
    // 定期更新（30秒ごと）
    setInterval(updateMarketStatus, 30000);
    
    loadSettings(); 
    wireSettings(); 
    wireSectionToggles(); 
    wireSubsectionToggles();
    
    // 子ウィンドウ（settings_window）からのメッセージを受信
    window.addEventListener('message', async (event) => {
      if (event.data && event.data.type === 'settings_action') {
        console.log('[DASHBOARD] Received settings message:', event.data);
        const { action, data } = event.data;
        
        switch (action) {
          case 'mode_changed':
            applyMode(data.mode);
            await load();
            break;
          case 'font_size_changed':
            applyFontSize(data.size);
            await load();
            break;
          case 'time_format_changed':
            await load();
            break;
          case 'enable_5m_changed':
            // 設定はlocalStorageに保存済み
            break;
          case 'columns_changed':
            applyColumnVisibility();
            await load();
            break;
          case 'rows_changed':
            applyRowVisibility();
            await load();
            break;
          case 'voice_volume_changed':
          case 'voice_rate_changed':
            // 音声設定はlocalStorageから取得されるので特別な処理不要
            break;
          case 'currency_filter_changed':
            applyCurrencyFilter();
            await load();
            break;
          case 'rule_saved':
          case 'rule_deleted':
          case 'rule_toggled':
          case 'rules_reordered':
            // ルール変更の場合はルールを再読み込み
            await loadRules();
            break;
        }
      } else if (event.data && event.data.type === 'request_currencies') {
        // 子ウィンドウが通貨リストを要求した場合
        if (settingsWindowRef && !settingsWindowRef.closed && availableCurrenciesGlobal.length > 0) {
          settingsWindowRef.postMessage({
            type: 'currencies_update',
            currencies: availableCurrenciesGlobal
          }, '*');
        }
      } else if (event.data && event.data.type === 'play_voice') {
        // タイマーウィンドウからの音声再生リクエスト
        console.log('[DASHBOARD] Received play_voice request:', event.data);
        const { text, voiceIndex } = event.data;
        
        if (text && voiceIndex !== undefined) {
          // 既存の音声を停止
          if (speechSynthesis.speaking) {
            console.log('[DASHBOARD] Canceling existing speech');
            speechSynthesis.cancel();
            // キャンセル後は少し長めに待機
            setTimeout(() => processTimerVoice(), 200);
            return;
          }
          
          processTimerVoice();
          
          function processTimerVoice() {
            // 音声リストを取得（キャッシュ優先）
            let voices = cachedVoices.length > 0 ? cachedVoices : speechSynthesis.getVoices();
            
            // 音声リストが空の場合は再取得を試みる
            if (voices.length === 0) {
              console.log('[DASHBOARD] Voices not loaded, triggering load...');
              voices = speechSynthesis.getVoices();
              if (voices.length > 0) {
                cachedVoices = voices;
              } else {
                // 音声がまだ読み込まれていない場合は再試行
                console.log('[DASHBOARD] Voices still not available, retrying in 300ms...');
                setTimeout(processTimerVoice, 300);
                return;
              }
            }
            
            console.log('[DASHBOARD] Total voices available:', voices.length);
            console.log('[DASHBOARD] Requested voice index:', voiceIndex);
            
            if (voices[voiceIndex]) {
              console.log('[DASHBOARD] Selected voice:', voices[voiceIndex].name);
              
              // 音声設定を構築
              const voiceSettings = {
                voice_name: voices[voiceIndex].name
              };
              
              // 音声合成エンジンの初期化を確実にするため待機時間を延長
              setTimeout(() => {
                console.log('[DASHBOARD] Starting timer speech synthesis with voice:', voiceSettings.voice_name);
                playVoiceMessage(text, voiceSettings, null, null, 0);
              }, 250); // 100ms → 250ms に延長
            } else {
              console.error('[DASHBOARD] Voice index out of range:', voiceIndex, 'Available:', voices.length);
              // フォールバック: 利用可能な音声がある場合は最初の音声で再生
              if (voices.length > 0) {
                console.log('[DASHBOARD] Attempting fallback with first available voice');
                const voiceSettings = {
                  voice_name: voices[0].name
                };
                setTimeout(() => {
                  playVoiceMessage(text, voiceSettings, null, null, 0);
                }, 250);
              }
            }
          }
        }
      }
    });
    
    // Calendar language selector and visibility - moved to separate window
    
    // Populate chime select
    await populateChimeSelect();
    
    // Populate voices when available (for browsers that load voices asynchronously)
    if ('speechSynthesis' in window) {
      // 初回実行
      populateVoiceSelect();
      
      // 音声リストが後から読み込まれる場合に備えて
      if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = () => {
          console.log('[VOICE] Voices changed event fired');
          populateVoiceSelect();
        };
      }
      
      // Chrome等では最初のgetVoices()呼び出しで空になることがあるため、
      // 少し待ってから再度実行
      setTimeout(() => {
        console.log('[VOICE] Delayed populate attempt');
        populateVoiceSelect();
      }, 100);
    }

    // 初期読み込みと定期的な更新
    try {
      // 30秒のタイムアウト付きで load() を実行
      const loadPromise = Promise.race([
        load(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Load timeout after 30s')), 30000)
        )
      ]);
      await loadPromise;
    } catch (e) {
      console.error('[INIT] Load failed:', e.message);
      console.log('[INIT] Continuing without initial data...');
    }
    
    scheduleNextUpdate();

    // Rules UI 初期化
    try {
      const rulesPromise = Promise.race([
        loadRules(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('LoadRules timeout after 10s')), 10000)
        )
      ]);
      await rulesPromise;
    } catch (e) {
      console.error('[INIT] LoadRules failed:', e.message);
    }
    
    // すべてのイベントリスナーを設定（ルールUI要素が追加された後に実行）
    try {
      const setupPromise = Promise.race([
        setupAllEventListeners(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Setup timeout after 10s')), 10000)
        )
      ]);
      await setupPromise;
    } catch (e) {
      console.error('[INIT] Setup failed:', e.message);
    }

    // Notification polling initialization (moved from separate DOMContentLoaded listener)
    const REQUIRED_VERSION = '2025-12-05-v3';
    const currentVersion = localStorage.getItem('app_version');
    if (currentVersion === REQUIRED_VERSION && !notificationPollingStarted) {
      notificationPollingStarted = true;
      
      const instanceId = Math.random().toString(36).substr(2, 9);
      console.log('[NOTIFICATIONS] Instance ID: ' + instanceId + ' - Page loaded - Version: ' + REQUIRED_VERSION);
      
      // Function to get current polling interval (in milliseconds)
      // Base interval: 5 minutes (300 seconds) + update delay offset
      const getPollingInterval = () => {
        const delaySecs = parseInt(localStorage.getItem('tv_update_delay') || '10');
        const baseInterval = 300; // 5 minutes in seconds
        const totalSeconds = baseInterval + delaySecs;
        return totalSeconds * 1000; // Convert to milliseconds
      };
      
      // Function to start polling
      const startNotificationPolling = () => {
        if (notificationCheckInterval) {
          console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Clearing existing polling interval ' + notificationCheckInterval);
          clearInterval(notificationCheckInterval);
          notificationCheckInterval = null;
        }

        const intervalMs = getPollingInterval();
        const intervalSecs = intervalMs / 1000;
        const mins = Math.floor(intervalSecs / 60);
        const secs = Math.floor(intervalSecs % 60);
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Starting polling with interval: ' + intervalMs + 'ms (' + mins + 'm ' + secs + 's)');
        checkNotifications(); // Initial check
        notificationCheckInterval = setInterval(checkNotifications, intervalMs);
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Timer ID: ' + notificationCheckInterval);
      };
      
      // Function to stop polling
      const stopNotificationPolling = () => {
        if (notificationCheckInterval) {
          console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Stopping polling');
          clearInterval(notificationCheckInterval);
          notificationCheckInterval = null;
        }
      };
      
      // Function to restart polling with new interval
      const restartNotificationPolling = () => {
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Restarting polling');
        stopNotificationPolling();
        startNotificationPolling();
      };
      
      // Start polling when page is visible
      startNotificationPolling();
      
      // バックグラウンドでも動作を継続（visibilitychange制御を削除）
      // ポーリングと更新は常に動作し続ける
      console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Background mode enabled, polling will continue regardless of visibility');
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        console.log('[NOTIFICATIONS] Instance ' + instanceId + ' - Page unloading, cleanup');
        stopNotificationPolling();
        notificationPollingStarted = false;
      });
    } else if (currentVersion !== REQUIRED_VERSION) {
      console.log('[NOTIFICATIONS] Version mismatch, skipping notification polling');
    }

    // Calendar visibility toggle - moved to separate window

  } catch (err) { console.log('settings init error', err); }
});

// 経過時間変換関数
function formatElapsedTime(datetimeStr, format) {
  if (!datetimeStr || datetimeStr === '-' || datetimeStr === '') return '-';
  
  // format === 'datetime' の場合はそのまま返す
  if (format === 'datetime') return datetimeStr;
  
  console.log('formatElapsedTime called:', datetimeStr, 'format:', format);
  
  // datetimeStr をパースして経過時間（分）を計算
  // 想定形式: "YY/MM/DD/HH:MM" (例: "25/10/31/21:35")
  try {
    const now = new Date();
    const segments = datetimeStr.trim().split('/');
    
    if (segments.length < 4) {
      console.log('Invalid format, expected YY/MM/DD/HH:MM, got:', segments);
      return datetimeStr;
    }
    
    // YY/MM/DD/HH:MM 形式をパース
    const year = 2000 + parseInt(segments[0], 10); // YY を YYYY に変換
    const month = parseInt(segments[1], 10) - 1; // 0-indexed
    const day = parseInt(segments[2], 10);
    
    // 時間部分を処理 (HH:MM)
    const timePart = segments[3]; // "HH:MM"
    const timeSegments = timePart.split(':');
    
    if (timeSegments.length < 2) {
      console.log('Invalid time format:', timePart);
      return datetimeStr;
    }
    
    const hour = parseInt(timeSegments[0], 10);
    const minute = parseInt(timeSegments[1], 10);
    
    const startTime = new Date(year, month, day, hour, minute);
    const elapsedMs = now - startTime;
    const elapsedMinutes = Math.floor(elapsedMs / 60000);
    
    // 5分刻みに丸める
    const roundedElapsedMinutes = Math.floor(elapsedMinutes / 5) * 5;
    
    console.log('Parsed:', { year, month, day, hour, minute, elapsedMinutes, roundedElapsedMinutes });
    
    if (elapsedMinutes < 0) {
      console.log('Negative elapsed time');
      return datetimeStr; // 未来の日時は元の文字列
    }
    
    if (format === 'm') {
      // 分のみ: "7320m"
      return roundedElapsedMinutes + 'm';
    } else if (format === 'hm') {
      // 時/分: "122:00" または "05:00"
      const hours = Math.floor(roundedElapsedMinutes / 60);
      const mins = roundedElapsedMinutes % 60;
      return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    } else if (format === 'dhm') {
      // 日/時/分: "05/02:00"
      const days = Math.floor(roundedElapsedMinutes / 1440);
      const remainMins = roundedElapsedMinutes % 1440;
      const hours = Math.floor(remainMins / 60);
      const mins = remainMins % 60;
      return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    }
    
    return datetimeStr;
  } catch (e) {
    console.error('formatElapsedTime error:', e, 'input:', datetimeStr);
    return datetimeStr;
  }
}

function calculateTrend(cloud) {
  // localStorageからトレンド設定を読み込み
  const configStr = localStorage.getItem('tv_trend_config');
  if (!configStr) {
    // デフォルト設定
    const defaults = {
      '5m': { use_angle: true, angle_threshold: 15, use_thickness: true, thickness_threshold: 3, use_dauten: true },
      '15m': { use_angle: true, angle_threshold: 20, use_thickness: true, thickness_threshold: 5, use_dauten: true },
      '1H': { use_angle: true, angle_threshold: 25, use_thickness: true, thickness_threshold: 8, use_dauten: true },
      '4H': { use_angle: true, angle_threshold: 30, use_thickness: true, thickness_threshold: 10, use_dauten: true }
    };
    const config = defaults[cloud.label] || defaults['5m'];
    return calculateTrendWithConfig(cloud, config);
  }
  
  try {
    const allConfig = JSON.parse(configStr);
    const config = allConfig[cloud.label] || allConfig['5m'];
    return calculateTrendWithConfig(cloud, config);
  } catch (e) {
    console.error('Failed to parse trend config:', e);
    return 'レンジ';
  }
}

function calculateTrendWithConfig(cloud, config) {
  // 各判定条件のチェック
  let angleUp = null;
  let thicknessUp = null;
  let dautenUp = null;
  
  // 角度チェック
  if (config.use_angle) {
    if (cloud.angle !== null && cloud.angle !== undefined) {
      const absAngle = Math.abs(cloud.angle);
      if (absAngle >= config.angle_threshold) {
        angleUp = cloud.angle > 0; // 正の角度 = 上昇
      } else {
        // 閾値を満たしていない場合はレンジ確定
        return 'レンジ';
      }
    } else {
      // データがない場合はレンジ
      return 'レンジ';
    }
  }
  
  // 厚みチェック
  if (config.use_thickness) {
    if (cloud.thickness !== null && cloud.thickness !== undefined) {
      const absThickness = Math.abs(cloud.thickness);
      if (absThickness >= config.thickness_threshold) {
        thicknessUp = cloud.gc === true; // GC = 上昇, DC = 下降
      } else {
        // 閾値を満たしていない場合はレンジ確定
        return 'レンジ';
      }
    } else {
      // データがない場合はレンジ
      return 'レンジ';
    }
  }
  
  // ダウ転チェック
  if (config.use_dauten) {
    if (cloud.dauten) {
      dautenUp = cloud.dauten === 'up';
    } else {
      // データがない場合はレンジ
      return 'レンジ';
    }
  }
  
  // 有効な判定条件を集める
  const conditions = [];
  if (angleUp !== null) conditions.push(angleUp);
  if (thicknessUp !== null) conditions.push(thicknessUp);
  if (dautenUp !== null) conditions.push(dautenUp);
  
  // 条件が1つもない場合はレンジ
  if (conditions.length === 0) return 'レンジ';
  
  // すべての条件が同じ方向を示しているかチェック
  const allUp = conditions.every(c => c === true);
  const allDown = conditions.every(c => c === false);
  
  if (allUp) return '↗上昇';
  if (allDown) return '↘下降';
  return 'レンジ';
}

function calculateTransferTimeDiff(cloud) {
  const dautenTimeStr = cloud.dauten_start_time_str;
  const crossTimeStr = cloud.elapsed_str;
  if (!dautenTimeStr || !crossTimeStr || dautenTimeStr === '-' || crossTimeStr === '-') return { diff: null, sameDirection: false };
  
  const dautenDir = cloud.dauten; // 'up' or 'down'
  const crossDir = cloud.gc; // true or false
  
  // 同方向チェック: dauten 'up' matches gc true (GC), dauten 'down' matches gc false (DC)
  const dautenUp = dautenDir === 'up';
  const crossUp = crossDir === true;
  const sameDirection = dautenUp === crossUp;
  
  if (!sameDirection) return { diff: null, sameDirection: false };
  
  // 時間差計算
  function parseTime(str) {
    if (!str || str === '-') return null;
    const segments = str.split('/');
    if (segments.length < 4) return null;
    const year = 2000 + parseInt(segments[0]);
    const month = parseInt(segments[1]) - 1;
    const day = parseInt(segments[2]);
    const timePart = segments[3];
    let hour = 0, minute = 0;
    if (timePart.includes(':')) {
      const tp = timePart.split(':');
      hour = parseInt(tp[0]);
      minute = parseInt(tp[1]);
    } else {
      hour = parseInt(timePart);
    }
    return new Date(year, month, day, hour, minute);
  }
  
  const dautenTime = parseTime(dautenTimeStr);
  const crossTime = parseTime(crossTimeStr);
  if (!dautenTime || !crossTime) return { diff: null, sameDirection: false };
  
  const diffMs = Math.abs(dautenTime - crossTime);
  const diffMin = Math.floor(diffMs / 60000);
  return { diff: diffMin, sameDirection: true };
}

function formatTimeDiff(diffMin, format) {
  if (diffMin === null) return '-';
  if (format === 'datetime') {
    // 測定開始時間が選択されている場合、時間差を「時:分」形式で表示
    const hours = Math.floor(diffMin / 60);
    const mins = diffMin % 60;
    return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  if (format === 'm') return diffMin + 'm';
  if (format === 'hm') {
    const hours = Math.floor(diffMin / 60);
    const mins = diffMin % 60;
    return String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  if (format === 'dhm') {
    const days = Math.floor(diffMin / 1440);
    const remainMins = diffMin % 1440;
    const hours = Math.floor(remainMins / 60);
    const mins = remainMins % 60;
    return String(days).padStart(2, '0') + '/' + String(hours).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
  }
  return diffMin + 'm';
}

async function load() {
  const update_at = new Date().toISOString();
  console.log('[CLIENT UPDATE START]', update_at);
  console.log('Loading data...');
  try {
    const r = await fetch('/current_states');
    console.log('Response status:', r.status);
    
    if (!r.ok) {
      throw new Error('HTTP ' + r.status);
    }
    
    const data = await r.json();
    console.log('Data received:', data);
    
    if (data.status === 'success' && data.states.length > 0) {
      // 現在のダッシュボードデータを保存（テスト時に使用）
      currentDashboardData = data.states;
      
      // 利用可能な通貨を抽出（TESTERを除外）
      const availableCurrencies = [...new Set(data.states.map(s => s.symbol))].filter(c => c !== 'TESTER');
      // グローバル変数を更新（子ウィンドウ通信用）
      availableCurrenciesGlobal = availableCurrencies;
      // 設定ウィンドウが開いていれば通貨リストを送信
      if (settingsWindowRef && !settingsWindowRef.closed) {
        settingsWindowRef.postMessage({
          type: 'currencies_update',
          currencies: availableCurrencies
        }, '*');
      }
  updateCurrencyFilter(availableCurrencies);
  // Populate rule editor scope select with current available currencies
  try { populateRuleScopeSelect(availableCurrencies); } catch (e) { console.log('populateRuleScopeSelect call error', e); }
      
      // 通貨ごとにコンテナを生成
      const container = document.getElementById('dashboards-container');
      
      // 既存の発火履歴を保存
      const existingHistories = {};
      document.querySelectorAll('.currency-fire-history-list').forEach(list => {
        const symbol = list.dataset.symbol;
        if (symbol) {
          existingHistories[symbol] = list.innerHTML;
        }
      });
      
      container.innerHTML = '';
      
      availableCurrencies.forEach(symbol => {
        // 各通貨のセクションを作成
        const section = document.createElement('div');
        section.className = 'currency-section';
        section.dataset.symbol = symbol;
        
        const isVisible = JSON.parse(localStorage.getItem('tv_currencies') || '{}')[symbol] !== false;
        if (!isVisible) {
          section.classList.add('hidden');
        }
        
        // 通貨ごとのテーブルを作成
        const dashboardDiv = document.createElement('div');
        dashboardDiv.className = 'currency-dashboard';
        section.appendChild(dashboardDiv);
        
        // 通貨ごとの発火履歴ウィンドウを作成
        const fireHistoryDiv = document.createElement('div');
        fireHistoryDiv.className = 'currency-fire-history';
        fireHistoryDiv.dataset.symbol = symbol;
        
        const headerDiv = document.createElement('div');
        headerDiv.className = 'currency-fire-history-header';
        
        const titleH3 = document.createElement('h3');
        titleH3.textContent = symbol + '発火履歴';
        
        const buttonsDiv = document.createElement('div');
        buttonsDiv.style.display = 'flex';
        buttonsDiv.style.gap = '8px';
        
        // ソート切り替えボタン（降順/昇順）
        const sortBtn = document.createElement('button');
        sortBtn.textContent = '▼▲';
        sortBtn.dataset.symbol = symbol;
        sortBtn.title = '履歴の並べ替え（降順/昇順）';
        sortBtn.addEventListener('click', () => toggleSortOrder(symbol));
        
        const clearBtn = document.createElement('button');
        clearBtn.textContent = 'クリア';
        clearBtn.dataset.symbol = symbol;
        clearBtn.addEventListener('click', () => clearFireHistory(symbol));
        
        // ルールカウントボタンを追加
        const ruleCountBtn = document.createElement('button');
        ruleCountBtn.id = 'rule-count-btn-' + symbol;
        ruleCountBtn.className = 'rule-count-btn';
        ruleCountBtn.textContent = '0';
        ruleCountBtn.title = 'アクティブなルール数';
        ruleCountBtn.addEventListener('click', () => showRuleDropdown(ruleCountBtn, symbol));
        
        buttonsDiv.appendChild(sortBtn);
        buttonsDiv.appendChild(clearBtn);
        buttonsDiv.appendChild(ruleCountBtn);
        
        headerDiv.appendChild(titleH3);
        headerDiv.appendChild(buttonsDiv);
        fireHistoryDiv.appendChild(headerDiv);
        
        const listDiv = document.createElement('div');
        listDiv.className = 'currency-fire-history-list';
        listDiv.dataset.symbol = symbol;
        
        // 既存の履歴があれば復元、なければデフォルトメッセージ
        if (existingHistories[symbol]) {
          listDiv.innerHTML = existingHistories[symbol];
        } else {
          listDiv.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
        }
        
        fireHistoryDiv.appendChild(listDiv);
        section.appendChild(fireHistoryDiv);
        
        container.appendChild(section);
        
        // テーブルを生成
        renderCurrencyTable(symbol, data.states, dashboardDiv);
      });
      
      // テーブル再描画後に設定を再適用
      try {
        const sz = localStorage.getItem('tv_font_size') || document.getElementById('fontSizeSelect')?.value || '14';
        applyFontSize(sz);
        applyColumnVisibility();
        applyRowVisibility();
      } catch (e) { /* ignore */ }
      
      // 高さ同期を実行
      setTimeout(syncAllFireHistoryHeights, 100);
      
      // ルールカウントボタンを更新（load()でDOMが再生成されるため）
      setTimeout(updateRuleCountButtons, 150);
      
      // ドラッグ&ドロップの初期化
      setTimeout(initCurrencySortable, 200);
    } else {
      document.getElementById('dashboards-container').innerHTML = '<div class="loading">データなし</div>';
    }
  } catch (e) {
    document.getElementById('dashboards-container').innerHTML = '<div class="loading">エラー: ' + e.message + '</div>';
  }
}

// 通貨ごとのテーブルを生成する関数
function renderCurrencyTable(symbol, allStates, container) {
  // 各時間足のデータを取得（複数のtf表記に対応）
  const state5m = allStates.find(x => x.symbol === symbol && (x.tf === '5' || x.tf === '5m' || x.tf === '5M'));
  const state15m = allStates.find(x => x.symbol === symbol && (x.tf === '15' || x.tf === '15m' || x.tf === '15M'));
  const state1h = allStates.find(x => x.symbol === symbol && (x.tf === '60' || x.tf === '1h' || x.tf === '1H'));
  const state4h = allStates.find(x => x.symbol === symbol && (x.tf === '240' || x.tf === '4h' || x.tf === '4H'));
  
  // いずれかのデータが存在すれば表示可能
  if (!state5m && !state15m && !state1h && !state4h) {
    container.innerHTML = '<div class="loading">データがありません</div>';
    return;
  }
  
  // 代表データ（更新時刻とprice用）
  const mainState = state5m || state15m || state1h || state4h;
  
  // 更新時刻を計算（JST）
  const updateTime = mainState.timestamp ? new Date(mainState.timestamp).toLocaleString('ja-JP', {timeZone: 'Asia/Tokyo', hour12: false}).split(' ')[1] : 'N/A';
  
  // 各時間足のデータを統合
  // 5m のクラウド配列をベースにするが、なければ各時間足の専用データから構築
  let baseClouds = state5m?.clouds || [];
  
  // 5m足のclouds配列に各時間足のデータがない場合、専用データから追加
  const timeframes = [
    { label: '5m', state: state5m },
    { label: '15m', state: state15m },
    { label: '1H', state: state1h },
    { label: '4H', state: state4h }
  ];
  
  const mergedClouds = [];
  
  timeframes.forEach(({ label, state }) => {
    // baseCloudsにこの時間足のデータがあるか確認
    let cloud = baseClouds.find(c => c.label === label);
    
    if (!cloud && state && state.clouds && state.clouds.length > 0) {
      // baseCloudsにないが専用データがある場合、専用データから作成
      cloud = { ...state.clouds[0], label: label };
    }
    
    if (cloud) {
      const merged = { ...cloud };
      
      // 専用データがあれば、そちらを優先してマージ
      // clouds[0]からデータを取得（bos_countは数値、daytrade.bosは文字列なので注意）
      if (label === '5m' && state5m && state5m.clouds?.[0]) {
        merged.dauten = state5m.clouds[0].dauten ?? cloud.dauten;
        merged.bos_count = state5m.clouds[0].bos_count ?? cloud.bos_count;
        merged.dauten_start_time_str = state5m.clouds[0].dauten_start_time_str ?? cloud.dauten_start_time_str;
        merged.elapsed_str = state5m.clouds[0].elapsed_str ?? cloud.elapsed_str;
      } else if (label === '15m' && state15m && state15m.clouds?.[0]) {
        merged.dauten = state15m.clouds[0].dauten ?? cloud.dauten;
        merged.bos_count = state15m.clouds[0].bos_count ?? cloud.bos_count;
        merged.dauten_start_time_str = state15m.clouds[0].dauten_start_time_str ?? cloud.dauten_start_time_str;
        merged.elapsed_str = state15m.clouds[0].elapsed_str ?? cloud.elapsed_str;
      } else if (label === '1H' && state1h && state1h.clouds?.[0]) {
        merged.dauten = state1h.clouds[0].dauten ?? cloud.dauten;
        merged.bos_count = state1h.clouds[0].bos_count ?? cloud.bos_count;
        merged.dauten_start_time_str = state1h.clouds[0].dauten_start_time_str ?? cloud.dauten_start_time_str;
        merged.elapsed_str = state1h.clouds[0].elapsed_str ?? cloud.elapsed_str;
      } else if (label === '4H' && state4h && state4h.clouds?.[0]) {
        merged.dauten = state4h.clouds[0].dauten ?? cloud.dauten;
        merged.bos_count = state4h.clouds[0].bos_count ?? cloud.bos_count;
        merged.dauten_start_time_str = state4h.clouds[0].dauten_start_time_str ?? cloud.dauten_start_time_str;
        merged.elapsed_str = state4h.clouds[0].elapsed_str ?? cloud.elapsed_str;
      }
      
      mergedClouds.push(merged);
    }
  });
  
  // row_order に従って行を並べ替え（なければデフォルト順序）
  const rowOrder = mainState.row_order || ['5m', '15m', 'price', '1H', '4H'];
  const orderedRows = [];
  
  rowOrder.forEach(label => {
    if (label === 'price') {
      orderedRows.push({ type: 'price', price: mainState.price });
    } else {
      const cloud = mergedClouds.find(c => c.label === label);
      if (cloud) {
        orderedRows.push({ type: 'cloud', ...cloud });
      }
    }
  });
  
  let html = '<div class="table-wrap"><table data-symbol="' + mainState.symbol + '"><tr><th class="drag-handle" colspan="12" style="text-align: center; cursor: grab; color: white;">' + mainState.symbol + ' - ' + mainState.price + '<span style="float: right;">更新 ' + updateTime + '</span></th></tr>';
  html += '<tr><th class="header-black">雲整列</th><th class="header-black">ダウ転</th><th class="header-black">突破数</th><th class="header-black">雲交差</th><th class="header-black">各雲間</th><th class="header-black">価格間</th><th class="header-black">雲角度</th><th class="header-black">雲厚み</th><th class="header-black">ダウ時間</th><th class="header-black">交差時間</th><th class="header-black">時間差</th><th class="header-black">トレンド</th></tr>';

  orderedRows.forEach(row => {
    if (row.type === 'price') {
      html += '<tr class="price-row"><td class="tf-label">価格</td>';
      html += '<td colspan="11"></td></tr>';
    } else {
      const c = row;
      html += '<tr>';
      
      let tfBgColor = '';
      if (c.label === '5m') tfBgColor = '#a9e88c';
      else if (c.label === '15m') tfBgColor = '#fbd0b2';
      else if (c.label === '1H') tfBgColor = '#8dc7fc';
      else if (c.label === '4H') tfBgColor = '#fa8dfe';
      
      if (tfBgColor) {
        html += '<td class="tf-label" style="background:' + tfBgColor + '; color:#000">' + c.label + '</td>';
      } else {
        html += '<td class="tf-label col-cloud-label">' + c.label + '</td>';
      }

      let dautenColor = '';
      if (c.dauten === 'up') dautenColor = '#2962ff';
      else if (c.dauten === 'down') dautenColor = '#f23645';

      let gcColor = '';
      if (c.gc === true) gcColor = '#2962ff';
      else if (c.gc === false) gcColor = '#f23645';

      let bosVal = c.bos_count;

      const toNum = v => (v === null || v === undefined || v === '' ? null : Number(v));
      const prev = toNum(c.distance_from_prev);
      const prevColor = (prev !== null ? (prev > 0 ? '#2962ff' : (prev < 0 ? '#f23645' : '')) : '');
      const dp = toNum(c.distance_from_price);
      const dpColor = (dp !== null ? (dp > 0 ? '#2962ff' : (dp < 0 ? '#f23645' : '')) : '');
      const ang = toNum(c.angle);
      const angColor = (ang !== null ? (ang > 0 ? '#2962ff' : (ang < 0 ? '#f23645' : '')) : '');
      const th = toNum(c.thickness);
      const thColor = (th !== null ? (th > 0 ? '#2962ff' : (th < 0 ? '#f23645' : '')) : '');

      if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';
      else html += '<td>' + (c.dauten === 'up' ? '▲Dow' : (c.dauten === 'down' ? '▼Dow' : '-')) + '</td>';

      const displayBos = (bosVal === null || bosVal === undefined || bosVal === '' ? '-' : bosVal);
      if (dautenColor) {
        html += '<td style="background:' + dautenColor + '; color:#fff">' + displayBos + '</td>';
      } else {
        html += '<td>' + displayBos + '</td>';
      }

      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (c.gc ? '▲GC' : '▼DC') + '</td>';
      else html += '<td>' + (c.gc ? '▲GC' : '▼DC') + '</td>';

      if (prevColor) html += '<td style="background:' + prevColor + '; color:#fff">' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (prev !== null ? prev.toFixed(1) : '-') + '</td>';

      if (dpColor) html += '<td style="background:' + dpColor + '; color:#fff">' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (dp !== null ? dp.toFixed(1) : '-') + '</td>';

      if (angColor) html += '<td style="background:' + angColor + '; color:#fff">' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';
      else html += '<td>' + (ang !== null ? ang.toFixed(1) + '°' : '-') + '</td>';

      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + (th !== null ? th.toFixed(1) : '-') + '</td>';
      else html += '<td>' + (th !== null ? th.toFixed(1) : '-') + '</td>';

      const timeFormat = localStorage.getItem('tv_time_format') || 'datetime';
      
      const dautenTimeFormatted = formatElapsedTime(c.dauten_start_time_str || '-', timeFormat);
      if (dautenColor) html += '<td style="background:' + dautenColor + '; color:#fff">' + dautenTimeFormatted + '</td>';
      else html += '<td>' + dautenTimeFormatted + '</td>';

      const elapsedTimeFormatted = formatElapsedTime(c.elapsed_str || '-', timeFormat);
      if (gcColor) html += '<td style="background:' + gcColor + '; color:#fff">' + elapsedTimeFormatted + '</td>';
      else html += '<td>' + elapsedTimeFormatted + '</td>';

      const timeDiffResult = calculateTransferTimeDiff(c);
      const timeDiffFormatted = formatTimeDiff(timeDiffResult.diff, timeFormat);
      let timeDiffBg = '';
      let timeDiffColor = '#fff';
      if (timeDiffResult.sameDirection) {
        timeDiffBg = dautenColor || '';
      } else {
        timeDiffBg = 'rgba(128,128,128,0.5)';
      }
      if (timeDiffBg) {
        html += '<td style="background:' + timeDiffBg + '; color:' + timeDiffColor + '">' + timeDiffFormatted + '</td>';
      } else {
        html += '<td style="color:' + timeDiffColor + '">' + timeDiffFormatted + '</td>';
      }
      
      // トレンド判定
      const trend = calculateTrend(c);
      if (trend === '↗上昇') {
        html += '<td style="background:#06b7f9; color:#fff; font-weight:bold">↗上昇</td></tr>';
      } else if (trend === '↘下降') {
        html += '<td style="background:#ff57ea; color:#fff; font-weight:bold">↘下降</td></tr>';
      } else {
        html += '<td style="background:#95a5a6; color:#fff">レンジ</td></tr>';
      }
    }
  });

  html += '</table></div>';
  container.innerHTML = html;
}

// 初期読み込みと定期的な更新
let updateTimer = null;

function computeNextUpdateTimeout(delaySeconds) {
  const now = new Date();
  const next = new Date(now);

  // Reset seconds and milliseconds first
  next.setSeconds(0, 0);

  // Align minutes to the next 5-minute boundary
  const minute = next.getMinutes();
  const remainder = minute % 5;
  if (remainder !== 0) {
    next.setMinutes(minute + (5 - remainder));
  } else {
    // If already on a 5-minute boundary, move to the next one
    next.setMinutes(minute + 5);
  }

  // Add delay seconds to the 5-minute boundary
  next.setSeconds(delaySeconds);

  // If the calculated time is in the past, move to the next 5-minute boundary
  if (next <= now) {
    next.setMinutes(next.getMinutes() + 5);
  }

  return { timeout: next.getTime() - now.getTime(), target: next };
}

async function executeScheduledUpdate() {
  console.log(`[TIMER] Executing scheduled update at ${new Date().toLocaleString('ja-JP', { hour12: false })}`);
  try {
    await load();
    console.log(`[TIMER] Update completed successfully`);
  } catch (error) {
    console.error(`[TIMER] Update failed:`, error);
  }
}

function scheduleNextUpdate() {
  if (updateTimer) {
    clearTimeout(updateTimer);
    updateTimer = null;
  }

  // 5分毎更新が無効の場合、タイマーを設定しない
  const enable5mUpdate = localStorage.getItem('tv_enable_5m_update') !== 'false';
  if (!enable5mUpdate) {
    console.log('[TIMER] 5分毎更新が無効のため、定期更新をスキップします');
    return;
  }

  // WebSocket最終更新から5分30秒以上経過していない場合、定期更新をスキップ
  const now = Date.now();
  const timeSinceLastUpdate = now - lastWebSocketUpdate;
  const fiveMinutesThirtySeconds = (5 * 60 + 30) * 1000; // 5分30秒 = 330秒 = 330000ミリ秒

  if (timeSinceLastUpdate < fiveMinutesThirtySeconds) {
    const remainingSeconds = Math.ceil((fiveMinutesThirtySeconds - timeSinceLastUpdate) / 1000);
    const remainingMinutes = Math.floor(remainingSeconds / 60);
    const remainingSecs = remainingSeconds % 60;
    console.log(`[TIMER] WebSocket更新から${remainingMinutes}分${remainingSecs}秒以内のため、定期更新をスキップします`);
    // 次回のチェックは5分30秒後にスケジュール
    updateTimer = setTimeout(() => {
      scheduleNextUpdate();
    }, fiveMinutesThirtySeconds - timeSinceLastUpdate);
    return;
  }

  const delay = parseInt(localStorage.getItem('tv_update_delay') || '10', 10);
  const { timeout, target } = computeNextUpdateTimeout(delay);

  const secondsUntil = Math.round(timeout / 1000);
  const targetStr = target.toLocaleString('ja-JP', { hour12: false });
  console.log(`[TIMER] WebSocket更新から5分以上経過したため、定期更新を実行します。次回: ${targetStr} (あと${secondsUntil}s)`);

  updateTimer = setTimeout(async () => {
    await executeScheduledUpdate();
    scheduleNextUpdate(); // Reschedule after execution
  }, timeout);
}

// 初期読み込みと定期的な更新をメインリスナーに統合
// loadRules()と他の初期化は最初のDOMContentLoadedリスナーで実行される

// --- Rules UI / API ---

// ルールの並び順をサーバーに保存
async function saveRulesOrder() {
  try {
    const ul = document.getElementById('rulesList');
    const items = ul.querySelectorAll('li[data-rule-id]');
    const order = Array.from(items).map(li => li.dataset.ruleId);
    
    const res = await fetch('/rules/reorder', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ order: order })
    });
    const j = await res.json();
    if (j.status !== 'success') {
      console.error('Failed to save rules order:', j.msg);
    }
  } catch (e) {
    console.error('saveRulesOrder error:', e);
  }
}

async function loadRules() {
  try {
    const r = await fetch('/rules');
    if (!r.ok) return;
    const data = await r.json();
    if (data.status !== 'success') return;
    allRules = data.rules || []; // グローバル変数に保存
    renderRulesList(allRules);
    updateRuleCountButtons(); // ルールカウントボタンを更新
    // populate scope select with available symbols (currencies)
    const scopeSelect = document.getElementById('ruleScope');
    const avail = [...new Set((allRules).map(x => x.scope && x.scope.symbol).filter(Boolean))];
    // keep existing options but add any new
    avail.forEach(s => {
      if (![...scopeSelect.options].some(o => o.value === s)) {
        const opt = document.createElement('option'); opt.value = s; opt.textContent = s; scopeSelect.appendChild(opt);
      }
    });
    // 「有効のみ」トグルのイベントを設定（初回のみ）
    const showEnabledOnlyToggle = document.getElementById('showEnabledOnly');
    if (showEnabledOnlyToggle && !showEnabledOnlyToggle.dataset.listenerAdded) {
      showEnabledOnlyToggle.dataset.listenerAdded = 'true';
      showEnabledOnlyToggle.addEventListener('change', () => {
        renderRulesList(allRules);
      });
    }
  } catch (e) { console.log('loadRules error', e); }
}

// ルールカウントボタンを更新する関数
function updateRuleCountButtons() {
  console.log('updateRuleCountButtons called, allRules:', allRules.length);
  // 各通貨の発火履歴ヘッダーのボタンを更新
  document.querySelectorAll('.currency-fire-history').forEach(historyDiv => {
    const symbol = historyDiv.dataset.symbol;
    const ruleCountBtn = document.getElementById('rule-count-btn-' + symbol);
    if (!ruleCountBtn) {
      console.log('ruleCountBtn not found for symbol:', symbol);
      return;
    }

    // この通貨に適用される有効なルールをカウント
    const activeRules = allRules.filter(r => {
      const isEnabled = r.enabled !== false;
      const scope = r.scope || {};
      const ruleSymbol = scope.symbol;
      // scope.symbolが空またはundefinedの場合は全通貨対象、それ以外は一致する場合のみ
      const matches = isEnabled && (!ruleSymbol || ruleSymbol === '' || ruleSymbol === symbol);
      console.log('Rule:', r.name, 'enabled:', isEnabled, 'scope:', scope, 'ruleSymbol:', ruleSymbol, 'symbol:', symbol, 'matches:', matches);
      return matches;
    });

    console.log('Active rules for', symbol, ':', activeRules.length);
    ruleCountBtn.textContent = activeRules.length.toString();
  });
}

// ルールドロップダウンを表示する関数
function showRuleDropdown(button, symbol) {
  // 既存のドロップダウンを削除
  document.querySelectorAll('.rule-dropdown').forEach(d => d.remove());
  
  // この通貨のアクティブなルールを取得
  const activeRules = allRules.filter(r => {
    const isEnabled = r.enabled !== false;
    const scope = r.scope || {};
    const ruleSymbol = scope.symbol;
    // scope.symbolが空またはundefinedの場合は全通貨対象、それ以外は一致する場合のみ
    return isEnabled && (!ruleSymbol || ruleSymbol === '' || ruleSymbol === symbol);
  });
  
  // ドロップダウンを作成
  const dropdown = document.createElement('div');
  dropdown.className = 'rule-dropdown';
  dropdown.style.position = 'absolute';
  dropdown.style.background = 'rgba(0, 0, 0, 0.9)';
  dropdown.style.border = '1px solid rgba(255, 255, 255, 0.3)';
  dropdown.style.borderRadius = '6px';
  dropdown.style.padding = '8px';
  dropdown.style.zIndex = '1000';
  dropdown.style.maxHeight = '200px';
  dropdown.style.overflowY = 'auto';
  dropdown.style.minWidth = '150px';
  
  if (activeRules.length === 0) {
    const item = document.createElement('div');
    item.textContent = 'アクティブなルールなし';
    item.style.color = 'rgba(255, 255, 255, 0.7)';
    item.style.padding = '4px 0';
    dropdown.appendChild(item);
  } else {
    activeRules.forEach(rule => {
      const item = document.createElement('div');
      item.textContent = rule.name || rule.id;
      item.style.color = '#fff';
      item.style.padding = '4px 0';
      item.style.cursor = 'pointer';
      item.addEventListener('mouseenter', () => item.style.background = 'rgba(255, 255, 255, 0.1)');
      item.addEventListener('mouseleave', () => item.style.background = 'transparent');
      dropdown.appendChild(item);
    });
  }
  
  // ボタンの位置を取得
  const rect = button.getBoundingClientRect();
  dropdown.style.left = rect.left + 'px';
  dropdown.style.top = (rect.bottom + 2) + 'px';
  
  // ドロップダウンを追加
  document.body.appendChild(dropdown);
  
  // クリックで閉じる
  const closeDropdown = (e) => {
    if (!dropdown.contains(e.target) && e.target !== button) {
      dropdown.remove();
      document.removeEventListener('click', closeDropdown);
    }
  };
  setTimeout(() => document.addEventListener('click', closeDropdown), 0);
}

function renderRulesList(rules) {
  // ソートはサーバー側で行うため、ここでは順序を変更しない
  // sort_orderの順に表示（サーバーからの順序をそのまま使用）
  
  const ul = document.getElementById('rulesList'); ul.innerHTML = '';
  const showEnabledOnly = document.getElementById('showEnabledOnly')?.checked || false;
  
  // ドラッグ中フラグ（実際に移動が行われたかを追跡）
  let dragMoved = false;
  
  // 有効のみフィルター
  const filteredRules = showEnabledOnly ? rules.filter(r => r.enabled !== false) : rules;
  
  filteredRules.forEach((rule, index) => {
    const li = document.createElement('li'); 
    li.style.padding = '6px 4px'; 
    li.style.borderBottom = '1px solid rgba(255,255,255,0.04)';
    li.style.display = 'flex'; 
    li.style.alignItems = 'center'; 
    li.style.justifyContent = 'space-between';
    li.dataset.ruleId = rule.id; // ドラッグ用にIDを保存
    li.draggable = true; // ドラッグ可能にする
    li.style.cursor = 'grab';
    
    // ドラッグ&ドロップイベント
    li.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', rule.id);
      li.style.opacity = '0.5';
      li.classList.add('dragging');
      dragMoved = false; // ドラッグ開始時にリセット
    });
    
    li.addEventListener('dragend', async () => {
      li.style.opacity = '1';
      li.classList.remove('dragging');
      // 実際に移動が行われた場合のみ順序を保存
      if (dragMoved) {
        await saveRulesOrder();
        dragMoved = false;
      }
    });
    
    li.addEventListener('dragover', (e) => {
      e.preventDefault();
      const draggingItem = document.querySelector('.dragging');
      if (draggingItem && draggingItem !== li) {
        dragMoved = true; // 実際に移動が行われた
        const rect = li.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        if (e.clientY < midY) {
          li.parentNode.insertBefore(draggingItem, li);
        } else {
          li.parentNode.insertBefore(draggingItem, li.nextSibling);
        }
      }
    });
    
    const left = document.createElement('div'); left.style.display = 'flex'; left.style.alignItems = 'center'; left.style.gap = '8px';
    const btns = document.createElement('div'); btns.style.display = 'flex'; btns.style.gap = '6px'; btns.style.alignItems = 'center';
    
    // ルール名（クリックで編集）
    const title = document.createElement('div'); 
    title.textContent = rule.name || rule.id; 
    title.style.fontWeight = '600';
    title.style.cursor = 'pointer';
    title.title = 'クリックして編集';
    title.addEventListener('click', () => openRuleEditor(rule));
    title.addEventListener('mouseenter', () => { title.style.textDecoration = 'underline'; });
    title.addEventListener('mouseleave', () => { title.style.textDecoration = 'none'; });
    
    // 有効/無効スライドトグル
    const isEnabled = rule.enabled !== false; // デフォルトは有効
    const toggleLabel = document.createElement('label');
    toggleLabel.style.display = 'flex';
    toggleLabel.style.alignItems = 'center';
    toggleLabel.style.cursor = 'pointer';
    
    const toggle = document.createElement('input');
    toggle.type = 'checkbox';
    toggle.className = 'rule-toggle-slider';
    toggle.checked = isEnabled;
    toggle.addEventListener('change', async () => {
      try {
        const newEnabled = toggle.checked;
        const updatedRule = { ...rule, enabled: newEnabled };
        const res = await fetch('/rules', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(updatedRule) });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('更新に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('toggle error', e); alert('トグルエラー: ' + e.message); }
    });
    toggleLabel.appendChild(toggle);
    
    // 複製ボタン
    const dup = document.createElement('button'); dup.textContent = '複製'; dup.style.padding = '4px 8px'; dup.className = 'rule-btn';
    dup.addEventListener('click', async () => {
      await duplicateRule(rule);
    });
    
    const del = document.createElement('button'); del.textContent = '削除'; del.style.padding = '4px 8px'; del.className = 'rule-btn';
    del.addEventListener('click', async () => {
      if (!confirm('ルールを削除しますか?')) return;
      try {
        const res = await fetch('/rules/' + encodeURIComponent(rule.id), { method: 'DELETE' });
        const j = await res.json();
        if (j.status === 'success') {
          await loadRules();
        } else {
          alert('削除に失敗しました: ' + (j.msg || JSON.stringify(j)));
        }
      } catch (e) { console.log('delete error', e); alert('削除エラー: ' + e.message); }
    });
    
    // レイアウト: ルール名 → スライドトグル → 複製ボタン → 削除ボタン
    left.appendChild(title);
    btns.appendChild(toggleLabel); btns.appendChild(dup); btns.appendChild(del);
    
    // 無効な場合は薄く表示
    title.style.opacity = isEnabled ? '1' : '0.5';
    btns.style.opacity = isEnabled ? '1' : '0.7';
    li.appendChild(left);
    li.appendChild(btns);
    ul.appendChild(li);
  });
  
  // ルールリスト更新後にボタンを更新
  updateRuleCountButtons();
}

// ルール複製機能
function generateUniqueName(originalName) {
  let counter = 1;
  let newName = originalName + '_' + counter;
  while (allRules.some(r => r.name === newName)) {
    counter++;
    newName = originalName + '_' + counter;
  }
  return newName;
}

async function duplicateRule(originalRule) {
  try {
    // 新しいルールを作成（ディープコピー）
    const newRule = JSON.parse(JSON.stringify(originalRule));
    
    // 新しいID生成
    newRule.id = 'rule_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    
    // 新しい名前生成（_1, _2...）
    newRule.name = generateUniqueName(originalRule.name || originalRule.id);
    
    // 有効状態を維持
    newRule.enabled = true;
    
    // サーバーに保存
    const res = await fetch('/rules', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(newRule)
    });
    
    const j = await res.json();
    
    if (j.status === 'success') {
      await loadRules();
    } else {
      alert('複製に失敗しました: ' + (j.msg || JSON.stringify(j)));
    }
  } catch (e) {
    console.log('duplicate error', e);
    alert('複製エラー: ' + e.message);
  }
}

function openRuleEditor(rule) {
  // populate editor fields
  console.log('[DEBUG] Editing rule:', JSON.stringify(rule, null, 2));
  document.getElementById('ruleName').value = rule.name || '';
  const scopeSel = document.getElementById('ruleScope');
  if (rule.scope && rule.scope.symbol) { scopeSel.value = rule.scope.symbol; }
  else { scopeSel.value = ''; }
  // clear conditions
  const condCont = document.getElementById('conditionsContainer'); condCont.innerHTML = '';
  const conds = (rule.rule && rule.rule.conditions) || [];
  const align = rule.rule && rule.rule.alignment;
  const hasAlignment = align && align.tfs && align.tfs.length >= 2;
  
  // 雲整列条件が2つ以上ある場合は、条件行を自動追加しない
  if (conds.length === 0 && !hasAlignment) addConditionRow();
  conds.forEach(c => {
    const row = createConditionRow(c);
    condCont.appendChild(row);
  });
    // populate alignment UI if present
  try {
    const align = rule.rule && rule.rule.alignment;
    if (align) {
      // clear all
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      (align.tfs || []).forEach(tf => {
        const el = document.querySelector('.align-tf[data-tf="' + tf + '"]');
        if(el) el.checked = true;
      });
      if (align.missing) document.getElementById('alignMissing').value = align.missing;
    } else {
      // reset to defaults
      document.querySelectorAll('.align-tf').forEach(cb=> cb.checked = false);
      document.getElementById('alignMissing').value = 'ignore';
    }
  } catch(e) { /* ignore */ }
  
  // populate voice settings
  const voice = rule.rule && rule.rule.voice;
  const isDirectionBased = voice && (voice.message_up !== undefined || voice.message_down !== undefined);
  document.getElementById('voiceDirectionBased').checked = isDirectionBased;
  document.getElementById('directionMessages').style.display = isDirectionBased ? 'flex' : 'none';
  document.getElementById('voiceMessagePosition').value = (voice && voice.message_position) || 'suffix';
  
  // Always populate common message if present
  document.getElementById('voiceMessage').value = (voice && voice.message) || '';
  
  // Populate direction-based messages if present
  if (isDirectionBased) {
    document.getElementById('voiceMessageUp').value = (voice && voice.message_up) || '';
    document.getElementById('voiceMessageDown').value = (voice && voice.message_down) || '';
  } else {
    document.getElementById('voiceMessageUp').value = '';
    document.getElementById('voiceMessageDown').value = '';
  }
  
  document.getElementById('voiceSelect').value = (voice && voice.voice_name) || '';
  
  // Populate chime settings
  document.getElementById('playChimeFirst').checked = !!(voice && voice.chime_file);
  document.getElementById('chimeSelect').value = (voice && voice.chime_file) || '';
  
  // Populate symbol insert setting
  document.getElementById('insertSymbol').checked = !!(voice && voice.insert_symbol);
  document.getElementById('symbolInsertPosition').value = (voice && voice.symbol_insert_position) || 'prefix';
  
  // store editing id on save button
  document.getElementById('saveRuleBtn').dataset.editing = rule.id;
}

// --- 雲整列: helper ---
function getAlignmentSettingsFromUI(){
  const tfs = Array.from(document.querySelectorAll('.align-tf')).filter(cb=>cb.checked).map(cb=>cb.dataset.tf);
  const missing = document.getElementById('alignMissing').value; // 'ignore' or 'fail'
  return { tfs, missing };
}

function validateAlignmentForSave(){
  const s = getAlignmentSettingsFromUI();
  const errEl = document.getElementById('alignError'); errEl.style.display = 'none'; errEl.textContent = '';
  if(s.tfs.length === 0){
    // No TFs selected, that's fine - alignment is optional
    return {ok:true, msg:'no_alignment_selected'};
  }
  if(s.tfs.length === 1){
    errEl.style.display='block'; errEl.textContent='エラー: 判定対象の時間は 2 個以上選択してください';
    return {ok:false, msg:'need_2_tfs'};
  }
  return {ok:true, msg:'ok'};
}

// wire align checkbox changes to keep UI consistent
// これらのイベントリスナーは最初のDOMContentLoadedリスナーで設定される
// (後で統合する必要があります)

function createConditionRow(c) {
  const div = document.createElement('div'); div.className = 'cond-row'; div.style.display='flex'; div.style.gap='6px'; div.style.alignItems='center';
  const tf = document.createElement('select'); tf.className='cond-tf'; tf.style.padding='6px'; tf.style.borderRadius='6px'; tf.style.background='rgba(15,27,65,0.7)'; tf.style.color='inherit'; tf.style.border='1px solid rgba(255,255,255,0.12)'; tf.innerHTML = '<option value="5m">5m</option><option value="15m">15m</option><option value="1H">1H</option><option value="4H">4H</option>';
  const field = document.createElement('select'); field.className='cond-field'; field.style.padding='6px'; field.style.borderRadius='6px'; field.style.background='rgba(15,27,65,0.7)'; field.style.color='inherit'; field.style.border='1px solid rgba(255,255,255,0.12)'; field.innerHTML = '<option value="dauten">ダウ転</option><option value="bos_count">突破数</option><option value="gc">雲交差</option><option value="distance_from_prev">各雲間</option><option value="distance_from_price">価格間</option><option value="angle">雲角度</option><option value="thickness">雲厚み</option><option value="transfer_time_diff">転換時間差</option>';
  const val = document.createElement('input'); val.className='cond-value'; val.placeholder='値'; val.style.padding='6px'; val.style.borderRadius='6px'; val.style.border='1px solid rgba(255,255,255,0.08)'; val.style.background='transparent'; val.style.color='inherit'; val.style.width='60px';
  const rem = document.createElement('button'); rem.className='removeCond'; rem.textContent='削除'; rem.style.padding='6px 12px';
  rem.addEventListener('click', () => div.remove());
  div.append(tf, field, val, rem);

  // hide/remove val when field is one of the toggle-only types
  function updateCondVisibility() {
    try {
      const hideVal = ['dauten','bos_count','gc','dauten_start_time_str','cross_start_time'];
      
      if (hideVal.includes(field.value)) {
        // remove val from DOM
        if (val.parentNode === div) div.removeChild(val);
      } else {
        // show val for numeric input
        if (val.parentNode !== div) div.insertBefore(val, rem);
        val.style.display = '';
        val.placeholder = '値';
      }
    } catch (e) {
      console.warn('updateCondVisibility error:', e);
    }
  }

  field.addEventListener('change', updateCondVisibility);
  // Set values from loaded rule BEFORE calling initial visibility update
  if (c) {
    tf.value = c.label || tf.value;
    field.value = c.field || field.value;
    val.value = c.value || '';
  }
  // initial visibility (AFTER setting field value so it checks the correct field type)
  updateCondVisibility();
  return div;
}

function addConditionRow() {
  const cont = document.getElementById('conditionsContainer');
  const r = createConditionRow(); cont.appendChild(r);
}

// ルール UI イベントリスナーは DOMContentLoaded リスナーで初期化される

// --- Notifications and Voice Alerts ---
let lastNotificationTimestamp = null;
let notificationCheckInterval = null;
let notificationPollingStarted = false; // Global flag to prevent multiple instances
let isInitialLoad = true; // ページ初回ロード時は通知を再生しない

// 通知を再生する関数(Socket.IOとポーリングの両方で使用)
async function playNotification(notification) {
  if (!notification) return;
  
  console.log('[PLAY_NOTIFICATION] Called with notification:', notification);
  
  // 音声設定を抽出
  const voiceSettings = notification.voice_settings || null;
  const message = notification.message || '';
  const symbol = notification.symbol || '';
  
  console.log('[PLAY_NOTIFICATION] Extracted - message:', message, 'voiceSettings:', voiceSettings, 'symbol:', symbol);
  
  // チャイム音と音声を再生
  playVoiceAlert(message, voiceSettings, symbol);
}

// 単一の通知を発火履歴に追加する関数
function addNotificationToHistory(notification) {
  if (!notification) return;
  
  console.log('[ADD_TO_HISTORY]', notification);
  
  const symbol = notification.symbol || 'UNKNOWN';
  const listEl = document.querySelector(`.currency-fire-history-list[data-symbol="${symbol}"]`);
  
  if (!listEl) {
    console.log('[ADD_TO_HISTORY] List element not found for symbol:', symbol);
    return;
  }
  
  // 既存の「履歴なし」メッセージを削除
  if (listEl.innerHTML.includes('履歴なし')) {
    listEl.innerHTML = '';
  }
  
  // Format timestamp: YY/MM/DD HH:mm
  const dt = new Date(notification.timestamp);
  const year = String(dt.getFullYear()).slice(-2);
  const month = String(dt.getMonth() + 1).padStart(2, '0');
  const day = String(dt.getDate()).padStart(2, '0');
  const hour = String(dt.getHours()).padStart(2, '0');
  const minute = String(dt.getMinutes()).padStart(2, '0');
  const timeStr = year + '/' + month + '/' + day + ' ' + hour + ':' + minute;
  
  // 新しい発火アイテムを作成
  const fireItem = document.createElement('div');
  fireItem.className = 'fire-item';
  fireItem.innerHTML = '<span class="fire-time">' + timeStr + '</span>';
  if (notification.direction) {
    const directionClass = notification.direction === '上昇' ? 'direction-up' : 'direction-down';
    fireItem.innerHTML += '<span class="fire-direction ' + directionClass + '">' + notification.direction + '</span>';
  }
  fireItem.innerHTML += '<span class="fire-name">' + (notification.rule_name || '不明') + '</span>';
  
  // 先頭に挿入(最新が上)
  listEl.insertBefore(fireItem, listEl.firstChild);
  
  // 最大20件に制限
  while (listEl.children.length > 20) {
    listEl.removeChild(listEl.lastChild);
  }
  
  // フォントサイズとレイアウトを適用
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  applyFontSize(savedSize);
  syncAllFireHistoryHeights();
  
  console.log('[ADD_TO_HISTORY] Added notification to history for', symbol);
}

async function checkNotifications() {
  const timestamp = new Date().toISOString();
  const stackTrace = new Error().stack;
  console.log('[NOTIFICATIONS] checkNotifications called at ' + timestamp);
  console.log('[NOTIFICATIONS] Call stack:', stackTrace);
  
  try {
    const res = await fetch('/api/notifications');
    if (!res.ok) return;
    const data = await res.json();
    if (data.status !== 'success') return;
    
    const notifications = data.notifications || [];
    if (notifications.length === 0) return;
    
    // Update fire history display
    updateFireHistory(notifications);
    
    // Get the latest notification
    const latest = notifications[0];
    const latestTimestamp = latest.timestamp;
    
    // 初回ロード時は音声を再生しない
    if (isInitialLoad) {
      console.log('[NOTIFICATIONS] Initial load - setting timestamp without playing sound');
      lastNotificationTimestamp = latestTimestamp;
      isInitialLoad = false;
      return;
    }
    
    // If this is a new notification (different timestamp)
    if (lastNotificationTimestamp !== latestTimestamp) {
      lastNotificationTimestamp = latestTimestamp;
      
      // Play notification with voice settings
      await playNotification(latest);
      
      console.log('[NOTIFICATION]', latest);
    }
  } catch (e) {
    console.log('checkNotifications error', e);
  }
}

function updateFireHistory(notifications) {
  if (notifications.length === 0) {
    // すべての通貨の履歴をクリア
    document.querySelectorAll('.fire-history-list').forEach(listEl => {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
    });
    return;
  }
  
  // 通貨ごとに通知を分類
  const notificationsBySymbol = {};
  notifications.forEach(notif => {
    const symbol = notif.symbol || 'UNKNOWN';
    if (!notificationsBySymbol[symbol]) {
      notificationsBySymbol[symbol] = [];
    }
    notificationsBySymbol[symbol].push(notif);
  });
  
    // 各通貨の発火履歴を更新
  document.querySelectorAll('.currency-fire-history-list').forEach(listEl => {
    const symbol = listEl.dataset.symbol;
    const symbolNotifications = notificationsBySymbol[symbol] || [];
    const displayNotifications = symbolNotifications.slice(0, 20);
    
    if (displayNotifications.length === 0) {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
      return;
    }
    
    let html = '';
    displayNotifications.forEach(notif => {
      // Format timestamp: YY/MM/DD HH:mm
      const dt = new Date(notif.timestamp);
      const year = String(dt.getFullYear()).slice(-2);
      const month = String(dt.getMonth() + 1).padStart(2, '0');
      const day = String(dt.getDate()).padStart(2, '0');
      const hour = String(dt.getHours()).padStart(2, '0');
      const minute = String(dt.getMinutes()).padStart(2, '0');
      const timeStr = year + '/' + month + '/' + day + ' ' + hour + ':' + minute;
      
      html += '<div class="fire-item">';
      html += '<span class="fire-time">' + timeStr + '</span>';
      if (notif.direction) {
        const directionClass = notif.direction === '上昇' ? 'direction-up' : 'direction-down';
        html += '<span class="fire-direction ' + directionClass + '">' + notif.direction + '</span>';
      }
      html += '<span class="fire-name">' + (notif.rule_name || '不明') + '</span>';
      html += '</div>';
    });
    
  });  // Apply current font size to newly created elements
  const savedSize = localStorage.getItem('tv_font_size') || '14';
  applyFontSize(savedSize);
  
  // Sync fire history heights after content update
  syncAllFireHistoryHeights();
}

// ドラッグ&ドロップで通貨の順序を変更
function initCurrencySortable() {
  const container = document.getElementById('dashboards-container');
  if (!container) return;
  
  // 既存のSortableインスタンスがあれば破棄
  if (window.currencySortable) {
    window.currencySortable.destroy();
  }
  
  // ドラッグ可能な通貨セクション全体をソート対象にする
  window.currencySortable = new Sortable(container, {
    handle: '.drag-handle',  // テーブルヘッダーのみドラッグ可能
    animation: 150,
    ghostClass: 'sortable-ghost',
    chosenClass: 'dragging-row',
    onEnd: function(evt) {
      // ドラッグ終了後に順序を保存
      const symbols = [];
      document.querySelectorAll('.currency-section').forEach(section => {
        const symbol = section.dataset.symbol;
        if (symbol) {
          symbols.push(symbol);
        }
      });
      
      console.log('[SORTABLE] New order:', symbols);
      
      // サーバーに保存
      fetch('/api/currency_order', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({symbols: symbols})
      }).then(res => res.json())
        .then(data => {
          if (data.status === 'success') {
            console.log('[SORTABLE] Currency order saved successfully');
          } else {
            console.error('[SORTABLE] Failed to save order:', data.msg);
          }
        })
        .catch(err => console.error('[SORTABLE] Save error:', err));
    }
  });
}

// 全通貨の発火履歴ウィンドウの高さを同期する
function syncAllFireHistoryHeights() {
  document.querySelectorAll('.currency-section').forEach(section => {
    const dashboard = section.querySelector('.currency-dashboard');
    const fireHistory = section.querySelector('.currency-fire-history');
    
    if (!dashboard || !fireHistory) return;
    
    // Get the table from dashboard
    const tableWrap = dashboard.querySelector('.table-wrap');
    if (!tableWrap) return;
    
    const table = tableWrap.querySelector('table');
    if (!table) return;
    
    // Use requestAnimationFrame to ensure layout is complete
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        const tableHeight = table.offsetHeight;
        
        // Set fire history height to match table
        fireHistory.style.height = tableHeight + 'px';
        
        // Adjust the list max-height to account for header
        const headerHeight = fireHistory.querySelector('.currency-fire-history-header')?.offsetHeight || 50;
        const padding = 24; // 12px top + 12px bottom
        const availableHeight = tableHeight - padding - headerHeight;
        
        const listEl = fireHistory.querySelector('.currency-fire-history-list');
        if (listEl) {
          listEl.style.maxHeight = Math.max(0, availableHeight) + 'px';
        }
        
        console.log('[SYNC] Table height:', tableHeight, 'Fire history height:', tableHeight);
      });
    });
  });
}

// Keep fire history height synced on viewport changes
window.addEventListener('resize', () => {
  requestAnimationFrame(() => syncAllFireHistoryHeights());
});

// Test fire button handler
async function testFire(symbol = 'USDJPY') {
  try {
    const res = await fetch('/api/test_fire', { 
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ symbol: symbol })
    });
    const data = await res.json();
    
    if (data.status === 'success') {
      console.log('Test fire sent:', data);
      // Refresh notifications immediately
      setTimeout(checkNotifications, 500);
    } else {
      console.log('Test fire failed:', data);
      alert('テスト発火に失敗しました: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (e) {
    console.log('Test fire error:', e);
    alert('テスト発火エラー: ' + e.message);
  }
}

// Clear fire history for a specific currency
async function clearFireHistory(symbol) {
  try {
    // まず即座にUIをクリア
    const listEl = document.querySelector(`.currency-fire-history-list[data-symbol="${symbol}"]`);
    if (listEl) {
      listEl.innerHTML = '<div style="color: rgba(255,255,255,0.5); text-align: center; padding: 20px;">履歴なし</div>';
    }
    
    // 次にサーバーにクリアリクエストを送信
    const res = await fetch('/api/clear_notifications', { method: 'POST' });
    const data = await res.json();
    if (data.status === 'success') {
      console.log('Notifications cleared');
    } else {
      console.log('Clear failed:', data);
      alert('クリアに失敗しました: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (e) {
    console.log('Clear error:', e);
    alert('クリアエラー: ' + e.message);
  }
}

// グローバル変数: 各通貨の発火履歴ソート状態（true: 降順, false: 昇順）
let fireHistorySortStates = {};

// 発火履歴のソート順を切り替える関数
function toggleSortOrder(symbol) {
  const listEl = document.querySelector(`.currency-fire-history-list[data-symbol="${symbol}"]`);
  if (!listEl) return;
  
  // 現在のソート状態を取得（デフォルトは降順）
  const currentSortDesc = fireHistorySortStates[symbol] !== false; // undefinedの場合はtrue（降順）
  const newSortDesc = !currentSortDesc;
  fireHistorySortStates[symbol] = newSortDesc;
  
  // 発火アイテムを取得
  const items = Array.from(listEl.querySelectorAll('.fire-item'));
  if (items.length === 0) return;
  
  // タイムスタンプでソート
  items.sort((a, b) => {
    const timeA = a.querySelector('.fire-time')?.textContent || '';
    const timeB = b.querySelector('.fire-time')?.textContent || '';
    
    // 日付文字列をDateオブジェクトに変換して比較
    const dateA = parseDateTimeString(timeA);
    const dateB = parseDateTimeString(timeB);
    
    if (newSortDesc) {
      return dateB - dateA; // 降順（新しいものが上）
    } else {
      return dateA - dateB; // 昇順（古いものが上）
    }
  });
  
  // ソートされたアイテムをリストに再配置
  items.forEach(item => listEl.appendChild(item));
  
  // ボタンのテキストを更新
  const sortBtn = document.querySelector(`button[title*="並べ替え"][data-symbol="${symbol}"]`);
  if (sortBtn) {
    sortBtn.textContent = newSortDesc ? '▼▲' : '▲▼';
    sortBtn.title = `履歴の並べ替え（${newSortDesc ? '降順' : '昇順'}）`;
  }
  
  console.log(`[SORT] ${symbol} fire history sorted: ${newSortDesc ? 'descending' : 'ascending'}`);
}

// 日付時刻文字列をDateオブジェクトに変換するヘルパー関数
function parseDateTimeString(dateTimeStr) {
  // 形式: YY/MM/DD HH:mm
  const match = dateTimeStr.match(/^(\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2})$/);
  if (!match) return new Date(0);
  
  const [, yy, mm, dd, hh, mi] = match;
  const year = 2000 + parseInt(yy); // 2000年代として扱う
  const month = parseInt(mm) - 1; // JavaScriptの月は0始まり
  const day = parseInt(dd);
  const hour = parseInt(hh);
  const minute = parseInt(mi);
  
  return new Date(year, month, day, hour, minute);
}

// 音声再生キューシステム
let voiceQueue = [];
let isPlayingVoice = false;
let lastChimeFile = null;  // 最後に再生した警報ファイル
let chimeReplayTimeout = null;  // 警報リプレイ防止タイマー
let speechCallCounter = 0;  // speechSynthesis.speak()呼び出しカウンター（デバッグ用）
let cachedVoices = [];  // 音声リストキャッシュ
let voicesLoaded = false;  // 音声リスト読み込み完了フラグ
let audioContext = null;  // AudioContext for unlocking audio
let audioUnlocked = false;  // オーディオがアンロックされたかどうか
let preloadedChimes = {};  // プリロードされたチャイム音

// オーディオをアンロックする関数（ユーザーインタラクション時に呼び出す）
function unlockAudio() {
  if (audioUnlocked) return;
  
  console.log('[AUDIO_UNLOCK] Attempting to unlock audio...');
  
  // AudioContext を作成してアンロック
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
  }
  
  if (audioContext.state === 'suspended') {
    audioContext.resume().then(() => {
      console.log('[AUDIO_UNLOCK] AudioContext resumed');
    });
  }
  
  // 無音を再生してオーディオをアンロック
  const silentAudio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
  silentAudio.volume = 0.001;
  silentAudio.play().then(() => {
    audioUnlocked = true;
    console.log('[AUDIO_UNLOCK] ✓ Audio unlocked successfully');
  }).catch(e => {
    console.log('[AUDIO_UNLOCK] Silent audio play failed:', e.message);
  });
  
  // speechSynthesis もアンロック
  if ('speechSynthesis' in window) {
    const utterance = new SpeechSynthesisUtterance('');
    utterance.volume = 0;
    speechSynthesis.speak(utterance);
    console.log('[AUDIO_UNLOCK] speechSynthesis unlocked');
  }
}

// ユーザーインタラクションイベントでオーディオをアンロック
['click', 'touchstart', 'keydown'].forEach(eventType => {
  document.addEventListener(eventType, unlockAudio, { once: true });
});

// チャイム音を事前にロードする関数
async function preloadChimeFiles() {
  try {
    const res = await fetch('/api/chime_files');
    if (res.ok) {
      const data = await res.json();
      const files = data.files || [];
      console.log('[CHIME_PRELOAD] Loading', files.length, 'chime files...');
      
      for (const file of files) {
        const audio = new Audio('/Alarm/' + file);
        audio.preload = 'auto';
        audio.load();
        preloadedChimes[file] = audio;
      }
      console.log('[CHIME_PRELOAD] ✓ Preloaded chimes:', Object.keys(preloadedChimes).length);
    }
  } catch (e) {
    console.log('[CHIME_PRELOAD] Error:', e);
  }
}

// ページ読み込み時にチャイムを事前ロード
preloadChimeFiles();

// 音声リストを事前にロードする関数
function preloadVoices() {
  return new Promise((resolve) => {
    if ('speechSynthesis' in window) {
      const voices = speechSynthesis.getVoices();
      if (voices.length > 0) {
        cachedVoices = voices;
        voicesLoaded = true;
        console.log('[VOICE_PRELOAD] Voices loaded immediately:', voices.length);
        resolve(voices);
        return;
      }
      
      // 音声リストがまだロードされていない場合はイベントを待つ
      if (speechSynthesis.onvoiceschanged !== undefined) {
        const handler = () => {
          cachedVoices = speechSynthesis.getVoices();
          voicesLoaded = true;
          console.log('[VOICE_PRELOAD] Voices loaded via event:', cachedVoices.length);
          resolve(cachedVoices);
        };
        speechSynthesis.addEventListener('voiceschanged', handler, { once: true });
        
        // タイムアウト後も解決（フォールバック）
        setTimeout(() => {
          if (!voicesLoaded) {
            cachedVoices = speechSynthesis.getVoices();
            voicesLoaded = cachedVoices.length > 0;
            console.log('[VOICE_PRELOAD] Timeout fallback, voices:', cachedVoices.length);
            resolve(cachedVoices);
          }
        }, 1000);
      } else {
        // onvoiceschanged がサポートされていない場合
        setTimeout(() => {
          cachedVoices = speechSynthesis.getVoices();
          voicesLoaded = cachedVoices.length > 0;
          console.log('[VOICE_PRELOAD] Delayed load, voices:', cachedVoices.length);
          resolve(cachedVoices);
        }, 100);
      }
    } else {
      resolve([]);
    }
  });
}

// ページ読み込み時に音声を事前ロード
preloadVoices();

function playVoiceAlert(message, voiceSettings = null, symbol = null) {
  console.log('[VOICE_ALERT] Called with message:', message, 'chime:', voiceSettings?.chime_file);
  
  // 同じ警報ファイルの重複再生を防ぐ
  const chimeFile = voiceSettings?.chime_file;
  
  // 同じ警報が100ms以内に連続して再生されようとしている場合はスキップ
  if (chimeFile && chimeFile === lastChimeFile && chimeReplayTimeout) {
    console.log('[VOICE_QUEUE] Skipping duplicate chime:', chimeFile);
    return;
  }
  
  // キューに追加
  voiceQueue.push({ message, voiceSettings, symbol });
  console.log('[VOICE_QUEUE] Added to queue. Queue length:', voiceQueue.length, 'Chime:', chimeFile);
  
  // 再生中でなければ次を再生
  if (!isPlayingVoice) {
    playNextInQueue();
  }
}

function playNextInQueue() {
  if (voiceQueue.length === 0) {
    isPlayingVoice = false;
    console.log('[VOICE_QUEUE] Queue empty');
    return;
  }
  
  isPlayingVoice = true;
  const item = voiceQueue.shift();
  console.log('[VOICE_QUEUE] Playing next. Remaining:', voiceQueue.length);
  
  try {
    // Check if speech synthesis is supported
    if (!('speechSynthesis' in window)) {
      console.log('Speech synthesis not supported');
      playNextInQueue();
      return;
    }
    
    // Play chime first if specified
    if (item.voiceSettings && item.voiceSettings.chime_file) {
      const chimeFile = item.voiceSettings.chime_file;
      
      // プリロードされたチャイムを使用、なければ新規作成
      let chimeAudio;
      if (preloadedChimes[chimeFile]) {
        chimeAudio = preloadedChimes[chimeFile].cloneNode();  // クローンして同時再生可能に
        console.log('[VOICE_QUEUE] Using preloaded chime:', chimeFile);
      } else {
        chimeAudio = new Audio('/Alarm/' + chimeFile);
        console.log('[VOICE_QUEUE] Creating new Audio for chime:', chimeFile);
      }
      
      chimeAudio.volume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
      
      // タイムアウトクリア
      if (chimeReplayTimeout) clearTimeout(chimeReplayTimeout);
      
      // 警報ファイルを記録
      lastChimeFile = chimeFile;
      console.log('[VOICE_QUEUE] Playing chime:', chimeFile, 'audioUnlocked:', audioUnlocked);
      
      // 再生完了時のハンドラ
      const onChimeEnd = () => {
        console.log('[VOICE_QUEUE] Chime ended:', chimeFile);
        playVoiceMessage(item.message, item.voiceSettings, item.symbol, () => {
          // 音声再生完了後、次を再生
          playNextInQueue();
        });
      };
      
      chimeAudio.addEventListener('ended', onChimeEnd, { once: true });
      
      // エラー時のフォールバック
      chimeAudio.addEventListener('error', (e) => {
        console.log('[VOICE_QUEUE] Chime error:', e);
        onChimeEnd();
      }, { once: true });
      
      // 再生試行
      const playPromise = chimeAudio.play();
      if (playPromise !== undefined) {
        playPromise.then(() => {
          console.log('[VOICE_QUEUE] ✓ Chime playing:', chimeFile);
        }).catch(e => {
          console.log('[VOICE_QUEUE] Chime play blocked:', e.message);
          // オーディオがブロックされた場合、音声メッセージのみ再生
          playVoiceMessage(item.message, item.voiceSettings, item.symbol, () => {
            playNextInQueue();
          });
        });
      }
      
      // 警報再生後、100msのリプレイ防止タイマーをセット
      chimeReplayTimeout = setTimeout(() => {
        lastChimeFile = null;
        chimeReplayTimeout = null;
      }, 100);
    } else {
      playVoiceMessage(item.message, item.voiceSettings, item.symbol, () => {
        playNextInQueue();
      });
    }
  } catch (e) {
    console.log('playNextInQueue error', e);
    playNextInQueue();
  }
}

function playVoiceMessage(message, voiceSettings = null, symbol = null, onComplete = null, retryCount = 0) {
  console.log('[VOICE_MESSAGE] Called with message:', message, 'voiceSettings:', voiceSettings, 'retryCount:', retryCount);
  
  // 音声リストを取得（キャッシュ優先）
  let voices = cachedVoices.length > 0 ? cachedVoices : speechSynthesis.getVoices();
  
  // 音声リストが空の場合は再試行
  if (voices.length === 0 && retryCount < 3) {
    console.log('[VOICE_MESSAGE] No voices available, retrying in 200ms... (attempt', retryCount + 1, ')');
    setTimeout(() => {
      // 再度音声リストを取得
      cachedVoices = speechSynthesis.getVoices();
      playVoiceMessage(message, voiceSettings, symbol, onComplete, retryCount + 1);
    }, 200);
    return;
  }
  
  // Create utterance
  const utterance = new SpeechSynthesisUtterance(message);
  
  // Get global settings
  const globalVolume = parseFloat(localStorage.getItem('tv_voice_volume') || '0.8');
  const globalRate = parseFloat(localStorage.getItem('tv_voice_rate') || '1.0');
  
  // Apply voice settings (rule-specific or global)
  utterance.lang = 'ja-JP';
  utterance.volume = globalVolume;
  utterance.rate = globalRate;
  
  // 許可された音声リスト
  const allowedVoiceNames = [
    'Microsoft 七海 Online (Natural) - Japanese (Japan)',
    'Microsoft 圭太 Online (Natural) - Japanese (Japan)',
    'Microsoft 碧衣 Online (Natural) - Japanese (Japan)',
    'Microsoft 大智 Online (Natural) - Japanese (Japan)',
    'Microsoft 真夕 Online (Natural) - Japanese (Japan)',
    'Microsoft 直紀 Online (Natural) - Japanese (Japan)',
    'Microsoft 志織 Online (Natural) - Japanese (Japan)'
  ];
  
  // ブロックする音声リスト（オフライン音声など）
  const blockedVoiceNames = [
    'Microsoft Ayumi - Japanese (Japan)',
    'Microsoft Haruka - Japanese (Japan)',
    'Microsoft Ichiro - Japanese (Japan)',
    'Microsoft Sayaka - Japanese (Japan)',
    'Microsoft Ayumi Desktop - Japanese (Japan)',
    'Microsoft Haruka Desktop - Japanese (Japan)',
    'Microsoft Ichiro Desktop - Japanese (Japan)',
    'Microsoft Sayaka Desktop - Japanese (Japan)',
    'Microsoft Ayumi (Japanese)',
    'Microsoft Haruka (Japanese)',
    'Microsoft Ichiro (Japanese)',
    'Microsoft Sayaka (Japanese)'
  ];
  
  // キャッシュを更新
  if (voices.length > 0) {
    cachedVoices = voices;
    voicesLoaded = true;
  }
  
  // 音声リストをフィルタ
  const availableVoices = voices.filter(v => !blockedVoiceNames.includes(v.name));
  
  console.log('[VOICE_MESSAGE] Total voices:', voices.length, 'After blocking:', availableVoices.length);
  
  // Set voice if specified
  if (voiceSettings && voiceSettings.voice_name) {
    const selectedVoice = availableVoices.find(v => v.name === voiceSettings.voice_name);
    if (selectedVoice) {
      utterance.voice = selectedVoice;
      console.log('[VOICE_MESSAGE] ✓ Using custom voice:', selectedVoice.name);
    } else {
      console.warn('[VOICE_MESSAGE] ⚠️ Custom voice not found:', voiceSettings.voice_name);
      console.warn('[VOICE_MESSAGE] Available voices:', availableVoices.map(v => v.name));
      // 許可された音声リストから最初の利用可能な音声を選択
      const fallbackVoice = availableVoices.find(v => allowedVoiceNames.includes(v.name));
      if (fallbackVoice) {
        utterance.voice = fallbackVoice;
        console.warn('[VOICE_MESSAGE] ⚠️ Using fallback voice:', fallbackVoice.name);
      } else {
        console.error('[VOICE_MESSAGE] ❌ No allowed voices available! Canceling speech.');
        console.error('[VOICE_MESSAGE] Available JP voices:', availableVoices.filter(v => v.lang.includes('ja') || v.lang.includes('JP')).map(v => v.name));
        if (onComplete) onComplete();
        return; // 音声再生をキャンセル
      }
    }
  } else {
    console.warn('[VOICE_MESSAGE] ⚠️ No voice settings provided');
    // 許可された音声リストから最初の利用可能な音声を選択
    const fallbackVoice = availableVoices.find(v => allowedVoiceNames.includes(v.name));
    if (fallbackVoice) {
      utterance.voice = fallbackVoice;
      console.log('[VOICE_MESSAGE] Using fallback voice:', fallbackVoice.name);
    } else {
      console.error('[VOICE_MESSAGE] ❌ No allowed voices available! Canceling speech.');
      if (onComplete) onComplete();
      return; // 音声再生をキャンセル
    }
  }
  
  // 音声が正しく設定されているか最終チェック
  if (utterance.voice && blockedVoiceNames.includes(utterance.voice.name)) {
    console.error('[VOICE_MESSAGE] ❌ BLOCKED VOICE DETECTED:', utterance.voice.name);
    console.error('[VOICE_MESSAGE] ❌ Forcing voice to first allowed voice...');
    const forcedVoice = availableVoices.find(v => allowedVoiceNames.includes(v.name));
    if (forcedVoice) {
      utterance.voice = forcedVoice;
      console.log('[VOICE_MESSAGE] ✓ Forced to:', forcedVoice.name);
    } else {
      console.error('[VOICE_MESSAGE] ❌ Cannot find allowed voice. Canceling speech.');
      if (onComplete) onComplete();
      return;
    }
  }
  
  // 通貨名挿入の場合、一拍の間を入れるために分割発声
  if (voiceSettings && voiceSettings.insert_symbol && symbol) {
    const japaneseName = currencyNames[symbol] || symbol;
    const position = voiceSettings.symbol_insert_position || 'prefix';
    
    let parts = [];
    if (position === 'prefix') {
      parts = [japaneseName, message.replace(japaneseName + ' ', '')];
    } else if (position === 'suffix') {
      parts = [message.replace(' ' + japaneseName, ''), japaneseName];
    } else if (position === 'both') {
      const middleMessage = message.replace(japaneseName + ' ', '').replace(' ' + japaneseName, '');
      parts = [japaneseName, middleMessage, japaneseName];
    }
    
    if (parts.length > 1) {
      console.log('[VOICE_MESSAGE] Split speaking with', parts.length, 'parts');
      // 分割発声
      let currentIndex = 0;
      
      function speakNext() {
        if (currentIndex < parts.length) {
          const partUtterance = new SpeechSynthesisUtterance(parts[currentIndex]);
          partUtterance.lang = utterance.lang;
          partUtterance.volume = utterance.volume;
          partUtterance.rate = utterance.rate;
          partUtterance.voice = utterance.voice;
          
          // 音声がブロックリストに含まれていないか確認
          if (partUtterance.voice) {
            const blockedNames = [
              'Microsoft Ayumi - Japanese (Japan)',
              'Microsoft Haruka - Japanese (Japan)',
              'Microsoft Ichiro - Japanese (Japan)',
              'Microsoft Sayaka - Japanese (Japan)',
              'Microsoft Ayumi Desktop - Japanese (Japan)',
              'Microsoft Haruka Desktop - Japanese (Japan)',
              'Microsoft Ichiro Desktop - Japanese (Japan)',
              'Microsoft Sayaka Desktop - Japanese (Japan)',
              'Microsoft Ayumi (Japanese)',
              'Microsoft Haruka (Japanese)',
              'Microsoft Ichiro (Japanese)',
              'Microsoft Sayaka (Japanese)'
            ];
            if (blockedNames.includes(partUtterance.voice.name)) {
              console.error('[VOICE_MESSAGE] ❌ BLOCKED VOICE IN PART:', partUtterance.voice.name);
              if (onComplete) onComplete();
              return;
            }
          }
          
          speechCallCounter++;
          const partCallId = speechCallCounter;
          console.log('[VOICE_MESSAGE] 🔊 Part', currentIndex + 1, '/', parts.length, 'speak() call #' + partCallId, ':', parts[currentIndex]);
          console.log('[VOICE_MESSAGE] Part voice:', partUtterance.voice ? partUtterance.voice.name : 'DEFAULT');
          
          partUtterance.onend = () => {
            currentIndex++;
            if (currentIndex >= parts.length) {
              // 全パート完了
              console.log('[VOICE_MESSAGE] All parts completed');
              if (onComplete) onComplete();
            } else {
              // 一拍の間を入れるために少し遅延
              setTimeout(speakNext, 200); // 200msの間
            }
          };
          
          partUtterance.onerror = () => {
            console.log('Part utterance error');
            if (onComplete) onComplete();
          };
          
          speechSynthesis.speak(partUtterance);
        } else {
          if (onComplete) onComplete();
        }
      }
      
      speakNext();
      return;
    }
  }
  
  // 完了イベントハンドラーを設定
  utterance.onstart = () => {
    console.log('[VOICE_MESSAGE] ✓ Voice synthesis started successfully');
  };
  
  utterance.onend = () => {
    console.log('[VOICE_MESSAGE] Voice message completed');
    if (onComplete) onComplete();
  };
  
  utterance.onerror = (e) => {
    console.log('[VOICE_MESSAGE] Voice message error:', e);
    if (onComplete) onComplete();
  };
  
  // 既存の音声を停止してから新しい音声を再生
  if (speechSynthesis.speaking || speechSynthesis.pending) {
    console.log('[VOICE_MESSAGE] Canceling existing speech before starting new one');
    speechSynthesis.cancel();
    // キャンセル後に少し待機
    setTimeout(() => {
      startSpeech();
    }, 50);
  } else {
    startSpeech();
  }
  
  function startSpeech() {
    // Speak
    speechCallCounter++;
    const currentCallId = speechCallCounter;
    console.log('[VOICE_MESSAGE] 🔊 speechSynthesis.speak() call #' + currentCallId);
    console.log('[VOICE_MESSAGE] Final voice check - Selected:', utterance.voice ? utterance.voice.name : 'DEFAULT (System)');
    console.log('[VOICE_MESSAGE] Final voice check - Lang:', utterance.lang);
    console.log('[VOICE_MESSAGE] Message to speak:', message);
    
    // 音声が明示的に設定されているか確認
    if (!utterance.voice) {
      console.error('[VOICE_MESSAGE] ❌ ERROR: No voice set! This should never happen!');
      console.error('[VOICE_MESSAGE] ❌ Available voices:', speechSynthesis.getVoices().filter(v => v.lang.startsWith('ja')).map(v => v.name));
      if (onComplete) onComplete();
      return;
    }
    
    speechSynthesis.speak(utterance);
    
    console.log('[VOICE_MESSAGE] Playing voice message:', message, 'volume:', utterance.volume, 'rate:', utterance.rate);
  }
}

// 音声有効化オーバーレイの表示
function showAudioEnableOverlay() {
  // 既にアンロックされていれば表示しない
  if (audioUnlocked) {
    console.log('[AUDIO_OVERLAY] Already unlocked, skipping overlay');
    return;
  }
  
  // 既存のオーバーレイがあれば表示しない
  if (document.getElementById('audioEnableOverlay')) {
    console.log('[AUDIO_OVERLAY] Overlay already exists');
    return;
  }
  
  console.log('[AUDIO_OVERLAY] Showing audio enable overlay');
  
  const overlay = document.createElement('div');
  overlay.id = 'audioEnableOverlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    cursor: pointer;
  `;
  
  overlay.innerHTML = `
    <div style="
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      border: 2px solid #4a90d9;
      border-radius: 16px;
      padding: 40px 60px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(74, 144, 217, 0.3);
    ">
      <div style="font-size: 48px; margin-bottom: 20px;">🔊</div>
      <div style="color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 12px;">
        音声通知を有効化
      </div>
      <div style="color: #aaa; font-size: 14px; margin-bottom: 20px;">
        クリックして音声アラートを有効にしてください
      </div>
      <button style="
        background: linear-gradient(135deg, #4a90d9 0%, #357abd 100%);
        color: white;
        border: none;
        padding: 12px 36px;
        font-size: 16px;
        font-weight: bold;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      " onmouseover="this.style.transform='scale(1.05)'; this.style.boxShadow='0 4px 16px rgba(74,144,217,0.5)';"
         onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none';">
        有効化
      </button>
    </div>
  `;
  
  overlay.addEventListener('click', () => {
    unlockAudio();
    overlay.remove();
    console.log('[AUDIO_OVERLAY] Dismissed and audio unlocked');
  });
  
  document.body.appendChild(overlay);
}

// ページ読み込み後にオーバーレイを表示（常に表示）
setTimeout(showAudioEnableOverlay, 500);
</script>
</body>
</html>
