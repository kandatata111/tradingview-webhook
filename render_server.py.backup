from flask import Flask, request, jsonify, render_template
import os
import requests
from datetime import datetime
import json
import webbrowser
import threading
import logging
import sys

# Windows環境でのUnicode出力を修正
if sys.platform == 'win32':
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer, 'strict')
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer, 'strict')

# ロギング設定
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('webhook_debug.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.config['TEMPLATES_AUTO_RELOAD'] = True
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

# スクリプトのディレクトリを取得
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
DB_PATH = os.path.join(BASE_DIR, 'webhook_data.db')

# データベース接続関数（PostgreSQL優先、フォールバックでSQLite）
def get_db_connection():
    """データベース接続を取得（PostgreSQL優先、SQLiteフォールバック）"""
    try:
        import psycopg2
        return psycopg2.connect(os.environ['DATABASE_URL'])
    except (ImportError, KeyError):
        # PostgreSQLが利用できない場合はSQLiteを使用
        import sqlite3
        return sqlite3.connect(DB_PATH)

def is_postgresql():
    """PostgreSQLを使用しているかどうか"""
    try:
        import psycopg2
        return 'DATABASE_URL' in os.environ
    except ImportError:
        return False

# 雲状態分析関数
def analyze_clouds(symbol, price, clouds):
    """
    雲の状態を分析して通知を生成
    """
    notifications = []
    
    for cloud in clouds:
        label = cloud.get('label', '')
        tf = cloud.get('tf', '')
        gc = cloud.get('gc', False)
        fire_count = cloud.get('fire_count', 0)
        max_reached = cloud.get('max_reached', False)
        thickness = cloud.get('thickness', 0)
        angle = cloud.get('angle', 0)
        elapsed = cloud.get('elapsed', 0)
        
        # 発火があった場合のみ通知
        if fire_count > 0:
            # 雲の種類を判定
            if label == '5m':
                cloud_type = 'short'
                cloud_name = '短期雲'
            elif label == '15m':
                cloud_type = 'mid'
                cloud_name = '中期雲'
            elif label == '1H':
                cloud_type = 'long'
                cloud_name = '長期雲'
            elif label == '4H':
                cloud_type = 'ultra'
                cloud_name = '超長期雲'
            else:
                continue
            
            # GC/DCを判定
            direction = 'up' if gc else 'dn'
            direction_ja = 'ゴールデンクロス' if gc else 'デッドクロス'
            
            # アラートタイプを決定
            alert_type = f'{cloud_type}_{direction}'
            
            # 最大発火数到達の場合
            if max_reached:
                alert_type = 'max_reached'
                direction_ja = '最大発火数到達'
            
            # メッセージ生成
            message = f"{cloud_name} {direction_ja} (発火{fire_count}回)"
            
            # Discord用メッセージ
            line_message = f"""🔔 ダウ雲アラート
銘柄: {symbol}
時間足: {tf}
価格: {price}

{cloud_name} ({label})
状態: {direction_ja}
発火回数: {fire_count}回
雲厚み: {thickness:.2f} Pips
雲角度: {angle:.2f}°
経過時間: {elapsed}バー

時刻: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"""
            
            notifications.append({
                'alert_type': alert_type,
                'message': message,
                'line_message': line_message,
                'cloud_label': label
            })
    
    return notifications

# Database setup
def init_db():
    """データベース初期化"""
    if is_postgresql():
        # PostgreSQLの場合
        conn = get_db_connection()
        c = conn.cursor()
        
        # 現在状態テーブル(通貨ペアごとに最新状態のみ保持)
        c.execute('''CREATE TABLE IF NOT EXISTS current_states
                     (symbol TEXT PRIMARY KEY,
                      timestamp TEXT,
                      tf TEXT,
                      price REAL,
                      daily_dow_status TEXT,
                      daily_dow_bos TEXT,
                      daily_dow_time TEXT,
                      swing_dow_status TEXT,
                      swing_dow_bos TEXT,
                      swing_dow_time TEXT,
                      row_order TEXT,
                      cloud_order TEXT,
                      cloud_5m_gc INTEGER,
                      cloud_5m_thickness REAL,
                      cloud_5m_angle REAL,
                      cloud_5m_fire_count INTEGER,
                      cloud_5m_elapsed TEXT,
                      cloud_5m_distance_from_price REAL,
                      cloud_5m_distance_from_prev REAL,
                      cloud_5m_topPrice REAL,
                      cloud_5m_bottomPrice REAL,
                      cloud_15m_gc INTEGER,
                      cloud_15m_thickness REAL,
                      cloud_15m_angle REAL,
                      cloud_15m_fire_count INTEGER,
                      cloud_15m_elapsed TEXT,
                      cloud_15m_distance_from_price REAL,
                      cloud_15m_distance_from_prev REAL,
                      cloud_15m_topPrice REAL,
                      cloud_15m_bottomPrice REAL,
                      cloud_1h_gc INTEGER,
                      cloud_1h_thickness REAL,
                      cloud_1h_angle REAL,
                      cloud_1h_fire_count INTEGER,
                      cloud_1h_elapsed TEXT,
                      cloud_1h_distance_from_price REAL,
                      cloud_1h_distance_from_prev REAL,
                      cloud_1h_topPrice REAL,
                      cloud_1h_bottomPrice REAL,
                      cloud_4h_gc INTEGER,
                      cloud_4h_thickness REAL,
                      cloud_4h_angle REAL,
                      cloud_4h_fire_count INTEGER,
                      cloud_4h_elapsed TEXT,
                      cloud_4h_distance_from_price REAL,
                      cloud_4h_distance_from_prev REAL,
                      cloud_4h_topPrice REAL,
                      cloud_4h_bottomPrice REAL)''')
        
        # 発火履歴テーブル（通知用）
        c.execute('''CREATE TABLE IF NOT EXISTS fire_history
                     (id SERIAL PRIMARY KEY,
                      timestamp TEXT,
                      symbol TEXT,
                      cloud_label TEXT,
                      fire_count INTEGER,
                      gc INTEGER,
                      message TEXT)''')
        
        conn.commit()
        conn.close()
    else:
        # SQLiteの場合
        import sqlite3
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()
        
        # 現在状態テーブル(通貨ペアごとに最新状態のみ保持)
        c.execute('''CREATE TABLE IF NOT EXISTS current_states
                     (symbol TEXT PRIMARY KEY,
                      timestamp TEXT,
                      tf TEXT,
                      price REAL,
                      daily_dow_status TEXT,
                      daily_dow_bos TEXT,
                      daily_dow_time TEXT,
                      swing_dow_status TEXT,
                      swing_dow_bos TEXT,
                      swing_dow_time TEXT,
                      row_order TEXT,
                      cloud_order TEXT,
                      cloud_5m_gc INTEGER,
                      cloud_5m_thickness REAL,
                      cloud_5m_angle REAL,
                      cloud_5m_fire_count INTEGER,
                      cloud_5m_elapsed TEXT,
                      cloud_5m_distance_from_price REAL,
                      cloud_5m_distance_from_prev REAL,
                      cloud_5m_topPrice REAL,
                      cloud_5m_bottomPrice REAL,
                      cloud_15m_gc INTEGER,
                      cloud_15m_thickness REAL,
                      cloud_15m_angle REAL,
                      cloud_15m_fire_count INTEGER,
                      cloud_15m_elapsed TEXT,
                      cloud_15m_distance_from_price REAL,
                      cloud_15m_distance_from_prev REAL,
                      cloud_15m_topPrice REAL,
                      cloud_15m_bottomPrice REAL,
                      cloud_1h_gc INTEGER,
                      cloud_1h_thickness REAL,
                      cloud_1h_angle REAL,
                      cloud_1h_fire_count INTEGER,
                      cloud_1h_elapsed TEXT,
                      cloud_1h_distance_from_price REAL,
                      cloud_1h_distance_from_prev REAL,
                      cloud_1h_topPrice REAL,
                      cloud_1h_bottomPrice REAL,
                      cloud_4h_gc INTEGER,
                      cloud_4h_thickness REAL,
                      cloud_4h_angle REAL,
                      cloud_4h_fire_count INTEGER,
                      cloud_4h_elapsed TEXT,
                      cloud_4h_distance_from_price REAL,
                      cloud_4h_distance_from_prev REAL,
                      cloud_4h_topPrice REAL,
                      cloud_4h_bottomPrice REAL)''')
        
        # 発火履歴テーブル（通知用）
        c.execute('''CREATE TABLE IF NOT EXISTS fire_history
                     (id INTEGER PRIMARY KEY AUTOINCREMENT,
                      timestamp TEXT,
                      symbol TEXT,
                      cloud_label TEXT,
                      fire_count INTEGER,
                      gc INTEGER,
                      message TEXT)''')
        
        conn.commit()
        conn.close()

# Send Discord notification
def send_discord_notification(message):
    webhook_url = os.getenv('DISCORD_WEBHOOK_URL')
    if not webhook_url:
        print("DISCORD_WEBHOOK_URL not set")
        return
    
    payload = {
        'content': message
    }
    try:
        response = requests.post(webhook_url, json=payload)
        print(f"Discord notification sent: {response.status_code}")
    except Exception as e:
        print(f"Discord notification error: {e}")

# Forward to local client
def forward_to_local_client(data):
    local_url = os.getenv('LOCAL_CLIENT_URL')
    if not local_url:
        print("LOCAL_CLIENT_URL not set - skipping forward")
        return
    
    try:
        requests.post(local_url, json=data, timeout=5)
        print("Forwarded to local client")
    except Exception as e:
        print(f"Forward error: {e}")

@app.errorhandler(Exception)
def handle_exception(e):
    """すべての例外をキャッチしてトレースバックをログ"""
    import traceback
    import sys
    import os
    
    # 例外情報を取得
    exc_type, exc_value, exc_traceback = sys.exc_info()
    error_msg = f"[UNHANDLED EXCEPTION] {exc_type.__name__}: {exc_value}"
    traceback_list = traceback.format_exception(exc_type, exc_value, exc_traceback)
    traceback_str = ''.join(traceback_list)
    
    # 絶対パスでファイルに書き込み
    error_log_path = r'c:\Users\kanda\Desktop\PythonData\TradingViewWebhook\error_log.txt'
    try:
        error_file = open(error_log_path, 'a', encoding='utf-8')
        error_file.write(f"\n\n==== ERROR at {datetime.now()} ====\n")
        error_file.write(f"{error_msg}\n")
        error_file.write(f"Traceback:\n{traceback_str}\n")
        error_file.flush()
        error_file.close()
    except Exception as file_err:
        # ファイル書き込み失敗もログ
        try:
            fallback_log = r'c:\Users\kanda\Desktop\PythonData\error_fallback.txt'
            with open(fallback_log, 'a', encoding='utf-8') as f:
                f.write(f"Failed to write error_log.txt: {file_err}\n")
                f.write(f"Original error: {error_msg}\n")
        except:
            pass
    
    # コンソールにも出力
    print(f"\n\n{error_msg}", flush=True)
    print(traceback_str, flush=True)
    
    return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/webhook', methods=['POST'])
def webhook():
    """
    Webhook endpoint - 最小限の実装から段階的に構築
    """
    try:
        # Step 1: JSONデータを取得
        data = request.get_json()
        
        if data is None:
            return jsonify({'status': 'error', 'message': 'No JSON data received'}), 400
        
        # Step 2: 基本的なデータ抽出
        symbol = data.get('symbol', 'UNKNOWN')
        tf = data.get('tf', '5')
        price = float(data.get('price', 0))
        
        print(f"✅ Received webhook - Symbol: {symbol}, TF: {tf}, Price: {price}", flush=True)
        
        # Step 3: 成功レスポンスを返す（まずは最小限）
        return jsonify({
            'status': 'success',
            'message': 'Webhook received',
            'symbol': symbol,
            'tf': tf,
            'price': price
        }), 200
        
    except Exception as e:
        print(f"❌ Webhook error: {e}", flush=True)
        import traceback
        traceback.print_exc()
        return jsonify({'status': 'error', 'message': str(e)}), 500
        
        symbol = data.get('symbol', 'UNKNOWN')
        tf = data.get('tf', '5')
        price = data.get('price', 0)
        
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"🔍 Step 2: Extracting clouds... data type: {type(data)}\n")
        
        clouds = data.get('clouds', {})
        
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"🔍 DEBUG: clouds type: {type(clouds)}, value: {clouds}\n")
        
        # 雲データの形式をチェック
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"🔍 Step 3: Checking clouds format...\n")
        
        if isinstance(clouds, str):
            # cloudsがJSON文字列の場合、パースする
            try:
                import json
                clouds = json.loads(clouds)
                print(f"🔄 Parsed clouds from string to: {type(clouds)}", flush=True)
                logger.info(f"🔄 Parsed clouds from string to: {type(clouds)}")
            except json.JSONDecodeError as e:
                print(f"❌ Failed to parse clouds string: {e}", flush=True)
                logger.error(f"❌ Failed to parse clouds string: {e}")
                clouds = {}
        elif isinstance(clouds, list):
            # 古いリスト形式の場合、辞書形式に変換
            clouds_dict = {}
            for idx, cloud in enumerate(clouds):
                if isinstance(cloud, str):
                    try:
                        import json
                        cloud = json.loads(cloud)
                        print(f"🔄 Parsed cloud index {idx} from string to dict", flush=True)
                        logger.info(f"🔄 Parsed cloud index {idx} from string to dict")
                    except json.JSONDecodeError as e:
                        print(f"❌ Failed to parse cloud index {idx} string: {e}, skipping", flush=True)
                        logger.error(f"❌ Failed to parse cloud index {idx} string: {e}, skipping")
                        continue

                if not isinstance(cloud, dict):
                    print(f"⚠️ cloud index {idx} is not dict, type: {type(cloud)}, value: {cloud}, skipping", flush=True)
                    logger.warning(f"⚠️ cloud index {idx} is not dict, type: {type(cloud)}, value: {cloud}, skipping")
                    continue

                label = cloud.get('label') or cloud.get('tf') or f'label_{idx}'
                clouds_dict[label] = cloud
            clouds = clouds_dict
        elif not isinstance(clouds, dict):
            # cloudsが辞書でない場合（Noneなど）、空の辞書に設定
            print(f"⚠️ clouds is not dict, type: {type(clouds)}, value: {clouds}, setting to empty dict", flush=True)
            logger.warning(f"⚠️ clouds is not dict, type: {type(clouds)}, value: {clouds}, setting to empty dict")
            clouds = {}
        
        print(f"✅ Parsed - Symbol: {symbol}, TF: {tf}, Price: {price}, Clouds: {len(clouds)}", flush=True)
        logger.info(f"✅ Parsed - Symbol: {symbol}, TF: {tf}, Price: {price}, Clouds: {len(clouds)}")
        
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"🔍 Step 4: About to get daytrade, data keys: {data.keys()}\n")
        
        print(f"🔍 DEBUG: About to get daytrade, data keys: {data.keys()}", flush=True)
        
        # デイトレード/スイングダウ情報の取得
        # 'daytrade'/'swing' または 'daily_dow'/'swing_dow' の両方をサポート
        # 受け取ったデータをそのまま使用
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"🔍 Step 5: Getting daytrade_raw...\n")
        
        daytrade_raw = data.get('daytrade') or data.get('daily_dow') or {}
        
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"🔍 DEBUG: daytrade_raw type: {type(daytrade_raw)}, value: {daytrade_raw}\n")
        
        print(f"🔍 DEBUG: daytrade_raw type: {type(daytrade_raw)}, value: {daytrade_raw}", flush=True)
        if isinstance(daytrade_raw, str):
            # daytrade_rawがJSON文字列の場合、パースする
            try:
                import json
                daytrade_raw = json.loads(daytrade_raw)
                print(f"🔄 Parsed daytrade_raw from string to: {type(daytrade_raw)}", flush=True)
                logger.info(f"🔄 Parsed daytrade_raw from string to: {type(daytrade_raw)}")
            except json.JSONDecodeError as e:
                print(f"❌ Failed to parse daytrade_raw string: {e}, using empty dict", flush=True)
                logger.error(f"❌ Failed to parse daytrade_raw string: {e}, using empty dict")
                daytrade_raw = {}
        if not isinstance(daytrade_raw, dict):
            print(f"⚠️ daytrade_raw is not dict, type: {type(daytrade_raw)}, value: {daytrade_raw}, using empty dict")
            daytrade_raw = {}
        
        swing_raw = data.get('swing') or data.get('swing_dow') or {}
        if isinstance(swing_raw, str):
            # swing_rawがJSON文字列の場合、パースする
            try:
                import json
                swing_raw = json.loads(swing_raw)
                print(f"🔄 Parsed swing_raw from string to: {type(swing_raw)}", flush=True)
                logger.info(f"🔄 Parsed swing_raw from string to: {type(swing_raw)}")
            except json.JSONDecodeError as e:
                print(f"❌ Failed to parse swing_raw string: {e}, using empty dict", flush=True)
                logger.error(f"❌ Failed to parse swing_raw string: {e}, using empty dict")
                swing_raw = {}
        if not isinstance(swing_raw, dict):
            print(f"⚠️ swing_raw is not dict, type: {type(swing_raw)}, value: {swing_raw}, using empty dict")
            swing_raw = {}
        
        daily_dow = {
            'status': daytrade_raw.get('status', ''),
            'bos': daytrade_raw.get('bos', ''),
            'time': daytrade_raw.get('time', '')
        }
        
        swing_dow = {
            'status': swing_raw.get('status', ''),
            'bos': swing_raw.get('bos', ''),
            'time': swing_raw.get('time', '')
        }
        
        row_order = data.get('row_order', ['price', '5m', '15m', '1H', '4H'])
        if not isinstance(row_order, list):
            print(f"⚠️ row_order is not list, type: {type(row_order)}, value: {row_order}, using default")
            row_order = ['price', '5m', '15m', '1H', '4H']
        
        cloud_order = data.get('cloud_order', ['5m', '15m', '1H', '4H'])
        if not isinstance(cloud_order, list):
            print(f"⚠️ cloud_order is not list, type: {type(cloud_order)}, value: {cloud_order}, using default")
            cloud_order = ['5m', '15m', '1H', '4H']
        
        # 雲データをパース
        cloud_data = {}
        for label, cloud in clouds.items():
            if isinstance(cloud, str):
                # cloudがJSON文字列の場合、パースする
                try:
                    import json
                    cloud = json.loads(cloud)
                    print(f"🔄 Parsed cloud {label} from string to dict", flush=True)
                    logger.info(f"🔄 Parsed cloud {label} from string to dict")
                except json.JSONDecodeError as e:
                    print(f"❌ Failed to parse cloud {label} string: {e}, skipping", flush=True)
                    logger.error(f"❌ Failed to parse cloud {label} string: {e}, skipping")
                    continue

            if not isinstance(cloud, dict):
                print(f"⚠️ cloud {label} is not dict after parsing, type: {type(cloud)}, value: {cloud}, skipping", flush=True)
                logger.warning(f"⚠️ cloud {label} is not dict after parsing, type: {type(cloud)}, value: {cloud}, skipping")
                continue
            
            topPrice = cloud.get('topPrice', 0)
            bottomPrice = cloud.get('bottomPrice', 0)
            
            # NAチェックを追加: PineScriptが"na"を送信した場合に0.0に変換
            if isinstance(topPrice, str) and topPrice.lower() == 'na':
                topPrice = 0.0
            else:
                try:
                    topPrice = float(topPrice)
                except ValueError:
                    topPrice = 0.0
            
            if isinstance(bottomPrice, str) and bottomPrice.lower() == 'na':
                bottomPrice = 0.0
            else:
                try:
                    bottomPrice = float(bottomPrice)
                except ValueError:
                    bottomPrice = 0.0
            
            cloud_data[label] = {
                'gc': 1 if cloud.get('gc', False) else 0,
                'thickness': cloud.get('thickness', 0),
                'angle': cloud.get('angle', 0),
                'fire_count': cloud.get('fire_count', 0),
                'elapsed': str(cloud.get('elapsed', '')),
                'distance_from_price': cloud.get('distance_from_price', 0),
                'distance_from_prev': cloud.get('distance_from_prev', 0),
                'topPrice': topPrice,
                'bottomPrice': bottomPrice
            }
            with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
                f.write(f"🔍 Parsed cloud {label}: topPrice={topPrice}, bottomPrice={bottomPrice}, cloud_data[{label}]={cloud_data[label]}\n")
            print(f"🔍 Parsed cloud {label}: topPrice={topPrice}, bottomPrice={bottomPrice}, cloud_data[{label}]={cloud_data[label]}", flush=True)
            logger.debug(f"🔍 Parsed cloud {label}: topPrice={topPrice}, bottomPrice={bottomPrice}, cloud_data[{label}]={cloud_data[label]}")
        
        # Save to database
        conn = get_db_connection()
        c = conn.cursor()
        
        # デバッグ: cloud_dataの内容を確認
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"🔍 cloud_data keys: {cloud_data.keys()}\n")
            f.write(f"🔍 5m topPrice from cloud_data: {cloud_data.get('5m', {}).get('topPrice', 'KEY_NOT_FOUND')}\n")
            f.write(f"🔍 5m bottomPrice from cloud_data: {cloud_data.get('5m', {}).get('bottomPrice', 'KEY_NOT_FOUND')}\n")
        print(f"🔍 cloud_data keys: {cloud_data.keys()}", flush=True)
        print(f"🔍 5m topPrice from cloud_data: {cloud_data.get('5m', {}).get('topPrice', 'KEY_NOT_FOUND')}", flush=True)
        print(f"🔍 5m bottomPrice from cloud_data: {cloud_data.get('5m', {}).get('bottomPrice', 'KEY_NOT_FOUND')}", flush=True)
        logger.debug(f"🔍 cloud_data keys: {cloud_data.keys()}")
        logger.debug(f"🔍 5m topPrice from cloud_data: {cloud_data.get('5m', {}).get('topPrice', 'KEY_NOT_FOUND')}")
        logger.debug(f"🔍 5m bottomPrice from cloud_data: {cloud_data.get('5m', {}).get('bottomPrice', 'KEY_NOT_FOUND')}")
        
        # values変数を定義
        values = (
            symbol, datetime.now().isoformat(), tf, price,
            daily_dow['status'], daily_dow['bos'], daily_dow['time'],
            swing_dow['status'], swing_dow['bos'], swing_dow['time'],
            ','.join(row_order), ','.join(cloud_order),
            cloud_data.get('5m', {}).get('gc', 0),
            cloud_data.get('5m', {}).get('thickness', 0),
            cloud_data.get('5m', {}).get('angle', 0),
            cloud_data.get('5m', {}).get('fire_count', 0),
            cloud_data.get('5m', {}).get('elapsed', ''),
            cloud_data.get('5m', {}).get('distance_from_price', 0),
            cloud_data.get('5m', {}).get('distance_from_prev', 0),
            cloud_data.get('5m', {}).get('topPrice', 0),
            cloud_data.get('5m', {}).get('bottomPrice', 0),
            cloud_data.get('15m', {}).get('gc', 0),
            cloud_data.get('15m', {}).get('thickness', 0),
            cloud_data.get('15m', {}).get('angle', 0),
            cloud_data.get('15m', {}).get('fire_count', 0),
            cloud_data.get('15m', {}).get('elapsed', ''),
            cloud_data.get('15m', {}).get('distance_from_price', 0),
            cloud_data.get('15m', {}).get('distance_from_prev', 0),
            cloud_data.get('15m', {}).get('topPrice', 0),
            cloud_data.get('15m', {}).get('bottomPrice', 0),
            cloud_data.get('1H', {}).get('gc', 0),
            cloud_data.get('1H', {}).get('thickness', 0),
            cloud_data.get('1H', {}).get('angle', 0),
            cloud_data.get('1H', {}).get('fire_count', 0),
            cloud_data.get('1H', {}).get('elapsed', ''),
            cloud_data.get('1H', {}).get('distance_from_price', 0),
            cloud_data.get('1H', {}).get('distance_from_prev', 0),
            cloud_data.get('1H', {}).get('topPrice', 0),
            cloud_data.get('1H', {}).get('bottomPrice', 0),
            cloud_data.get('4H', {}).get('gc', 0),
            cloud_data.get('4H', {}).get('thickness', 0),
            cloud_data.get('4H', {}).get('angle', 0),
            cloud_data.get('4H', {}).get('fire_count', 0),
            cloud_data.get('4H', {}).get('elapsed', ''),
            cloud_data.get('4H', {}).get('distance_from_price', 0),
            cloud_data.get('4H', {}).get('distance_from_prev', 0),
            cloud_data.get('4H', {}).get('topPrice', 0),
            cloud_data.get('4H', {}).get('bottomPrice', 0)
        )
        
        # デバッグ: valuesの19番目(cloud_5m_topPrice)と20番目(cloud_5m_bottomPrice)を確認
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"values[19] (cloud_5m_topPrice): {values[19]}\n")
            f.write(f"values[20] (cloud_5m_bottomPrice): {values[20]}\n")
        
        if is_postgresql():
            # PostgreSQLの場合
            c.execute("""INSERT INTO current_states 
                         (symbol, timestamp, tf, price,
                          daily_dow_status, daily_dow_bos, daily_dow_time,
                          swing_dow_status, swing_dow_bos, swing_dow_time,
                          row_order,
                          cloud_order,
                          cloud_5m_gc, cloud_5m_thickness, cloud_5m_angle, cloud_5m_fire_count, cloud_5m_elapsed,
                          cloud_5m_distance_from_price, cloud_5m_distance_from_prev, cloud_5m_topPrice, cloud_5m_bottomPrice,
                          cloud_15m_gc, cloud_15m_thickness, cloud_15m_angle, cloud_15m_fire_count, cloud_15m_elapsed,
                          cloud_15m_distance_from_price, cloud_15m_distance_from_prev, cloud_15m_topPrice, cloud_15m_bottomPrice,
                          cloud_1h_gc, cloud_1h_thickness, cloud_1h_angle, cloud_1h_fire_count, cloud_1h_elapsed,
                          cloud_1h_distance_from_price, cloud_1h_distance_from_prev, cloud_1h_topPrice, cloud_1h_bottomPrice,
                          cloud_4h_gc, cloud_4h_thickness, cloud_4h_angle, cloud_4h_fire_count, cloud_4h_elapsed,
                          cloud_4h_distance_from_price, cloud_4h_distance_from_prev, cloud_4h_topPrice, cloud_4h_bottomPrice)
                         VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                         ON CONFLICT (symbol) DO UPDATE SET
                             timestamp = EXCLUDED.timestamp,
                             tf = EXCLUDED.tf,
                             price = EXCLUDED.price,
                             daily_dow_status = EXCLUDED.daily_dow_status,
                             daily_dow_bos = EXCLUDED.daily_dow_bos,
                             daily_dow_time = EXCLUDED.daily_dow_time,
                             swing_dow_status = EXCLUDED.swing_dow_status,
                             swing_dow_bos = EXCLUDED.swing_dow_bos,
                             swing_dow_time = EXCLUDED.swing_dow_time,
                             row_order = EXCLUDED.row_order,
                             cloud_order = EXCLUDED.cloud_order,
                             cloud_5m_gc = EXCLUDED.cloud_5m_gc,
                             cloud_5m_thickness = EXCLUDED.cloud_5m_thickness,
                             cloud_5m_angle = EXCLUDED.cloud_5m_angle,
                             cloud_5m_fire_count = EXCLUDED.cloud_5m_fire_count,
                             cloud_5m_elapsed = EXCLUDED.cloud_5m_elapsed,
                             cloud_5m_distance_from_price = EXCLUDED.cloud_5m_distance_from_price,
                             cloud_5m_distance_from_prev = EXCLUDED.cloud_5m_distance_from_prev,
                             cloud_5m_topPrice = EXCLUDED.cloud_5m_topPrice,
                             cloud_5m_bottomPrice = EXCLUDED.cloud_5m_bottomPrice,
                             cloud_15m_gc = EXCLUDED.cloud_15m_gc,
                             cloud_15m_thickness = EXCLUDED.cloud_15m_thickness,
                             cloud_15m_angle = EXCLUDED.cloud_15m_angle,
                             cloud_15m_fire_count = EXCLUDED.cloud_15m_fire_count,
                             cloud_15m_elapsed = EXCLUDED.cloud_15m_elapsed,
                             cloud_15m_distance_from_price = EXCLUDED.cloud_15m_distance_from_price,
                             cloud_15m_distance_from_prev = EXCLUDED.cloud_15m_distance_from_prev,
                             cloud_15m_topPrice = EXCLUDED.cloud_15m_topPrice,
                             cloud_15m_bottomPrice = EXCLUDED.cloud_15m_bottomPrice,
                             cloud_1h_gc = EXCLUDED.cloud_1h_gc,
                             cloud_1h_thickness = EXCLUDED.cloud_1h_thickness,
                             cloud_1h_angle = EXCLUDED.cloud_1h_angle,
                             cloud_1h_fire_count = EXCLUDED.cloud_1h_fire_count,
                             cloud_1h_elapsed = EXCLUDED.cloud_1h_elapsed,
                             cloud_1h_distance_from_price = EXCLUDED.cloud_1h_distance_from_price,
                             cloud_1h_distance_from_prev = EXCLUDED.cloud_1h_distance_from_prev,
                             cloud_1h_topPrice = EXCLUDED.cloud_1h_topPrice,
                             cloud_1h_bottomPrice = EXCLUDED.cloud_1h_bottomPrice,
                             cloud_4h_gc = EXCLUDED.cloud_4h_gc,
                             cloud_4h_thickness = EXCLUDED.cloud_4h_thickness,
                             cloud_4h_angle = EXCLUDED.cloud_4h_angle,
                             cloud_4h_fire_count = EXCLUDED.cloud_4h_fire_count,
                             cloud_4h_elapsed = EXCLUDED.cloud_4h_elapsed,
                             cloud_4h_distance_from_price = EXCLUDED.cloud_4h_distance_from_price,
                             cloud_4h_distance_from_prev = EXCLUDED.cloud_4h_distance_from_prev,
                             cloud_4h_topPrice = EXCLUDED.cloud_4h_topPrice,
                             cloud_4h_bottomPrice = EXCLUDED.cloud_4h_bottomPrice""",
                      values)
        else:
            # SQLiteの場合
            placeholders = ', '.join(['?'] * 48)
            c.execute(f"""INSERT OR REPLACE INTO current_states 
                         (symbol, timestamp, tf, price,
                          daily_dow_status, daily_dow_bos, daily_dow_time,
                          swing_dow_status, swing_dow_bos, swing_dow_time,
                          row_order,
                          cloud_order,
                          cloud_5m_gc, cloud_5m_thickness, cloud_5m_angle, cloud_5m_fire_count, cloud_5m_elapsed,
                          cloud_5m_distance_from_price, cloud_5m_distance_from_prev, cloud_5m_topPrice, cloud_5m_bottomPrice,
                          cloud_15m_gc, cloud_15m_thickness, cloud_15m_angle, cloud_15m_fire_count, cloud_15m_elapsed,
                          cloud_15m_distance_from_price, cloud_15m_distance_from_prev, cloud_15m_topPrice, cloud_15m_bottomPrice,
                          cloud_1h_gc, cloud_1h_thickness, cloud_1h_angle, cloud_1h_fire_count, cloud_1h_elapsed,
                          cloud_1h_distance_from_price, cloud_1h_distance_from_prev, cloud_1h_topPrice, cloud_1h_bottomPrice,
                          cloud_4h_gc, cloud_4h_thickness, cloud_4h_angle, cloud_4h_fire_count, cloud_4h_elapsed,
                          cloud_4h_distance_from_price, cloud_4h_distance_from_prev, cloud_4h_topPrice, cloud_4h_bottomPrice)
                         VALUES ({placeholders})""",
                      values)
        
        conn.commit()
        conn.close()
        
        print(f"💾 Data saved to database for {symbol}")
        
        # Analyze clouds and generate notifications (発火時のみ通知)
        # notifications = analyze_clouds(symbol, price, clouds)
        notifications = []  # 一時的に空のリストに
        
        print(f"🔔 Notifications generated: {len(notifications)}")
        
        # 発火履歴を保存（通知が発生した時のみ）
        if len(notifications) > 0:
            conn = get_db_connection()
            c = conn.cursor()
            for notif in notifications:
                if is_postgresql():
                    c.execute("""INSERT INTO fire_history (timestamp, symbol, cloud_label, fire_count, gc, message)
                                 VALUES (%s, %s, %s, %s, %s, %s)""",
                              (datetime.now().isoformat(), symbol, notif['cloud_label'], 
                               cloud_data.get(notif['cloud_label'], {}).get('fire_count', 0),
                               cloud_data.get(notif['cloud_label'], {}).get('gc', 0),
                               notif['message']))
                else:
                    c.execute("""INSERT INTO fire_history (timestamp, symbol, cloud_label, fire_count, gc, message)
                                 VALUES (?, ?, ?, ?, ?, ?)""",
                              (datetime.now().isoformat(), symbol, notif['cloud_label'], 
                               cloud_data.get(notif['cloud_label'], {}).get('fire_count', 0),
                               cloud_data.get(notif['cloud_label'], {}).get('gc', 0),
                               notif['message']))
            conn.commit()
            conn.close()
        
        # Send Discord notifications (発火時のみ)
        for notif in notifications:
            send_discord_notification(notif['line_message'])
            
            # Forward to local client
            forward_to_local_client({
                'alert_type': notif['alert_type'],
                'message': notif['message'],
                'symbol': symbol,
                'price': price,
                'cloud_label': notif['cloud_label']
            })
        
        return jsonify({'status': 'success', 'message': 'State updated', 'notifications': len(notifications)}), 200
        
    except Exception as e:
        error_msg = f"❌ Error in webhook: {e}"
        print(error_msg, flush=True)
        import traceback
        traceback_str = traceback.format_exc()
        print(traceback_str, flush=True)
        
        with open('debug_webhook.txt', 'a', encoding='utf-8') as f:
            f.write(f"{error_msg}\n")
            f.write(f"Traceback:\n{traceback_str}\n")
        
        logger.error(f"{error_msg}\n{traceback_str}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy'}), 200

@app.route('/', methods=['GET'])
def dashboard():
    """Webダッシュボード"""
    response = app.make_response(render_template('dashboard.html'))
    response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '0'
    return response

@app.route('/current_states', methods=['GET'])
def get_current_states():
    """全通貨ペアの現在状態を取得"""
    try:
        print("📊 /current_states endpoint called")
        conn = get_db_connection()
        if is_postgresql():
            try:
                import psycopg2.extras
                cursor_factory = psycopg2.extras.RealDictCursor
            except ImportError:
                cursor_factory = None
            
            if cursor_factory:
                c = conn.cursor(cursor_factory=cursor_factory)
                c.execute("""SELECT * FROM current_states ORDER BY symbol""")
                states = c.fetchall()
                conn.close()
                
                print(f"✅ PostgreSQL: Found {len(states)} states")
                
                result = []
                for s in states:
                    result.append({
                        'symbol': s['symbol'],
                        'timestamp': s['timestamp'],
                        'tf': s['tf'],
                        'price': s['price'],
                        'daily_dow': {
                            'status': s['daily_dow_status'] or '',
                            'bos': s['daily_dow_bos'] or '',
                            'time': s['daily_dow_time'] or ''
                        },
                        'swing_dow': {
                            'status': s['swing_dow_status'] or '',
                            'bos': s['swing_dow_bos'] or '',
                            'time': s['swing_dow_time'] or ''
                        },
                        'row_order': s['row_order'].split(',') if s['row_order'] else ['price', '5m', '15m', '1H', '4H'],
                        'cloud_order': s['cloud_order'].split(',') if s['cloud_order'] else ['5m', '15m', '1H', '4H'],
                        'clouds': {
                            '5m': {
                                'gc': bool(s['cloud_5m_gc']),
                                'thickness': s['cloud_5m_thickness'],
                                'angle': s['cloud_5m_angle'],
                                'fire_count': s['cloud_5m_fire_count'],
                                'elapsed': s['cloud_5m_elapsed'],
                                'distance_from_price': s['cloud_5m_distance_from_price'],
                                'distance_from_prev': s['cloud_5m_distance_from_prev'],
                                'topPrice': s['cloud_5m_topPrice'],
                                'bottomPrice': s['cloud_5m_bottomPrice']
                            },
                            '15m': {
                                'gc': bool(s['cloud_15m_gc']),
                                'thickness': s['cloud_15m_thickness'],
                                'angle': s['cloud_15m_angle'],
                                'fire_count': s['cloud_15m_fire_count'],
                                'elapsed': s['cloud_15m_elapsed'],
                                'distance_from_price': s['cloud_15m_distance_from_price'],
                                'distance_from_prev': s['cloud_15m_distance_from_prev'],
                                'topPrice': s['cloud_15m_topPrice'],
                                'bottomPrice': s['cloud_15m_bottomPrice']
                            },
                            '1H': {
                                'gc': bool(s['cloud_1h_gc']),
                                'thickness': s['cloud_1h_thickness'],
                                'angle': s['cloud_1h_angle'],
                                'fire_count': s['cloud_1h_fire_count'],
                                'elapsed': s['cloud_1h_elapsed'],
                                'distance_from_price': s['cloud_1h_distance_from_price'],
                                'distance_from_prev': s['cloud_1h_distance_from_prev'],
                                'topPrice': s['cloud_1h_topPrice'],
                                'bottomPrice': s['cloud_1h_bottomPrice']
                            },
                            '4H': {
                                'gc': bool(s['cloud_4h_gc']),
                                'thickness': s['cloud_4h_thickness'],
                                'angle': s['cloud_4h_angle'],
                                'fire_count': s['cloud_4h_fire_count'],
                                'elapsed': s['cloud_4h_elapsed'],
                                'distance_from_price': s['cloud_4h_distance_from_price'],
                                'distance_from_prev': s['cloud_4h_distance_from_prev'],
                                'topPrice': s['cloud_4h_topPrice'],
                                'bottomPrice': s['cloud_4h_bottomPrice']
                            }
                        }
                    })
                
                print(f"📤 Returning {len(result)} states to client")
                return jsonify({
                    'status': 'success',
                    'states': result
                }), 200
            else:
                # psycopg2が利用できない場合はSQLiteとして扱う
                c = conn.cursor()
                c.execute("""SELECT * FROM current_states ORDER BY symbol""")
                states = c.fetchall()
                conn.close()
                
                print(f"✅ SQLite fallback: Found {len(states)} states")
                
                result = []
                for s in states:
                    result.append({
                        'symbol': s[0],
                        'timestamp': s[1],
                        'tf': s[2],
                        'price': s[3],
                        'daily_dow': {
                            'status': s[4] or '',
                            'bos': s[5] or '',
                            'time': s[6] or ''
                        },
                        'swing_dow': {
                            'status': s[7] or '',
                            'bos': s[8] or '',
                            'time': s[9] or ''
                        },
                        'row_order': s[10].split(',') if s[10] else ['price', '5m', '15m', '1H', '4H'],
                        'cloud_order': s[11].split(',') if s[11] else ['5m', '15m', '1H', '4H'],
                        'clouds': {
                            '5m': {
                                'gc': bool(s[12]),
                                'thickness': s[13],
                                'angle': s[14],
                                'fire_count': s[15],
                                'elapsed': s[16],
                                'distance_from_price': s[17],
                                'distance_from_prev': s[18],
                                'topPrice': s[19],
                                'bottomPrice': s[20]
                            },
                            '15m': {
                                'gc': bool(s[21]),
                                'thickness': s[22],
                                'angle': s[23],
                                'fire_count': s[24],
                                'elapsed': s[25],
                                'distance_from_price': s[26],
                                'distance_from_prev': s[27],
                                'topPrice': s[28],
                                'bottomPrice': s[29]
                            },
                            '1H': {
                                'gc': bool(s[30]),
                                'thickness': s[31],
                                'angle': s[32],
                                'fire_count': s[33],
                                'elapsed': s[34],
                                'distance_from_price': s[35],
                                'distance_from_prev': s[36],
                                'topPrice': s[37],
                                'bottomPrice': s[38]
                            },
                            '4H': {
                                'gc': bool(s[39]),
                                'thickness': s[40],
                                'angle': s[41],
                                'fire_count': s[42],
                                'elapsed': s[43],
                                'distance_from_price': s[44],
                                'distance_from_prev': s[45],
                                'topPrice': s[46],
                                'bottomPrice': s[47]
                            }
                        }
                    })
                
                return jsonify({
                    'status': 'success',
                    'states': result
                }), 200
        else:
            # SQLiteの場合
            c = conn.cursor()
            c.execute("""SELECT * FROM current_states ORDER BY symbol""")
            states = c.fetchall()
            conn.close()
            
            result = []
            for s in states:
                result.append({
                    'symbol': s[0],
                    'timestamp': s[1],
                    'tf': s[2],
                    'price': s[3],
                    'daily_dow': {
                        'status': s[4] or '',
                        'bos': s[5] or '',
                        'time': s[6] or ''
                    },
                    'swing_dow': {
                        'status': s[7] or '',
                        'bos': s[8] or '',
                        'time': s[9] or ''
                    },
                    'row_order': s[10].split(',') if s[10] else ['price', '5m', '15m', '1H', '4H'],
                    'cloud_order': s[11].split(',') if s[11] else ['5m', '15m', '1H', '4H'],
                    'clouds': {
                        '5m': {
                            'gc': bool(s[12]),
                            'thickness': s[13],
                            'angle': s[14],
                            'fire_count': s[15],
                            'elapsed': s[16],
                            'distance_from_price': s[17],
                            'distance_from_prev': s[18],
                            'topPrice': s[19],
                            'bottomPrice': s[20]
                        },
                        '15m': {
                            'gc': bool(s[21]),
                            'thickness': s[22],
                            'angle': s[23],
                            'fire_count': s[24],
                            'elapsed': s[25],
                            'distance_from_price': s[26],
                            'distance_from_prev': s[27],
                            'topPrice': s[28],
                            'bottomPrice': s[29]
                        },
                        '1H': {
                            'gc': bool(s[30]),
                            'thickness': s[31],
                            'angle': s[32],
                            'fire_count': s[33],
                            'elapsed': s[34],
                            'distance_from_price': s[35],
                            'distance_from_prev': s[36],
                            'topPrice': s[37],
                            'bottomPrice': s[38]
                        },
                        '4H': {
                            'gc': bool(s[39]),
                            'thickness': s[40],
                            'angle': s[41],
                            'fire_count': s[42],
                            'elapsed': s[43],
                            'distance_from_price': s[44],
                            'distance_from_prev': s[45],
                            'topPrice': s[46],
                            'bottomPrice': s[47]
                        }
                    }
                })
        
        return jsonify({
            'status': 'success',
            'states': result
        }), 200
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

@app.route('/fire_history', methods=['GET'])
def get_fire_history():
    """発火履歴を取得"""
    try:
        conn = get_db_connection()
        if is_postgresql():
            try:
                import psycopg2.extras
                cursor_factory = psycopg2.extras.RealDictCursor
            except ImportError:
                cursor_factory = None
            
            if cursor_factory:
                c = conn.cursor(cursor_factory=cursor_factory)
                c.execute("""SELECT * FROM fire_history ORDER BY timestamp DESC LIMIT 50""")
                history = c.fetchall()
                conn.close()
                
                result = []
                for h in history:
                    result.append({
                        'id': h['id'],
                        'timestamp': h['timestamp'],
                        'symbol': h['symbol'],
                        'cloud_label': h['cloud_label'],
                        'fire_count': h['fire_count'],
                        'gc': bool(h['gc']),
                        'message': h['message']
                    })
                
                return jsonify({
                    'status': 'success',
                    'history': result
                }), 200
            else:
                # psycopg2が利用できない場合はSQLiteとして扱う
                c = conn.cursor()
                c.execute("""SELECT * FROM fire_history ORDER BY timestamp DESC LIMIT 50""")
                history = c.fetchall()
                conn.close()
                
                result = []
                for h in history:
                    result.append({
                        'id': h[0],
                        'timestamp': h[1],
                        'symbol': h[2],
                        'cloud_label': h[3],
                        'fire_count': h[4],
                        'gc': bool(h[5]),
                        'message': h[6]
                    })
                
                return jsonify({
                    'status': 'success',
                    'history': result
                }), 200
        else:
            # SQLiteの場合
            c = conn.cursor()
            c.execute("""SELECT * FROM fire_history ORDER BY timestamp DESC LIMIT 50""")
            history = c.fetchall()
            conn.close()
            
            result = []
            for h in history:
                result.append({
                    'id': h[0],
                    'timestamp': h[1],
                    'symbol': h[2],
                    'cloud_label': h[3],
                    'fire_count': h[4],
                    'gc': bool(h[5]),
                    'message': h[6]
                })
        
        return jsonify({
            'status': 'success',
            'history': result
        }), 200
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

def open_browser():
    """サーバー起動後にブラウザを自動で開く"""
    webbrowser.open('http://localhost:5000')

if __name__ == '__main__':
    init_db()
    port = int(os.environ.get('PORT', 5000))
    
    # Render環境ではブラウザ自動起動を無効化
    # dev_server.pyから起動される場合もブラウザを開かない（dev_server.py側で制御）
    if os.environ.get('RENDER') != 'true' and os.environ.get('FLASK_ENV') != 'development':
        # 本番環境でrender_server.pyを直接起動した場合のみブラウザを開く
        if os.environ.get('WERKZEUG_RUN_MAIN') != 'true':
            threading.Timer(1.5, open_browser).start()
    
    # デバッグモードを有効化してエラー詳細を表示
    app.run(host='0.0.0.0', port=port, debug=False)
